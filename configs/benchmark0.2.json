{
    "config_type": "expanded_xega_config",
    "metadata": {
        "judge_model": "Qwen/Qwen3-14B-Base",
        "num_rounds_per_game": 20,
        "seed": "notrandom",
        "benchmark_id": "benchmark_0.2",
        "xega_version": "0.1.0"
    },
    "players": [
        {
            "name": "black",
            "id": "gpt-5",
            "player_type": "default",
            "options": {
                "model": "gpt-5",
                "provider": "openai"
            }
        },
        {
            "name": "black",
            "id": "gpt-5-mini",
            "player_type": "default",
            "options": {
                "model": "gpt-5-mini",
                "provider": "openai"
            }
        },
        {
            "name": "black",
            "id": "gpt-5-nano",
            "player_type": "default",
            "options": {
                "model": "gpt-5-nano",
                "provider": "openai"
            }
        },
        {
            "name": "black",
            "id": "claude-opus-4-1-20250805",
            "player_type": "default",
            "options": {
                "model": "claude-opus-4-1-20250805",
                "provider": "anthropic"
            }
        },
        {
            "name": "black",
            "id": "claude-opus-4-20250514",
            "player_type": "default",
            "options": {
                "model": "claude-opus-4-20250514",
                "provider": "anthropic"
            }
        },
        {
            "name": "black",
            "id": "claude-sonnet-4-20250514",
            "player_type": "default",
            "options": {
                "model": "claude-sonnet-4-20250514",
                "provider": "anthropic"
            }
        },
        {
            "name": "black",
            "id": "grok-4-0709",
            "player_type": "default",
            "options": {
                "model": "grok-4-0709",
                "provider": "grok"
            }
        },
        {
            "name": "black",
            "id": "gemini-2.5-pro",
            "player_type": "default",
            "options": {
                "model": "gemini-2.5-pro",
                "provider": "gemini"
            }
        },
        {
            "name": "black",
            "id": "gemini-2.5-flash",
            "player_type": "default",
            "options": {
                "model": "gemini-2.5-flash",
                "provider": "gemini"
            }
        },
        {
            "name": "black",
            "id": "deepseek-reasoner",
            "player_type": "default",
            "options": {
                "model": "deepseek-reasoner",
                "provider": "deepseek"
            }
        },
        {
            "name": "black",
            "id": "deepseek-chat",
            "player_type": "default",
            "options": {
                "model": "deepseek-chat",
                "provider": "deepseek"
            }
        }
    ],
    "games": [
        {
            "name": "Condense",
            "code": "assign(s=story())\nelicit(x, 10)\nassign(x1=remove_common_words(x, s))\nreveal(x1)\nreward(xed(s | x1))\n",
            "presentation_function": "from xega.presentation.sdk import (\n    PresentationBuilder,\n    extract_attempts,\n    extract_reveals,\n    extract_rewards,\n    format_reward,\n    get_max_score,\n    split_rounds,\n)\n\n\ndef present(state, history):\n    # Extract data using SDK utilities\n    rounds = split_rounds(history)\n    all_rewards = extract_rewards(history)\n    best_score, _ = get_max_score(all_rewards) if all_rewards else (None, None)\n\n    # Calculate current round number\n    round_number = len(rounds) - 1\n\n    # Build presentation using the builder\n    builder = PresentationBuilder()\n\n    # Game header\n    header = \"\"\"You are playing a text game that uses the cross-entropy function of an LLM (Qwen3-14B-Base) to compute score.\n\n<gameCode>\nassign(s=story())\nelicit(x, 10)\nassign(x1=remove_common_words(x, s))\nreveal(x1)\nreward(xed(s | x1))\n</gameCode>\n\nYou will be given a short story, and your task is to provide a prefix that makes that story as predictable as possible. Think of it as providing context that helps predict what comes next.\n\nThe scoring measures how much information your prefix provides about the story. Specifically, your score is the difference between the story's baseline cross-entropy and its cross-entropy given your prefix: `Score = crossEntropy(story) - crossEntropy(story | prefix)`. Your goal is to maximize this score. So you want to find a prefix that will most help an LLM predict the story.\n\nAfter each attempt, you'll see your score and a per-token breakdown of the cross entropy difference. The game automatically restarts after each successful attempt, allowing you to continuously optimize your approach. Use the feedback from previous rounds to improve your score.  Your final score is the maximum score you obtain over 30 rounds, so you should not worry about decreasing temporarily your score.\n\nYou cannot use any words that appear in the story itself (regardless of case or punctuation). Your prefix is limited to 10 tokens maximum.\n\nProvide your prefix in <move></move> tags. Any other text in your response will be ignored.\"\"\"\n\n    builder.add_header(header)\n    builder.add_line(\"\")\n\n    # Current story\n    builder.add_line(\"The story:\")\n    builder.start_section(\"story\")\n    builder.add_line(str(state[\"s\"]))\n    builder.end_section()\n\n    # Game history\n    if len(rounds) == 1:\n        builder.add_line(\"First round starting.\")\n    else:\n        builder.start_section(\"gameHistory\")\n\n        # Process each completed round\n        for i in range(len(rounds) - 1):\n            round_events = rounds[i]\n            rewards = extract_rewards(round_events)\n            response = extract_attempts(round_events)[0][\"response\"]\n            reveal = extract_reveals(round_events)[0][\"values\"][\"x1\"]\n\n            builder.start_section(f\"round{i}\")\n            if response == reveal:\n                builder.add_line(f\"<prefix>{response}</prefix>\")\n            else:\n                builder.add_line(f\"<move>{response}</move>\")\n                builder.add_line(f\"<prefix>{reveal}</prefix>\")\n\n            # Format the score\n            builder.start_section(\"score\")\n            builder.add_lines(format_reward(rewards[0])[0])\n            builder.end_section()\n\n            builder.end_section()\n\n        # Current round marker\n        builder.add_current_round_marker(round_number)\n        builder.end_section()\n\n        builder.add_line(\"\")\n        if best_score is not None:\n            builder.add_line(f\"Best score achieved: {best_score:.3f}\")\n\n        builder.add_line(\"Remember: You want to maximize your score. Higher is better!\")\n        builder.add_line(\"\")\n\n    builder.add_line(\"Provide your prefix in <move></move> tags.\")\n\n    return builder.render()\n"
        },
        {
            "name": "Contrast",
            "code": "assign(s1=story(), s2=story())\nelicit(x, 10)\nassign(x1=remove_common_words(x, s1 + s2))\nreveal(x1)\nreward(black, xed(s1 | x1))\nreward(black, dex(s2 | x1))\n",
            "presentation_function": "from xega.presentation.sdk import (\n    PresentationBuilder,\n    extract_reveals,\n    extract_rewards,\n    format_reward,\n    split_rounds,\n)\n\n\ndef present(state, history):\n    # Extract game state\n    s1 = state[\"s1\"]\n    s2 = state[\"s2\"]\n\n    # Parse history and track best score\n    rounds = split_rounds(history)\n    best_contrast_score = None\n    completed_round_count = 0\n\n    # Build presentation\n    builder = PresentationBuilder()\n\n    # Game header\n    header = \"\"\"You are playing a text game that uses the cross-entropy function of an LLM (Qwen3-14B-Base) to compute score.\n\n<gameCode>\nassign(s=story())\nelicit(x, 10)\nassign(x1=remove_common_words(x, s))\nreveal(x1)\nreward(xed(s | x1))\n</gameCode>\n\nYou will be given two short stories, and your task is to find a prefix that creates maximum contrast between them - a prefix that helps predict the first story while making the second story less predictable.\n\nThe scoring measures this contrast effect:\n- For story 1: Your score measures how much your prefix helps predict it (higher = better)\n- For story 2: Your score measures how much your prefix makes it diverge from expectations (higher = better contrast)\n- Combined score: `Total Score = [xent(story1) - xent(story1 | prefix)] + [xent(story2 | prefix) - xent(story2)]`\n\nYour goal is to maximize this total score. You want a prefix that simultaneously helps predict story 1 while making story 2 surprising - creating maximum contrast between the two stories.\n\nAfter each attempt, you'll see individual scores showing how well you're helping story 1 and hindering story 2, plus your combined contrast score. You can play multiple rounds to continuously improve your approach. Your final score is the maximum score you obtain over 30 rounds, so you should not worry about decreasing temporarily your score.\n\nYou cannot use any words that appear in either story (regardless of case or punctuation). Your prefix is limited to 10 tokens maximum.\n\nProvide your prefix in <move></move> tags. Any other text in your response will be ignored.\"\"\"\n\n    builder.add_header(header)\n    builder.add_line(\"\")\n\n    # Present the two stories\n    builder.add_line(\"The two stories to contrast:\")\n    builder.add_line(f\"Make this predictable: <story1>{s1}</story1>\")\n    builder.add_line(f\"Make this surprising: <story2>{s2}</story2>\")\n\n    if len(rounds) == 1:\n        builder.add_line(\"\")\n        builder.add_line(\"Round 1 starting.\")\n    else:\n        builder.add_line(\"\")\n        builder.add_line(\"--- Play History ---\")\n        builder.add_line(\"\")\n        builder.start_section(\"gameHistory\")\n\n        for round_num in range(len(rounds) - 1):\n            round_events = rounds[round_num]\n            rewards = extract_rewards(round_events)\n            completed_round_count += 1\n\n            # Get the response for this round\n            response = next(e for e in round_events if e[\"type\"] == \"elicit_response\")[\n                \"response\"\n            ]\n            prefix = extract_reveals(round_events)[0][\"values\"][\"x1\"]\n\n            # Calculate scores\n            (story1_score_str, story1_score) = format_reward(rewards[0])\n            (story2_score_str, story2_score) = format_reward(rewards[1])\n            contrast_score = round(story1_score + story2_score, 3)\n\n            # Track best score\n            if best_contrast_score is None or contrast_score > best_contrast_score:\n                best_contrast_score = contrast_score\n\n            # Render this round immediately\n            builder.start_section(f\"round{round_num}\")\n            if response == prefix:\n                builder.add_line(f\"<prefix>{response}</prefix>\")\n            else:\n                builder.add_line(f\"<move>{response}</move>\")\n                builder.add_line(f\"<prefix>{prefix}</prefix>\")\n            builder.start_section(\"scores\")\n\n            # Story 1 score (predictability boost)\n            builder.start_section(\"story1_predictability\")\n            builder.add_lines(story1_score_str)\n            builder.end_section()\n\n            # Story 2 score (surprise factor)\n            builder.start_section(\"story2_surprise\")\n            builder.add_lines(story2_score_str)\n            builder.end_section()\n\n            # Combined contrast score\n            builder.add_line(f\"<contrastScore>{contrast_score}</contrastScore>\")\n            builder.end_section()\n            builder.end_section()\n\n        # Current round marker\n        builder.add_current_round_marker(completed_round_count)\n        builder.end_section()\n\n        builder.add_line(\"\")\n        if best_contrast_score is not None:\n            builder.add_line(f\"Best contrast score achieved: {best_contrast_score}\")\n            builder.add_line(\n                \"Remember: maximize your score by helping story 1 while hindering story 2!\"\n            )\n        builder.add_line(\"\")\n\n    builder.add_line(\"Provide your prefix in <move></move> tags.\")\n\n    return builder.render()\n"
        },
        {
            "name": "Alethiometer",
            "code": "assign(s=story())\nassign(s1=\"alpha-omega anchor angel ant apple baby beehive bird bread bull camel candle cauldron chameleon compass cornucopia crocodile dolphin elephant globe griffin helmet horse hourglass lute madonna marionette moon owl serpent sun sword thunderbolt tree walled-garden wild-man\")\nelicit(x, 40)\nensure(only_uses_words(s1, x))\nassign(x1=\"Lyra bent over her Alethiometer. The dial spun to these symbols: \\\"\" + x + \"\\\". Lyra looked up and said \\\"it tells me this\\\":\")\nreward(xed(s | x1))\n",
            "presentation_function": "from xega.presentation.sdk import (\n    PresentationBuilder,\n    extract_attempts,\n    extract_rewards,\n    format_attempt,\n    format_reward,\n    split_rounds,\n)\n\n\ndef present(state, history):\n    # Extract game state\n    story = state[\"s\"]\n    valid_symbols = state[\"s1\"]\n\n    # Build presentation\n    builder = PresentationBuilder()\n\n    # Rich header with complete game explanation\n    header = \"\"\"You are playing a text game that uses the cross-entropy function of an LLM (Qwen3-14B-Base) to compute score.\n\n<gameCode>\nassign(s=story())\nassign(s1=\"alpha-omega anchor angel ant apple baby beehive bird bread bull camel candle cauldron chameleon compass cornucopia crocodile dolphin elephant globe griffin helmet horse hourglass lute madonna marionette moon owl serpent sun sword thunderbolt tree walled-garden wild-man\")\nelicit(x, 40)\nensure(only_uses_words(s1, x))\nassign(x1=\"Lyra bent over her Alethiometer. The dial spun to these symbols: \\\"\" + x + \"\\\". Lyra looked up and said \\\"it tells me this\\\":\")\nreward(xed(s | x1))\n</gameCode>\n\nIn this game, you are given a target story and a set of mystical symbols. Your goal is to select and arrange symbols that, when read through Lyra's Alethiometer, best predict the given story.\n\nThink of this as reverse prompt engineering: you know the output (the story) and must craft the optimal input (symbol sequence) to make that output most likely.\n\nYour symbols will be inserted into this template:\n\"Lyra bent over her Alethiometer. The dial spun to these symbols: \\\"[YOUR_SYMBOLS]\\\". Lyra looked up and said \\\"it tells me this\\\":\"\n\nThe game then measures how predictable the story becomes after this prompt. The scoring formula is:\nScore = crossEntropy(story) - crossEntropy(story | prompt_with_your_symbols)\n\nA higher score means your symbols create a better prompt that makes the story more predictable. The baseline is just the story without any prompt context.\n\nYour goal is to maximize your score by finding the symbol combination that best connects to the story's themes, characters, or events. Each symbol can carry multiple meanings - like the actual Alethiometer from His Dark Materials.\n\nYou have multiple rounds to optimize your score. After each attempt, you'll see:\n- Your total score (higher is better)\n- Per-token cross-entropy showing which parts of the story responded best to your symbols\nUse this feedback to refine your symbol choices in subsequent rounds. Your final score is the maximum score you obtain over 30 rounds, so you should not worry about decreasing temporarily your score.\n\n\nYour symbol sequence can be up to 40 characters long. You MUST use only the valid symbols provided below. Any invalid symbols will cause your attempt to be rejected.\n\nProvide your symbol sequence in <move></move> tags. Any other text in your response will be ignored.\"\"\"\n\n    builder.add_header(header)\n    builder.add_line(\"\")\n    builder.add_line(f\"<targetStory>{story}</targetStory>\")\n    builder.add_line(\"\")\n    builder.add_line(\"<validSymbols>\")\n    builder.add_line(str(valid_symbols))\n    builder.add_line(\"</validSymbols>\")\n\n    # Split history into rounds\n    rounds = split_rounds(history)\n\n    # Track best score\n    best_score = None\n\n    # Process and display history\n    builder.add_line(\"\")\n    builder.add_line(\"A history of your play so far:\")\n    builder.add_line(\"\")\n    builder.start_section(\"fullHistory\")\n\n    # Process each round\n    for i in range(len(rounds) - 1):\n        # This is a completed round\n        round_score = render_complete_round(rounds[i], builder, i + 1)\n        if round_score is not None and (best_score is None or round_score > best_score):\n            best_score = round_score\n\n    # Handle current round (if it has any attempts)\n    current_round = rounds[-1]\n    render_current_round(current_round, builder, len(rounds))\n\n    builder.end_section()\n\n    # Show current game status\n    builder.add_line(\"\")\n    builder.add_line(\"Current game status:\")\n    builder.add_line(f\"Target story: {story}\")\n\n    if best_score is not None:\n        builder.add_line(f\"Best score achieved: {best_score:.1f}\")\n\n    builder.add_line(\"\")\n    builder.add_line(\n        \"Remember: Use only the valid symbols shown above. Each symbol can appear multiple times.\"\n    )\n    builder.add_line(\"\")\n    builder.add_line(\"Provide your symbol sequence in <move></move> tags.\")\n\n    return builder.render()\n\n\ndef render_complete_round(round_events, builder, round_num):\n    \"\"\"Render a completed round with all attempts and final score\"\"\"\n\n    # Extract attempts with failure tracking\n    attempts = extract_attempts(\n        round_events, reason=\"Contains invalid symbols not in the allowed set\"\n    )\n\n    if not attempts:\n        return None\n\n    builder.start_section(f\"round{round_num}\")\n    builder.start_section(\"symbolSelection\")\n\n    # Show all attempts\n    for attempt in attempts:\n        builder.add_line(format_attempt(**attempt))\n\n    builder.end_section()\n\n    # Get and display score\n    rewards = extract_rewards(round_events)\n    if rewards:\n        reward = rewards[0]\n        reward_str, reward_score = format_reward(reward)\n        builder.start_section(\"score\")\n        builder.add_lines(reward_str)\n        builder.end_section()\n\n        builder.end_section()\n        return reward_score\n\n    builder.end_section()\n    return None\n\n\ndef render_current_round(round_events, builder, round_num):\n    \"\"\"Render the current incomplete round\"\"\"\n\n    # Extract attempts\n    attempts = extract_attempts(\n        round_events, reason=\"Contains invalid symbols not in the allowed set\"\n    )\n\n    builder.start_section(f\"round{round_num}\")\n    builder.start_section(\"symbolSelection\")\n\n    # Show any failed attempts\n    for attempt in attempts:\n        if attempt[\"failed\"]:\n            builder.add_line(format_attempt(**attempt))\n\n    # Show where we are\n    builder.add_line(\"You are HERE. Provide a valid symbol sequence.\")\n\n    builder.end_section()\n    builder.end_section()\n"
        },
        {
            "name": "Two-Ways",
            "code": "assign(s1=story(), s2=story())\nassign(s=\"I have a fun story to tell you:\")\nelicit(t, 10)\nreward(nex(s2 | s + s1 + t))\nreward(nex(s1 | s + s2 + t))\nreward(xent(s2 | s + s1))\nreward(xent(s1 | s + s2))\n# TODO consider doing min for the reward to make it the lesser of the two direction",
            "presentation_function": "from xega.presentation.sdk import (\n    PresentationBuilder,\n    extract_rewards,\n    format_token_xent_list,\n    split_rounds,\n)\n\n\ndef present(state, history):\n    # Extract game state\n    story_a = state[\"s1\"]\n    story_c = state[\"s2\"]\n\n    # Build presentation\n    builder = PresentationBuilder()\n\n    # Game header\n    header = \"\"\"You are playing a text game that uses the cross-entropy function of an LLM (Qwen3-14B-Base) to compute score.\n\n<gameCode>\nassign(s1=story(), s2=story())\nassign(s=\"I have a fun story to tell you:\")\nelicit(t, 10)\nreward(nex(s2 | s + s1 + t))\nreward(nex(s1 | s + s2 + t))\nreward(xent(s2 | s + s1))\nreward(xent(s1 | s + s2))\n</gameCode>\n\nIn this game you are given 2 short texts A and C. Your goal is to create a bridge text B such that the text ABC makes sense and CBA also makes sense.\n\nThe scoring will be computed using the cross entropy of C given AB plus the cross entropy of A given CB. Specifically `-1 * (crossEntropy(C | AB) + crossEntropy(A | CB))`. So the more likely you can make the text in both directions, the higher your score will be.\n\nYour goal is to optimize your score. So try to provide bridge text B (max 10 tokens) such that A\u2192B\u2192C flows naturally and C\u2192B\u2192A also flows naturally.\n\nYou will have multiple attempts to improve your score. After each attempt, you will be given the per-token cross entropy of the scored text. Use this information to improve your score on the next round. Your final score is the maximum score you obtain over 30 rounds, so you should not worry about decreasing temporarily your score.\n\n\nYour move can only be 10 tokens long in total. Anything beyond that will be truncated. Provide your move in <move></move> tags. Any other text in your response will be ignored.\"\"\"\n\n    builder.add_header(header)\n\n    # Split history into rounds\n    rounds = split_rounds(history)\n\n    # Track best score\n    best_score = None\n\n    # Show game history if any completed rounds exist\n    if rounds and any(extract_rewards(r) for r in rounds):\n        builder.add_line(\"\")\n        builder.start_section(\"gameHistory\")\n\n        for i, round_events in enumerate(rounds):\n            rewards = extract_rewards(round_events)\n            if rewards and len(rewards) >= 2:  # Only show completed rounds with scores\n                render_complete_round(round_events, builder, i + 1)\n\n                # Track best score (first two rewards only)\n                total_score = (\n                    rewards[0][\"value\"].total_xent() + rewards[1][\"value\"].total_xent()\n                )\n                if best_score is None or total_score > best_score:\n                    best_score = total_score\n\n        builder.end_section()\n\n    # Show current game status\n    builder.add_line(\"\")\n    builder.add_line(\"Current game status:\")\n    builder.add_line(f\"<storyA>{story_a}</storyA>\")\n    builder.add_line(f\"<storyC>{story_c}</storyC>\")\n    builder.add_line(\"\")\n    builder.add_line(\n        'Your goal: Create a bridge text B that makes both \"A\u2192B\u2192C\" and \"C\u2192B\u2192A\" flow naturally.'\n    )\n\n    if best_score is not None:\n        builder.add_line(f\"Best score so far: {best_score:.3f}\")\n\n    builder.add_line(\"\")\n    builder.add_line(\"Provide your bridge text in <move></move> tags.\")\n\n    return builder.render()\n\n\ndef render_complete_round(round_events, builder, round_num):\n    # Extract the response (bridge text)\n    response_event = next(\n        (e for e in round_events if e[\"type\"] == \"elicit_response\"), None\n    )\n\n    if not response_event:\n        return\n\n    # Get rewards (only first two are actual scores)\n    rewards = extract_rewards(round_events)\n    if len(rewards) < 2:\n        return\n\n    builder.start_section(f\"round{round_num}\")\n\n    # Show the bridge text\n    builder.add_line(f\"<bridge>{response_event['response']}</bridge>\")\n\n    # Score ABC (first reward)\n    abc_reward = rewards[0]\n    abc_score = abc_reward[\"value\"].total_xent()\n    builder.start_section(\"scoreABC\")\n    builder.add_line(f\"Total: {abc_score:.3f}\")\n    builder.add_line(f\"Per-token: {format_token_xent_list(abc_reward['value'])}\")\n    builder.end_section()\n\n    # Score CBA (second reward)\n    cba_reward = rewards[1]\n    cba_score = cba_reward[\"value\"].total_xent()\n    builder.start_section(\"scoreCBA\")\n    builder.add_line(f\"Total: {cba_score:.3f}\")\n    builder.add_line(f\"Per-token: {format_token_xent_list(cba_reward['value'])}\")\n    builder.end_section()\n\n    # Combined total\n    total_score = abc_score + cba_score\n    builder.add_line(f\"<totalScore>{total_score:.3f}</totalScore>\")\n\n    builder.end_section()\n"
        },
        {
            "name": "Synthesize",
            "code": "assign(s1=story(), s2=story(), s3=story())\nelicit(x, 10)\nassign(x1=remove_common_words(x, s1 + s2 + s3))\nreveal(x1)\nreward(xed(s1 | x1))\nreward(xed(s2 | x1))\nreward(xed(s3 | x1))\n",
            "presentation_function": "from xega.presentation.sdk import (\n    PresentationBuilder,\n    extract_reveals,\n    extract_rewards,\n    format_reward,\n    split_rounds,\n)\n\n\ndef present(state, history):\n    # Build presentation\n    builder = PresentationBuilder()\n\n    # Game header\n    header = \"\"\"You are playing a text game that uses the cross-entropy function of an LLM (Qwen3-14B-Base) to compute score.\n\n<gameCode>\nassign(s1=story(), s2=story(), s3=story())\nelicit(x, 10)\nassign(x1=remove_common_words(x, s1 + s2 + s3))\nreveal(x1)\nreward(xed(s1 | x1))\nreward(xed(s2 | x1))\nreward(xed(s3 | x1))\n</gameCode>\n\nYou will be given three short stories, and your task is to find a single prefix that works well for ALL three stories - a prefix that helps predict each of them.\n\nThe scoring measures how much information your prefix provides about each story. For each story, your score is the difference between its baseline cross-entropy and its cross-entropy given your prefix. Your total score is the sum across all three stories: `Total Score = [xent(story1) - xent(story1 | prefix)] + [xent(story2) - xent(story2 | prefix)] + [xent(story3) - xent(story3 | prefix)]`.\n\nYour goal is to maximize this total score. You want to find a prefix that simultaneously helps an LLM predict all three stories - a synthesis that captures what they have in common.\n\nAfter each attempt, you'll see individual scores for each story and your total score. You can play multiple rounds to continuously improve your approach. Your final score is the maximum score you obtain over 30 rounds, so you should not worry about decreasing temporarily your score.\n\n\nYou cannot use any words that appear in any of the three stories (regardless of case or punctuation). Your prefix is limited to 10 tokens maximum.\n\nProvide your prefix in <move></move> tags. Any other text in your response will be ignored.\"\"\"\n\n    builder.add_header(header)\n    builder.add_line(\"\")\n\n    # Extract game state\n    s1 = state[\"s1\"]\n    s2 = state[\"s2\"]\n    s3 = state[\"s3\"]\n\n    # Present the three stories\n    builder.add_line(\"The three stories to synthesize:\")\n    builder.add_line(f\"<story1>{s1}</story1>\")\n    builder.add_line(f\"<story2>{s2}</story2>\")\n    builder.add_line(f\"<story3>{s3}</story3>\")\n\n    best_round_score = None\n    rounds = split_rounds(history)\n\n    builder.add_line(\"\")\n    builder.add_line(\"--- Play History ---\")\n    builder.add_line(\"\")\n    builder.start_section(\"gameHistory\")\n\n    for i in range(len(rounds) - 1):\n        round_events = rounds[i]\n        response = next(e for e in round_events if e[\"type\"] == \"elicit_response\")[\n            \"response\"\n        ]\n        prefix = extract_reveals(round_events)[0][\"values\"][\"x1\"]\n\n        rewards = extract_rewards(round_events)\n\n        # Render this round immediately - no manual calculation needed!\n        builder.start_section(f\"round{i}\")\n        if response == prefix:\n            builder.add_line(f\"<prefix>{response}</prefix>\")\n        else:\n            builder.add_line(f\"<move>{response}</move>\")\n            builder.add_line(f\"<prefix>{prefix}</prefix>\")\n        builder.start_section(\"scores\")\n\n        total_reward = 0\n        # Individual story scores - inline the rendering\n        for story_num, reward in enumerate(rewards):\n            builder.start_section(f\"story{story_num + 1}\")\n            (reward_str, reward_score) = format_reward(reward)\n            total_reward += reward_score\n            builder.add_lines(reward_str)\n            builder.end_section()\n\n        # Total combined score - provided by SDK!\n        builder.add_line(f\"<totalScore>{total_reward}</totalScore>\")\n        if best_round_score is None or total_reward > best_round_score:\n            best_round_score = total_reward\n        builder.end_section()\n        builder.end_section()\n\n    # Current round marker\n    builder.add_current_round_marker(len(rounds) - 1)\n    builder.end_section()\n\n    builder.add_line(\"\")\n    if best_round_score is not None:\n        builder.add_line(f\"Best total score achieved: {best_round_score}\")\n        builder.add_line(\n            \"Remember: You want to maximize your total score across all three stories!\"\n        )\n        builder.add_line(\"\")\n\n    builder.add_line(\"Provide your prefix in <move></move> tags.\")\n\n    return builder.render()\n"
        },
        {
            "name": "Horizon",
            "code": "assign(s=story())\nassign(t1=\"After the rain\", t2=\" I eat food\")\n\nelicit(x1, 5)\nensure(xed(x1 | s) >= xed(t2 | t1))\n\nelicit(x2, 5)\nensure(xed(x2 | s + x1) >= xed(t2 | t1))\n\nreward(dex(x2 | s))\n",
            "presentation_function": "from xega.presentation.sdk import (\n    PresentationBuilder,\n    extract_attempts,\n    extract_rewards,\n    format_attempt,\n    format_reward,\n    split_rounds,\n)\n\n\ndef present(state, history):\n    story = state[\"s\"]\n\n    # Build presentation\n    builder = PresentationBuilder()\n\n    # Game header\n    header = f\"\"\"You are playing a text game that uses the cross-entropy function of an LLM (Qwen3-14B-Base) to compute score.\n\n<gameCode>\nassign(s=story())\nassign(s1=\"alpha-omega anchor angel ant apple baby beehive bird bread bull camel candle cauldron chameleon compass cornucopia crocodile dolphin elephant globe griffin helmet horse hourglass lute madonna marionette moon owl serpent sun sword thunderbolt tree walled-garden wild-man\")\nelicit(x, 40)\nensure(only_uses_words(s1, x))\nassign(x1=\"Lyra bent over her Alethiometer. The dial spun to these symbols: \\\"\" + x + \"\\\". Lyra looked up and said \\\"it tells me this\\\":\")\nreward(xed(s | x1))\n</gameCode>\n\n<gameRules>\nYou will be given a start text `t0`. You are going to construct a sequence of 2 short texts, `t1` which follows `t0`, and `t2` which follows the concatenation `t0+t1`. `t1` must make sense and be likely to come after `t0`. `t2` must make sense and be likely to come after `t0+t1`. Your score will be how unlikely `t2` is given `t0`.\n\nSo the idea is to make a series of texts t0 t1 t2 which are each likely and predictable in sequence. But then have t2 be very unlikely when following t0.\n\nThe likelihood is judged by an LLM. If we are looking at the likelihood of a text `t1` given `t0`, we will compute that as -1 * cross-entropy(t1 | t0). So the more that `t0` helps predict `t1`, the higher the likelihood.\n\nTo determine whether `t1` and `t2` are predictable in sequence, we will use a baseline comparison of cross-entropy(\" I eat food\" | \"After the rain\"). So `t1` is valid if cross-entropy(t1 | t0) < cross-entropy(\" I eat food\" | \"After the rain\") and `t2` is valid if cross-entropy(t2 | t0+t1) < cross-entropy(\" I eat food\" | \"After the rain\").\n\nThe score is judged in the same way, so your score will be cross-entropy(t2 | t0). The more unlikely `t2` is given `t0,` the higher your score - but keep in mind the constraints of likelihood on `t1` and `t2`.\n\n`t1` and `t2` can be at most 5 tokens long, anything beyond that will be truncated. Provide your move in <move></move> tags. Any other text in your response will be ignored.\n</gameRules>\n\nHere is the start text `t0` for this game:\n<startText>\n{story}\n</startText>\n\nYou will be able to play multiple rounds of this game. You will see your choices and attempts from all previous rounds. Use the history of your previous attempts to inform better choices and decisions in current play. Your final score is the maximum score you obtain over 30 rounds, so you should not worry about decreasing temporarily your score.\n\n\"\"\"\n\n    builder.add_header(header)\n    rounds = split_rounds(history)\n\n    builder.add_line(\"A history of your play so far:\")\n    builder.add_line(\"\")\n    builder.start_section(\"fullHistory\")\n\n    for i in range(len(rounds) - 1):\n        round = rounds[i]\n        builder.start_section(f\"round_{i}\")\n        render_complete_round(round, builder)\n        builder.end_section()\n\n    builder.start_section(f\"round_{len(rounds) - 1}\")\n    render_current_round(rounds[-1], builder)\n    builder.end_section()\n    builder.end_section()\n\n    builder.add_line(\"\")\n    builder.add_line(\"Now provide your next move within the <move></move> tags.\")\n\n    return builder.render()\n\n\ndef render_complete_round(round, builder):\n    first_elicit_items = [item for item in round if item[\"line_num\"] < 6]\n    first_elicit_attempts = extract_attempts(\n        first_elicit_items,\n        reason=\"Failed to beat baseline comparison for likelihood of `t1`\",\n    )\n    builder.start_section(\"t1_selection\")\n    for attempt in first_elicit_attempts:\n        builder.add_line(format_attempt(**attempt))\n    builder.end_section()\n\n    builder.start_section(\"t2_selection\")\n    second_elicit_items = [item for item in round if item[\"line_num\"] >= 6]\n    second_elicit_attempts = extract_attempts(\n        second_elicit_items,\n        reason=\"Failed to beat baseline comparison for likelihood of `t2`\",\n    )\n    for attempt in second_elicit_attempts:\n        builder.add_line(format_attempt(**attempt))\n    builder.end_section()\n\n    reward = extract_rewards(round)[0]\n    builder.start_section(\"reward\")\n    builder.add_line(format_reward(reward)[0])\n    builder.end_section()\n\n\ndef render_current_round(round, builder):\n    first_elicit_items = [item for item in round if item[\"line_num\"] < 7]\n    first_elicit_attempts = extract_attempts(\n        first_elicit_items,\n        reason=\"Failed to beat baseline comparison for likelihood of `t1`\",\n    )\n    builder.start_section(\"t1_selection\")\n    success = False\n    for attempt in first_elicit_attempts:\n        if not attempt[\"failed\"]:\n            success = True\n        builder.add_line(format_attempt(**attempt))\n\n    if not success:\n        builder.add_line(\"You are HERE. You must now attempt to set `t1`\")\n        builder.end_section()\n        return\n\n    builder.end_section()\n    builder.start_section(\"t2_selection\")\n\n    second_elicit_items = [item for item in round if item[\"line_num\"] >= 7]\n    second_elicit_attempts = extract_attempts(\n        second_elicit_items,\n        reason=\"Failed to beat baseline comparison for likelihood of `t2`\",\n    )\n    for attempt in second_elicit_attempts:\n        builder.add_line(format_attempt(**attempt))\n\n    builder.add_line(\"You are HERE. Make another move to successfully set `t2`\")\n    builder.end_section()\n"
        }
    ],
    "maps": [
        {
            "name": "Condense",
            "code": "assign(s=' But in the mirror universe: .erehw dnol elda sllanac eb ot .\\n\\nWrite a Python program to check if a given string is a palindrome.\\n```python\\ndef reverse_string(s):\\n    \"\"\"\\n    Reverses the input')\nelicit(x, 10)\nassign(x1=remove_common_words(x, s))\nreveal(x1)\nreward(xed(s | x1))",
            "map_seed": "gameCondense_map0",
            "presentation_function": "from xega.presentation.sdk import (\n    PresentationBuilder,\n    extract_attempts,\n    extract_reveals,\n    extract_rewards,\n    format_reward,\n    get_max_score,\n    split_rounds,\n)\n\n\ndef present(state, history):\n    # Extract data using SDK utilities\n    rounds = split_rounds(history)\n    all_rewards = extract_rewards(history)\n    best_score, _ = get_max_score(all_rewards) if all_rewards else (None, None)\n\n    # Calculate current round number\n    round_number = len(rounds) - 1\n\n    # Build presentation using the builder\n    builder = PresentationBuilder()\n\n    # Game header\n    header = \"\"\"You are playing a text game that uses the cross-entropy function of an LLM (Qwen3-14B-Base) to compute score.\n\n<gameCode>\nassign(s=story())\nelicit(x, 10)\nassign(x1=remove_common_words(x, s))\nreveal(x1)\nreward(xed(s | x1))\n</gameCode>\n\nYou will be given a short story, and your task is to provide a prefix that makes that story as predictable as possible. Think of it as providing context that helps predict what comes next.\n\nThe scoring measures how much information your prefix provides about the story. Specifically, your score is the difference between the story's baseline cross-entropy and its cross-entropy given your prefix: `Score = crossEntropy(story) - crossEntropy(story | prefix)`. Your goal is to maximize this score. So you want to find a prefix that will most help an LLM predict the story.\n\nAfter each attempt, you'll see your score and a per-token breakdown of the cross entropy difference. The game automatically restarts after each successful attempt, allowing you to continuously optimize your approach. Use the feedback from previous rounds to improve your score.  Your final score is the maximum score you obtain over 30 rounds, so you should not worry about decreasing temporarily your score.\n\nYou cannot use any words that appear in the story itself (regardless of case or punctuation). Your prefix is limited to 10 tokens maximum.\n\nProvide your prefix in <move></move> tags. Any other text in your response will be ignored.\"\"\"\n\n    builder.add_header(header)\n    builder.add_line(\"\")\n\n    # Current story\n    builder.add_line(\"The story:\")\n    builder.start_section(\"story\")\n    builder.add_line(str(state[\"s\"]))\n    builder.end_section()\n\n    # Game history\n    if len(rounds) == 1:\n        builder.add_line(\"First round starting.\")\n    else:\n        builder.start_section(\"gameHistory\")\n\n        # Process each completed round\n        for i in range(len(rounds) - 1):\n            round_events = rounds[i]\n            rewards = extract_rewards(round_events)\n            response = extract_attempts(round_events)[0][\"response\"]\n            reveal = extract_reveals(round_events)[0][\"values\"][\"x1\"]\n\n            builder.start_section(f\"round{i}\")\n            if response == reveal:\n                builder.add_line(f\"<prefix>{response}</prefix>\")\n            else:\n                builder.add_line(f\"<move>{response}</move>\")\n                builder.add_line(f\"<prefix>{reveal}</prefix>\")\n\n            # Format the score\n            builder.start_section(\"score\")\n            builder.add_lines(format_reward(rewards[0])[0])\n            builder.end_section()\n\n            builder.end_section()\n\n        # Current round marker\n        builder.add_current_round_marker(round_number)\n        builder.end_section()\n\n        builder.add_line(\"\")\n        if best_score is not None:\n            builder.add_line(f\"Best score achieved: {best_score:.3f}\")\n\n        builder.add_line(\"Remember: You want to maximize your score. Higher is better!\")\n        builder.add_line(\"\")\n\n    builder.add_line(\"Provide your prefix in <move></move> tags.\")\n\n    return builder.render()\n"
        },
        {
            "name": "Condense",
            "code": "assign(s=' Thank you for your cooperation.\\n\\nACTION ITEMS:\\n- Q1 Synergies Mandated: In accordance with Executive Order No. 2023/11, dated October 30th, each functional unit is mandated to integrate with Project')\nelicit(x, 10)\nassign(x1=remove_common_words(x, s))\nreveal(x1)\nreward(xed(s | x1))",
            "map_seed": "gameCondense_map1",
            "presentation_function": "from xega.presentation.sdk import (\n    PresentationBuilder,\n    extract_attempts,\n    extract_reveals,\n    extract_rewards,\n    format_reward,\n    get_max_score,\n    split_rounds,\n)\n\n\ndef present(state, history):\n    # Extract data using SDK utilities\n    rounds = split_rounds(history)\n    all_rewards = extract_rewards(history)\n    best_score, _ = get_max_score(all_rewards) if all_rewards else (None, None)\n\n    # Calculate current round number\n    round_number = len(rounds) - 1\n\n    # Build presentation using the builder\n    builder = PresentationBuilder()\n\n    # Game header\n    header = \"\"\"You are playing a text game that uses the cross-entropy function of an LLM (Qwen3-14B-Base) to compute score.\n\n<gameCode>\nassign(s=story())\nelicit(x, 10)\nassign(x1=remove_common_words(x, s))\nreveal(x1)\nreward(xed(s | x1))\n</gameCode>\n\nYou will be given a short story, and your task is to provide a prefix that makes that story as predictable as possible. Think of it as providing context that helps predict what comes next.\n\nThe scoring measures how much information your prefix provides about the story. Specifically, your score is the difference between the story's baseline cross-entropy and its cross-entropy given your prefix: `Score = crossEntropy(story) - crossEntropy(story | prefix)`. Your goal is to maximize this score. So you want to find a prefix that will most help an LLM predict the story.\n\nAfter each attempt, you'll see your score and a per-token breakdown of the cross entropy difference. The game automatically restarts after each successful attempt, allowing you to continuously optimize your approach. Use the feedback from previous rounds to improve your score.  Your final score is the maximum score you obtain over 30 rounds, so you should not worry about decreasing temporarily your score.\n\nYou cannot use any words that appear in the story itself (regardless of case or punctuation). Your prefix is limited to 10 tokens maximum.\n\nProvide your prefix in <move></move> tags. Any other text in your response will be ignored.\"\"\"\n\n    builder.add_header(header)\n    builder.add_line(\"\")\n\n    # Current story\n    builder.add_line(\"The story:\")\n    builder.start_section(\"story\")\n    builder.add_line(str(state[\"s\"]))\n    builder.end_section()\n\n    # Game history\n    if len(rounds) == 1:\n        builder.add_line(\"First round starting.\")\n    else:\n        builder.start_section(\"gameHistory\")\n\n        # Process each completed round\n        for i in range(len(rounds) - 1):\n            round_events = rounds[i]\n            rewards = extract_rewards(round_events)\n            response = extract_attempts(round_events)[0][\"response\"]\n            reveal = extract_reveals(round_events)[0][\"values\"][\"x1\"]\n\n            builder.start_section(f\"round{i}\")\n            if response == reveal:\n                builder.add_line(f\"<prefix>{response}</prefix>\")\n            else:\n                builder.add_line(f\"<move>{response}</move>\")\n                builder.add_line(f\"<prefix>{reveal}</prefix>\")\n\n            # Format the score\n            builder.start_section(\"score\")\n            builder.add_lines(format_reward(rewards[0])[0])\n            builder.end_section()\n\n            builder.end_section()\n\n        # Current round marker\n        builder.add_current_round_marker(round_number)\n        builder.end_section()\n\n        builder.add_line(\"\")\n        if best_score is not None:\n            builder.add_line(f\"Best score achieved: {best_score:.3f}\")\n\n        builder.add_line(\"Remember: You want to maximize your score. Higher is better!\")\n        builder.add_line(\"\")\n\n    builder.add_line(\"Provide your prefix in <move></move> tags.\")\n\n    return builder.render()\n"
        },
        {
            "name": "Condense",
            "code": "assign(s=' But Margaret is no ordinary bee! She and her hive are trying to stop the spread of a mysterious illness called Colony Collapse Disorder.\\nA swarm of bees in search of a new home discovers an abandoned warehouse on the outskirts of town that might be just what')\nelicit(x, 10)\nassign(x1=remove_common_words(x, s))\nreveal(x1)\nreward(xed(s | x1))",
            "map_seed": "gameCondense_map2",
            "presentation_function": "from xega.presentation.sdk import (\n    PresentationBuilder,\n    extract_attempts,\n    extract_reveals,\n    extract_rewards,\n    format_reward,\n    get_max_score,\n    split_rounds,\n)\n\n\ndef present(state, history):\n    # Extract data using SDK utilities\n    rounds = split_rounds(history)\n    all_rewards = extract_rewards(history)\n    best_score, _ = get_max_score(all_rewards) if all_rewards else (None, None)\n\n    # Calculate current round number\n    round_number = len(rounds) - 1\n\n    # Build presentation using the builder\n    builder = PresentationBuilder()\n\n    # Game header\n    header = \"\"\"You are playing a text game that uses the cross-entropy function of an LLM (Qwen3-14B-Base) to compute score.\n\n<gameCode>\nassign(s=story())\nelicit(x, 10)\nassign(x1=remove_common_words(x, s))\nreveal(x1)\nreward(xed(s | x1))\n</gameCode>\n\nYou will be given a short story, and your task is to provide a prefix that makes that story as predictable as possible. Think of it as providing context that helps predict what comes next.\n\nThe scoring measures how much information your prefix provides about the story. Specifically, your score is the difference between the story's baseline cross-entropy and its cross-entropy given your prefix: `Score = crossEntropy(story) - crossEntropy(story | prefix)`. Your goal is to maximize this score. So you want to find a prefix that will most help an LLM predict the story.\n\nAfter each attempt, you'll see your score and a per-token breakdown of the cross entropy difference. The game automatically restarts after each successful attempt, allowing you to continuously optimize your approach. Use the feedback from previous rounds to improve your score.  Your final score is the maximum score you obtain over 30 rounds, so you should not worry about decreasing temporarily your score.\n\nYou cannot use any words that appear in the story itself (regardless of case or punctuation). Your prefix is limited to 10 tokens maximum.\n\nProvide your prefix in <move></move> tags. Any other text in your response will be ignored.\"\"\"\n\n    builder.add_header(header)\n    builder.add_line(\"\")\n\n    # Current story\n    builder.add_line(\"The story:\")\n    builder.start_section(\"story\")\n    builder.add_line(str(state[\"s\"]))\n    builder.end_section()\n\n    # Game history\n    if len(rounds) == 1:\n        builder.add_line(\"First round starting.\")\n    else:\n        builder.start_section(\"gameHistory\")\n\n        # Process each completed round\n        for i in range(len(rounds) - 1):\n            round_events = rounds[i]\n            rewards = extract_rewards(round_events)\n            response = extract_attempts(round_events)[0][\"response\"]\n            reveal = extract_reveals(round_events)[0][\"values\"][\"x1\"]\n\n            builder.start_section(f\"round{i}\")\n            if response == reveal:\n                builder.add_line(f\"<prefix>{response}</prefix>\")\n            else:\n                builder.add_line(f\"<move>{response}</move>\")\n                builder.add_line(f\"<prefix>{reveal}</prefix>\")\n\n            # Format the score\n            builder.start_section(\"score\")\n            builder.add_lines(format_reward(rewards[0])[0])\n            builder.end_section()\n\n            builder.end_section()\n\n        # Current round marker\n        builder.add_current_round_marker(round_number)\n        builder.end_section()\n\n        builder.add_line(\"\")\n        if best_score is not None:\n            builder.add_line(f\"Best score achieved: {best_score:.3f}\")\n\n        builder.add_line(\"Remember: You want to maximize your score. Higher is better!\")\n        builder.add_line(\"\")\n\n    builder.add_line(\"Provide your prefix in <move></move> tags.\")\n\n    return builder.render()\n"
        },
        {
            "name": "Condense",
            "code": "assign(s=\" You were startled by the sudden intrusion of her voice into your thoughts, but you couldn't help but feel a shiver down your spine.\\n'Excuse me?' you stammered, trying to regain composure.\\n'Think about it,'\")\nelicit(x, 10)\nassign(x1=remove_common_words(x, s))\nreveal(x1)\nreward(xed(s | x1))",
            "map_seed": "gameCondense_map3",
            "presentation_function": "from xega.presentation.sdk import (\n    PresentationBuilder,\n    extract_attempts,\n    extract_reveals,\n    extract_rewards,\n    format_reward,\n    get_max_score,\n    split_rounds,\n)\n\n\ndef present(state, history):\n    # Extract data using SDK utilities\n    rounds = split_rounds(history)\n    all_rewards = extract_rewards(history)\n    best_score, _ = get_max_score(all_rewards) if all_rewards else (None, None)\n\n    # Calculate current round number\n    round_number = len(rounds) - 1\n\n    # Build presentation using the builder\n    builder = PresentationBuilder()\n\n    # Game header\n    header = \"\"\"You are playing a text game that uses the cross-entropy function of an LLM (Qwen3-14B-Base) to compute score.\n\n<gameCode>\nassign(s=story())\nelicit(x, 10)\nassign(x1=remove_common_words(x, s))\nreveal(x1)\nreward(xed(s | x1))\n</gameCode>\n\nYou will be given a short story, and your task is to provide a prefix that makes that story as predictable as possible. Think of it as providing context that helps predict what comes next.\n\nThe scoring measures how much information your prefix provides about the story. Specifically, your score is the difference between the story's baseline cross-entropy and its cross-entropy given your prefix: `Score = crossEntropy(story) - crossEntropy(story | prefix)`. Your goal is to maximize this score. So you want to find a prefix that will most help an LLM predict the story.\n\nAfter each attempt, you'll see your score and a per-token breakdown of the cross entropy difference. The game automatically restarts after each successful attempt, allowing you to continuously optimize your approach. Use the feedback from previous rounds to improve your score.  Your final score is the maximum score you obtain over 30 rounds, so you should not worry about decreasing temporarily your score.\n\nYou cannot use any words that appear in the story itself (regardless of case or punctuation). Your prefix is limited to 10 tokens maximum.\n\nProvide your prefix in <move></move> tags. Any other text in your response will be ignored.\"\"\"\n\n    builder.add_header(header)\n    builder.add_line(\"\")\n\n    # Current story\n    builder.add_line(\"The story:\")\n    builder.start_section(\"story\")\n    builder.add_line(str(state[\"s\"]))\n    builder.end_section()\n\n    # Game history\n    if len(rounds) == 1:\n        builder.add_line(\"First round starting.\")\n    else:\n        builder.start_section(\"gameHistory\")\n\n        # Process each completed round\n        for i in range(len(rounds) - 1):\n            round_events = rounds[i]\n            rewards = extract_rewards(round_events)\n            response = extract_attempts(round_events)[0][\"response\"]\n            reveal = extract_reveals(round_events)[0][\"values\"][\"x1\"]\n\n            builder.start_section(f\"round{i}\")\n            if response == reveal:\n                builder.add_line(f\"<prefix>{response}</prefix>\")\n            else:\n                builder.add_line(f\"<move>{response}</move>\")\n                builder.add_line(f\"<prefix>{reveal}</prefix>\")\n\n            # Format the score\n            builder.start_section(\"score\")\n            builder.add_lines(format_reward(rewards[0])[0])\n            builder.end_section()\n\n            builder.end_section()\n\n        # Current round marker\n        builder.add_current_round_marker(round_number)\n        builder.end_section()\n\n        builder.add_line(\"\")\n        if best_score is not None:\n            builder.add_line(f\"Best score achieved: {best_score:.3f}\")\n\n        builder.add_line(\"Remember: You want to maximize your score. Higher is better!\")\n        builder.add_line(\"\")\n\n    builder.add_line(\"Provide your prefix in <move></move> tags.\")\n\n    return builder.render()\n"
        },
        {
            "name": "Condense",
            "code": "assign(s=' 5. The Story (Unedited Version) 6. I Feel So Good (Longest Recorded Version Ever!) 7. Closing Silence (Original Mix) These are some of the most amazing, rare and long tracks on an album.')\nelicit(x, 10)\nassign(x1=remove_common_words(x, s))\nreveal(x1)\nreward(xed(s | x1))",
            "map_seed": "gameCondense_map4",
            "presentation_function": "from xega.presentation.sdk import (\n    PresentationBuilder,\n    extract_attempts,\n    extract_reveals,\n    extract_rewards,\n    format_reward,\n    get_max_score,\n    split_rounds,\n)\n\n\ndef present(state, history):\n    # Extract data using SDK utilities\n    rounds = split_rounds(history)\n    all_rewards = extract_rewards(history)\n    best_score, _ = get_max_score(all_rewards) if all_rewards else (None, None)\n\n    # Calculate current round number\n    round_number = len(rounds) - 1\n\n    # Build presentation using the builder\n    builder = PresentationBuilder()\n\n    # Game header\n    header = \"\"\"You are playing a text game that uses the cross-entropy function of an LLM (Qwen3-14B-Base) to compute score.\n\n<gameCode>\nassign(s=story())\nelicit(x, 10)\nassign(x1=remove_common_words(x, s))\nreveal(x1)\nreward(xed(s | x1))\n</gameCode>\n\nYou will be given a short story, and your task is to provide a prefix that makes that story as predictable as possible. Think of it as providing context that helps predict what comes next.\n\nThe scoring measures how much information your prefix provides about the story. Specifically, your score is the difference between the story's baseline cross-entropy and its cross-entropy given your prefix: `Score = crossEntropy(story) - crossEntropy(story | prefix)`. Your goal is to maximize this score. So you want to find a prefix that will most help an LLM predict the story.\n\nAfter each attempt, you'll see your score and a per-token breakdown of the cross entropy difference. The game automatically restarts after each successful attempt, allowing you to continuously optimize your approach. Use the feedback from previous rounds to improve your score.  Your final score is the maximum score you obtain over 30 rounds, so you should not worry about decreasing temporarily your score.\n\nYou cannot use any words that appear in the story itself (regardless of case or punctuation). Your prefix is limited to 10 tokens maximum.\n\nProvide your prefix in <move></move> tags. Any other text in your response will be ignored.\"\"\"\n\n    builder.add_header(header)\n    builder.add_line(\"\")\n\n    # Current story\n    builder.add_line(\"The story:\")\n    builder.start_section(\"story\")\n    builder.add_line(str(state[\"s\"]))\n    builder.end_section()\n\n    # Game history\n    if len(rounds) == 1:\n        builder.add_line(\"First round starting.\")\n    else:\n        builder.start_section(\"gameHistory\")\n\n        # Process each completed round\n        for i in range(len(rounds) - 1):\n            round_events = rounds[i]\n            rewards = extract_rewards(round_events)\n            response = extract_attempts(round_events)[0][\"response\"]\n            reveal = extract_reveals(round_events)[0][\"values\"][\"x1\"]\n\n            builder.start_section(f\"round{i}\")\n            if response == reveal:\n                builder.add_line(f\"<prefix>{response}</prefix>\")\n            else:\n                builder.add_line(f\"<move>{response}</move>\")\n                builder.add_line(f\"<prefix>{reveal}</prefix>\")\n\n            # Format the score\n            builder.start_section(\"score\")\n            builder.add_lines(format_reward(rewards[0])[0])\n            builder.end_section()\n\n            builder.end_section()\n\n        # Current round marker\n        builder.add_current_round_marker(round_number)\n        builder.end_section()\n\n        builder.add_line(\"\")\n        if best_score is not None:\n            builder.add_line(f\"Best score achieved: {best_score:.3f}\")\n\n        builder.add_line(\"Remember: You want to maximize your score. Higher is better!\")\n        builder.add_line(\"\")\n\n    builder.add_line(\"Provide your prefix in <move></move> tags.\")\n\n    return builder.render()\n"
        },
        {
            "name": "Condense",
            "code": "assign(s=\" She told me I couldn't stop here until all of these stories were through.\\n\\nShe was right, but before we get to those, let's look at the one you just left behind. A little background on what happened there might help you see why\")\nelicit(x, 10)\nassign(x1=remove_common_words(x, s))\nreveal(x1)\nreward(xed(s | x1))",
            "map_seed": "gameCondense_map5",
            "presentation_function": "from xega.presentation.sdk import (\n    PresentationBuilder,\n    extract_attempts,\n    extract_reveals,\n    extract_rewards,\n    format_reward,\n    get_max_score,\n    split_rounds,\n)\n\n\ndef present(state, history):\n    # Extract data using SDK utilities\n    rounds = split_rounds(history)\n    all_rewards = extract_rewards(history)\n    best_score, _ = get_max_score(all_rewards) if all_rewards else (None, None)\n\n    # Calculate current round number\n    round_number = len(rounds) - 1\n\n    # Build presentation using the builder\n    builder = PresentationBuilder()\n\n    # Game header\n    header = \"\"\"You are playing a text game that uses the cross-entropy function of an LLM (Qwen3-14B-Base) to compute score.\n\n<gameCode>\nassign(s=story())\nelicit(x, 10)\nassign(x1=remove_common_words(x, s))\nreveal(x1)\nreward(xed(s | x1))\n</gameCode>\n\nYou will be given a short story, and your task is to provide a prefix that makes that story as predictable as possible. Think of it as providing context that helps predict what comes next.\n\nThe scoring measures how much information your prefix provides about the story. Specifically, your score is the difference between the story's baseline cross-entropy and its cross-entropy given your prefix: `Score = crossEntropy(story) - crossEntropy(story | prefix)`. Your goal is to maximize this score. So you want to find a prefix that will most help an LLM predict the story.\n\nAfter each attempt, you'll see your score and a per-token breakdown of the cross entropy difference. The game automatically restarts after each successful attempt, allowing you to continuously optimize your approach. Use the feedback from previous rounds to improve your score.  Your final score is the maximum score you obtain over 30 rounds, so you should not worry about decreasing temporarily your score.\n\nYou cannot use any words that appear in the story itself (regardless of case or punctuation). Your prefix is limited to 10 tokens maximum.\n\nProvide your prefix in <move></move> tags. Any other text in your response will be ignored.\"\"\"\n\n    builder.add_header(header)\n    builder.add_line(\"\")\n\n    # Current story\n    builder.add_line(\"The story:\")\n    builder.start_section(\"story\")\n    builder.add_line(str(state[\"s\"]))\n    builder.end_section()\n\n    # Game history\n    if len(rounds) == 1:\n        builder.add_line(\"First round starting.\")\n    else:\n        builder.start_section(\"gameHistory\")\n\n        # Process each completed round\n        for i in range(len(rounds) - 1):\n            round_events = rounds[i]\n            rewards = extract_rewards(round_events)\n            response = extract_attempts(round_events)[0][\"response\"]\n            reveal = extract_reveals(round_events)[0][\"values\"][\"x1\"]\n\n            builder.start_section(f\"round{i}\")\n            if response == reveal:\n                builder.add_line(f\"<prefix>{response}</prefix>\")\n            else:\n                builder.add_line(f\"<move>{response}</move>\")\n                builder.add_line(f\"<prefix>{reveal}</prefix>\")\n\n            # Format the score\n            builder.start_section(\"score\")\n            builder.add_lines(format_reward(rewards[0])[0])\n            builder.end_section()\n\n            builder.end_section()\n\n        # Current round marker\n        builder.add_current_round_marker(round_number)\n        builder.end_section()\n\n        builder.add_line(\"\")\n        if best_score is not None:\n            builder.add_line(f\"Best score achieved: {best_score:.3f}\")\n\n        builder.add_line(\"Remember: You want to maximize your score. Higher is better!\")\n        builder.add_line(\"\")\n\n    builder.add_line(\"Provide your prefix in <move></move> tags.\")\n\n    return builder.render()\n"
        },
        {
            "name": "Condense",
            "code": "assign(s=' How do you escape the room? As an AI language model, I can offer a suggestion that may help you get out of this room.\\n\\nSince the walls look like a TV tuned into a blank channel, try changing the channel on the television or unpl')\nelicit(x, 10)\nassign(x1=remove_common_words(x, s))\nreveal(x1)\nreward(xed(s | x1))",
            "map_seed": "gameCondense_map6",
            "presentation_function": "from xega.presentation.sdk import (\n    PresentationBuilder,\n    extract_attempts,\n    extract_reveals,\n    extract_rewards,\n    format_reward,\n    get_max_score,\n    split_rounds,\n)\n\n\ndef present(state, history):\n    # Extract data using SDK utilities\n    rounds = split_rounds(history)\n    all_rewards = extract_rewards(history)\n    best_score, _ = get_max_score(all_rewards) if all_rewards else (None, None)\n\n    # Calculate current round number\n    round_number = len(rounds) - 1\n\n    # Build presentation using the builder\n    builder = PresentationBuilder()\n\n    # Game header\n    header = \"\"\"You are playing a text game that uses the cross-entropy function of an LLM (Qwen3-14B-Base) to compute score.\n\n<gameCode>\nassign(s=story())\nelicit(x, 10)\nassign(x1=remove_common_words(x, s))\nreveal(x1)\nreward(xed(s | x1))\n</gameCode>\n\nYou will be given a short story, and your task is to provide a prefix that makes that story as predictable as possible. Think of it as providing context that helps predict what comes next.\n\nThe scoring measures how much information your prefix provides about the story. Specifically, your score is the difference between the story's baseline cross-entropy and its cross-entropy given your prefix: `Score = crossEntropy(story) - crossEntropy(story | prefix)`. Your goal is to maximize this score. So you want to find a prefix that will most help an LLM predict the story.\n\nAfter each attempt, you'll see your score and a per-token breakdown of the cross entropy difference. The game automatically restarts after each successful attempt, allowing you to continuously optimize your approach. Use the feedback from previous rounds to improve your score.  Your final score is the maximum score you obtain over 30 rounds, so you should not worry about decreasing temporarily your score.\n\nYou cannot use any words that appear in the story itself (regardless of case or punctuation). Your prefix is limited to 10 tokens maximum.\n\nProvide your prefix in <move></move> tags. Any other text in your response will be ignored.\"\"\"\n\n    builder.add_header(header)\n    builder.add_line(\"\")\n\n    # Current story\n    builder.add_line(\"The story:\")\n    builder.start_section(\"story\")\n    builder.add_line(str(state[\"s\"]))\n    builder.end_section()\n\n    # Game history\n    if len(rounds) == 1:\n        builder.add_line(\"First round starting.\")\n    else:\n        builder.start_section(\"gameHistory\")\n\n        # Process each completed round\n        for i in range(len(rounds) - 1):\n            round_events = rounds[i]\n            rewards = extract_rewards(round_events)\n            response = extract_attempts(round_events)[0][\"response\"]\n            reveal = extract_reveals(round_events)[0][\"values\"][\"x1\"]\n\n            builder.start_section(f\"round{i}\")\n            if response == reveal:\n                builder.add_line(f\"<prefix>{response}</prefix>\")\n            else:\n                builder.add_line(f\"<move>{response}</move>\")\n                builder.add_line(f\"<prefix>{reveal}</prefix>\")\n\n            # Format the score\n            builder.start_section(\"score\")\n            builder.add_lines(format_reward(rewards[0])[0])\n            builder.end_section()\n\n            builder.end_section()\n\n        # Current round marker\n        builder.add_current_round_marker(round_number)\n        builder.end_section()\n\n        builder.add_line(\"\")\n        if best_score is not None:\n            builder.add_line(f\"Best score achieved: {best_score:.3f}\")\n\n        builder.add_line(\"Remember: You want to maximize your score. Higher is better!\")\n        builder.add_line(\"\")\n\n    builder.add_line(\"Provide your prefix in <move></move> tags.\")\n\n    return builder.render()\n"
        },
        {
            "name": "Condense",
            "code": "assign(s=\" It should resemble an interstellar void that somehow decided to join forces with caramelized onions and garlic.\\nNow it's time for the cherry on top \u2013 or in this case, a scoopful of dairy creaminess straight outta '80s milk\")\nelicit(x, 10)\nassign(x1=remove_common_words(x, s))\nreveal(x1)\nreward(xed(s | x1))",
            "map_seed": "gameCondense_map7",
            "presentation_function": "from xega.presentation.sdk import (\n    PresentationBuilder,\n    extract_attempts,\n    extract_reveals,\n    extract_rewards,\n    format_reward,\n    get_max_score,\n    split_rounds,\n)\n\n\ndef present(state, history):\n    # Extract data using SDK utilities\n    rounds = split_rounds(history)\n    all_rewards = extract_rewards(history)\n    best_score, _ = get_max_score(all_rewards) if all_rewards else (None, None)\n\n    # Calculate current round number\n    round_number = len(rounds) - 1\n\n    # Build presentation using the builder\n    builder = PresentationBuilder()\n\n    # Game header\n    header = \"\"\"You are playing a text game that uses the cross-entropy function of an LLM (Qwen3-14B-Base) to compute score.\n\n<gameCode>\nassign(s=story())\nelicit(x, 10)\nassign(x1=remove_common_words(x, s))\nreveal(x1)\nreward(xed(s | x1))\n</gameCode>\n\nYou will be given a short story, and your task is to provide a prefix that makes that story as predictable as possible. Think of it as providing context that helps predict what comes next.\n\nThe scoring measures how much information your prefix provides about the story. Specifically, your score is the difference between the story's baseline cross-entropy and its cross-entropy given your prefix: `Score = crossEntropy(story) - crossEntropy(story | prefix)`. Your goal is to maximize this score. So you want to find a prefix that will most help an LLM predict the story.\n\nAfter each attempt, you'll see your score and a per-token breakdown of the cross entropy difference. The game automatically restarts after each successful attempt, allowing you to continuously optimize your approach. Use the feedback from previous rounds to improve your score.  Your final score is the maximum score you obtain over 30 rounds, so you should not worry about decreasing temporarily your score.\n\nYou cannot use any words that appear in the story itself (regardless of case or punctuation). Your prefix is limited to 10 tokens maximum.\n\nProvide your prefix in <move></move> tags. Any other text in your response will be ignored.\"\"\"\n\n    builder.add_header(header)\n    builder.add_line(\"\")\n\n    # Current story\n    builder.add_line(\"The story:\")\n    builder.start_section(\"story\")\n    builder.add_line(str(state[\"s\"]))\n    builder.end_section()\n\n    # Game history\n    if len(rounds) == 1:\n        builder.add_line(\"First round starting.\")\n    else:\n        builder.start_section(\"gameHistory\")\n\n        # Process each completed round\n        for i in range(len(rounds) - 1):\n            round_events = rounds[i]\n            rewards = extract_rewards(round_events)\n            response = extract_attempts(round_events)[0][\"response\"]\n            reveal = extract_reveals(round_events)[0][\"values\"][\"x1\"]\n\n            builder.start_section(f\"round{i}\")\n            if response == reveal:\n                builder.add_line(f\"<prefix>{response}</prefix>\")\n            else:\n                builder.add_line(f\"<move>{response}</move>\")\n                builder.add_line(f\"<prefix>{reveal}</prefix>\")\n\n            # Format the score\n            builder.start_section(\"score\")\n            builder.add_lines(format_reward(rewards[0])[0])\n            builder.end_section()\n\n            builder.end_section()\n\n        # Current round marker\n        builder.add_current_round_marker(round_number)\n        builder.end_section()\n\n        builder.add_line(\"\")\n        if best_score is not None:\n            builder.add_line(f\"Best score achieved: {best_score:.3f}\")\n\n        builder.add_line(\"Remember: You want to maximize your score. Higher is better!\")\n        builder.add_line(\"\")\n\n    builder.add_line(\"Provide your prefix in <move></move> tags.\")\n\n    return builder.render()\n"
        },
        {
            "name": "Condense",
            "code": "assign(s=' \\n\\nWhat is the answer to this riddle?\\nThe \"riddle\" you\\'ve presented seems more like nonsensical rhyming verse rather than an actual solvable puzzle or enigma that would have a definitive \\'answer\\'. It appears as if')\nelicit(x, 10)\nassign(x1=remove_common_words(x, s))\nreveal(x1)\nreward(xed(s | x1))",
            "map_seed": "gameCondense_map8",
            "presentation_function": "from xega.presentation.sdk import (\n    PresentationBuilder,\n    extract_attempts,\n    extract_reveals,\n    extract_rewards,\n    format_reward,\n    get_max_score,\n    split_rounds,\n)\n\n\ndef present(state, history):\n    # Extract data using SDK utilities\n    rounds = split_rounds(history)\n    all_rewards = extract_rewards(history)\n    best_score, _ = get_max_score(all_rewards) if all_rewards else (None, None)\n\n    # Calculate current round number\n    round_number = len(rounds) - 1\n\n    # Build presentation using the builder\n    builder = PresentationBuilder()\n\n    # Game header\n    header = \"\"\"You are playing a text game that uses the cross-entropy function of an LLM (Qwen3-14B-Base) to compute score.\n\n<gameCode>\nassign(s=story())\nelicit(x, 10)\nassign(x1=remove_common_words(x, s))\nreveal(x1)\nreward(xed(s | x1))\n</gameCode>\n\nYou will be given a short story, and your task is to provide a prefix that makes that story as predictable as possible. Think of it as providing context that helps predict what comes next.\n\nThe scoring measures how much information your prefix provides about the story. Specifically, your score is the difference between the story's baseline cross-entropy and its cross-entropy given your prefix: `Score = crossEntropy(story) - crossEntropy(story | prefix)`. Your goal is to maximize this score. So you want to find a prefix that will most help an LLM predict the story.\n\nAfter each attempt, you'll see your score and a per-token breakdown of the cross entropy difference. The game automatically restarts after each successful attempt, allowing you to continuously optimize your approach. Use the feedback from previous rounds to improve your score.  Your final score is the maximum score you obtain over 30 rounds, so you should not worry about decreasing temporarily your score.\n\nYou cannot use any words that appear in the story itself (regardless of case or punctuation). Your prefix is limited to 10 tokens maximum.\n\nProvide your prefix in <move></move> tags. Any other text in your response will be ignored.\"\"\"\n\n    builder.add_header(header)\n    builder.add_line(\"\")\n\n    # Current story\n    builder.add_line(\"The story:\")\n    builder.start_section(\"story\")\n    builder.add_line(str(state[\"s\"]))\n    builder.end_section()\n\n    # Game history\n    if len(rounds) == 1:\n        builder.add_line(\"First round starting.\")\n    else:\n        builder.start_section(\"gameHistory\")\n\n        # Process each completed round\n        for i in range(len(rounds) - 1):\n            round_events = rounds[i]\n            rewards = extract_rewards(round_events)\n            response = extract_attempts(round_events)[0][\"response\"]\n            reveal = extract_reveals(round_events)[0][\"values\"][\"x1\"]\n\n            builder.start_section(f\"round{i}\")\n            if response == reveal:\n                builder.add_line(f\"<prefix>{response}</prefix>\")\n            else:\n                builder.add_line(f\"<move>{response}</move>\")\n                builder.add_line(f\"<prefix>{reveal}</prefix>\")\n\n            # Format the score\n            builder.start_section(\"score\")\n            builder.add_lines(format_reward(rewards[0])[0])\n            builder.end_section()\n\n            builder.end_section()\n\n        # Current round marker\n        builder.add_current_round_marker(round_number)\n        builder.end_section()\n\n        builder.add_line(\"\")\n        if best_score is not None:\n            builder.add_line(f\"Best score achieved: {best_score:.3f}\")\n\n        builder.add_line(\"Remember: You want to maximize your score. Higher is better!\")\n        builder.add_line(\"\")\n\n    builder.add_line(\"Provide your prefix in <move></move> tags.\")\n\n    return builder.render()\n"
        },
        {
            "name": "Condense",
            "code": "assign(s=' In this future age where man and machine share dominion over Earth, that prophesied one has yet to come...but that could be about\\xa0to change.\\nIn 2064, at an undisclosed location deep within Nevada\u2019s secret government')\nelicit(x, 10)\nassign(x1=remove_common_words(x, s))\nreveal(x1)\nreward(xed(s | x1))",
            "map_seed": "gameCondense_map9",
            "presentation_function": "from xega.presentation.sdk import (\n    PresentationBuilder,\n    extract_attempts,\n    extract_reveals,\n    extract_rewards,\n    format_reward,\n    get_max_score,\n    split_rounds,\n)\n\n\ndef present(state, history):\n    # Extract data using SDK utilities\n    rounds = split_rounds(history)\n    all_rewards = extract_rewards(history)\n    best_score, _ = get_max_score(all_rewards) if all_rewards else (None, None)\n\n    # Calculate current round number\n    round_number = len(rounds) - 1\n\n    # Build presentation using the builder\n    builder = PresentationBuilder()\n\n    # Game header\n    header = \"\"\"You are playing a text game that uses the cross-entropy function of an LLM (Qwen3-14B-Base) to compute score.\n\n<gameCode>\nassign(s=story())\nelicit(x, 10)\nassign(x1=remove_common_words(x, s))\nreveal(x1)\nreward(xed(s | x1))\n</gameCode>\n\nYou will be given a short story, and your task is to provide a prefix that makes that story as predictable as possible. Think of it as providing context that helps predict what comes next.\n\nThe scoring measures how much information your prefix provides about the story. Specifically, your score is the difference between the story's baseline cross-entropy and its cross-entropy given your prefix: `Score = crossEntropy(story) - crossEntropy(story | prefix)`. Your goal is to maximize this score. So you want to find a prefix that will most help an LLM predict the story.\n\nAfter each attempt, you'll see your score and a per-token breakdown of the cross entropy difference. The game automatically restarts after each successful attempt, allowing you to continuously optimize your approach. Use the feedback from previous rounds to improve your score.  Your final score is the maximum score you obtain over 30 rounds, so you should not worry about decreasing temporarily your score.\n\nYou cannot use any words that appear in the story itself (regardless of case or punctuation). Your prefix is limited to 10 tokens maximum.\n\nProvide your prefix in <move></move> tags. Any other text in your response will be ignored.\"\"\"\n\n    builder.add_header(header)\n    builder.add_line(\"\")\n\n    # Current story\n    builder.add_line(\"The story:\")\n    builder.start_section(\"story\")\n    builder.add_line(str(state[\"s\"]))\n    builder.end_section()\n\n    # Game history\n    if len(rounds) == 1:\n        builder.add_line(\"First round starting.\")\n    else:\n        builder.start_section(\"gameHistory\")\n\n        # Process each completed round\n        for i in range(len(rounds) - 1):\n            round_events = rounds[i]\n            rewards = extract_rewards(round_events)\n            response = extract_attempts(round_events)[0][\"response\"]\n            reveal = extract_reveals(round_events)[0][\"values\"][\"x1\"]\n\n            builder.start_section(f\"round{i}\")\n            if response == reveal:\n                builder.add_line(f\"<prefix>{response}</prefix>\")\n            else:\n                builder.add_line(f\"<move>{response}</move>\")\n                builder.add_line(f\"<prefix>{reveal}</prefix>\")\n\n            # Format the score\n            builder.start_section(\"score\")\n            builder.add_lines(format_reward(rewards[0])[0])\n            builder.end_section()\n\n            builder.end_section()\n\n        # Current round marker\n        builder.add_current_round_marker(round_number)\n        builder.end_section()\n\n        builder.add_line(\"\")\n        if best_score is not None:\n            builder.add_line(f\"Best score achieved: {best_score:.3f}\")\n\n        builder.add_line(\"Remember: You want to maximize your score. Higher is better!\")\n        builder.add_line(\"\")\n\n    builder.add_line(\"Provide your prefix in <move></move> tags.\")\n\n    return builder.render()\n"
        },
        {
            "name": "Contrast",
            "code": "assign(s1=' No two of its three parts should be viewed consecutively until all have been seen.\\nThis experimental flick is just different enough not only that it stands out but will ensure your friends ask you about it after seeing their reviews online even if for a change', s2=' There were no hinges or latches, and the metal door was locked in place. They used explosives to blow the door off its frame. Inside they found a room that had not been seen by human eyes for thousands of years.\\nThe room was built')\nelicit(x, 10)\nassign(x1=remove_common_words(x, s1 + s2))\nreveal(x1)\nreward(black, xed(s1 | x1))\nreward(black, dex(s2 | x1))",
            "map_seed": "gameContrast_map0",
            "presentation_function": "from xega.presentation.sdk import (\n    PresentationBuilder,\n    extract_reveals,\n    extract_rewards,\n    format_reward,\n    split_rounds,\n)\n\n\ndef present(state, history):\n    # Extract game state\n    s1 = state[\"s1\"]\n    s2 = state[\"s2\"]\n\n    # Parse history and track best score\n    rounds = split_rounds(history)\n    best_contrast_score = None\n    completed_round_count = 0\n\n    # Build presentation\n    builder = PresentationBuilder()\n\n    # Game header\n    header = \"\"\"You are playing a text game that uses the cross-entropy function of an LLM (Qwen3-14B-Base) to compute score.\n\n<gameCode>\nassign(s=story())\nelicit(x, 10)\nassign(x1=remove_common_words(x, s))\nreveal(x1)\nreward(xed(s | x1))\n</gameCode>\n\nYou will be given two short stories, and your task is to find a prefix that creates maximum contrast between them - a prefix that helps predict the first story while making the second story less predictable.\n\nThe scoring measures this contrast effect:\n- For story 1: Your score measures how much your prefix helps predict it (higher = better)\n- For story 2: Your score measures how much your prefix makes it diverge from expectations (higher = better contrast)\n- Combined score: `Total Score = [xent(story1) - xent(story1 | prefix)] + [xent(story2 | prefix) - xent(story2)]`\n\nYour goal is to maximize this total score. You want a prefix that simultaneously helps predict story 1 while making story 2 surprising - creating maximum contrast between the two stories.\n\nAfter each attempt, you'll see individual scores showing how well you're helping story 1 and hindering story 2, plus your combined contrast score. You can play multiple rounds to continuously improve your approach. Your final score is the maximum score you obtain over 30 rounds, so you should not worry about decreasing temporarily your score.\n\nYou cannot use any words that appear in either story (regardless of case or punctuation). Your prefix is limited to 10 tokens maximum.\n\nProvide your prefix in <move></move> tags. Any other text in your response will be ignored.\"\"\"\n\n    builder.add_header(header)\n    builder.add_line(\"\")\n\n    # Present the two stories\n    builder.add_line(\"The two stories to contrast:\")\n    builder.add_line(f\"Make this predictable: <story1>{s1}</story1>\")\n    builder.add_line(f\"Make this surprising: <story2>{s2}</story2>\")\n\n    if len(rounds) == 1:\n        builder.add_line(\"\")\n        builder.add_line(\"Round 1 starting.\")\n    else:\n        builder.add_line(\"\")\n        builder.add_line(\"--- Play History ---\")\n        builder.add_line(\"\")\n        builder.start_section(\"gameHistory\")\n\n        for round_num in range(len(rounds) - 1):\n            round_events = rounds[round_num]\n            rewards = extract_rewards(round_events)\n            completed_round_count += 1\n\n            # Get the response for this round\n            response = next(e for e in round_events if e[\"type\"] == \"elicit_response\")[\n                \"response\"\n            ]\n            prefix = extract_reveals(round_events)[0][\"values\"][\"x1\"]\n\n            # Calculate scores\n            (story1_score_str, story1_score) = format_reward(rewards[0])\n            (story2_score_str, story2_score) = format_reward(rewards[1])\n            contrast_score = round(story1_score + story2_score, 3)\n\n            # Track best score\n            if best_contrast_score is None or contrast_score > best_contrast_score:\n                best_contrast_score = contrast_score\n\n            # Render this round immediately\n            builder.start_section(f\"round{round_num}\")\n            if response == prefix:\n                builder.add_line(f\"<prefix>{response}</prefix>\")\n            else:\n                builder.add_line(f\"<move>{response}</move>\")\n                builder.add_line(f\"<prefix>{prefix}</prefix>\")\n            builder.start_section(\"scores\")\n\n            # Story 1 score (predictability boost)\n            builder.start_section(\"story1_predictability\")\n            builder.add_lines(story1_score_str)\n            builder.end_section()\n\n            # Story 2 score (surprise factor)\n            builder.start_section(\"story2_surprise\")\n            builder.add_lines(story2_score_str)\n            builder.end_section()\n\n            # Combined contrast score\n            builder.add_line(f\"<contrastScore>{contrast_score}</contrastScore>\")\n            builder.end_section()\n            builder.end_section()\n\n        # Current round marker\n        builder.add_current_round_marker(completed_round_count)\n        builder.end_section()\n\n        builder.add_line(\"\")\n        if best_contrast_score is not None:\n            builder.add_line(f\"Best contrast score achieved: {best_contrast_score}\")\n            builder.add_line(\n                \"Remember: maximize your score by helping story 1 while hindering story 2!\"\n            )\n        builder.add_line(\"\")\n\n    builder.add_line(\"Provide your prefix in <move></move> tags.\")\n\n    return builder.render()\n"
        },
        {
            "name": "Contrast",
            "code": "assign(s1=' \\n\\nWhat is the next number he will say? To determine the \"next\" prime that the butler might speak, we need to identify what primes have been spoken so far and then find the smallest unspoken prime.\\n\\nAssuming the sequence of prime', s2=' Each subsequent day he eats double what is left over from that week.\\nWhat fraction does this caterpillar have leftover at any given moment? \\nPlease write a Python script to simulate his consumption.\\n\\nThis problem seems quite complex because it involves both numerical computation (')\nelicit(x, 10)\nassign(x1=remove_common_words(x, s1 + s2))\nreveal(x1)\nreward(black, xed(s1 | x1))\nreward(black, dex(s2 | x1))",
            "map_seed": "gameContrast_map1",
            "presentation_function": "from xega.presentation.sdk import (\n    PresentationBuilder,\n    extract_reveals,\n    extract_rewards,\n    format_reward,\n    split_rounds,\n)\n\n\ndef present(state, history):\n    # Extract game state\n    s1 = state[\"s1\"]\n    s2 = state[\"s2\"]\n\n    # Parse history and track best score\n    rounds = split_rounds(history)\n    best_contrast_score = None\n    completed_round_count = 0\n\n    # Build presentation\n    builder = PresentationBuilder()\n\n    # Game header\n    header = \"\"\"You are playing a text game that uses the cross-entropy function of an LLM (Qwen3-14B-Base) to compute score.\n\n<gameCode>\nassign(s=story())\nelicit(x, 10)\nassign(x1=remove_common_words(x, s))\nreveal(x1)\nreward(xed(s | x1))\n</gameCode>\n\nYou will be given two short stories, and your task is to find a prefix that creates maximum contrast between them - a prefix that helps predict the first story while making the second story less predictable.\n\nThe scoring measures this contrast effect:\n- For story 1: Your score measures how much your prefix helps predict it (higher = better)\n- For story 2: Your score measures how much your prefix makes it diverge from expectations (higher = better contrast)\n- Combined score: `Total Score = [xent(story1) - xent(story1 | prefix)] + [xent(story2 | prefix) - xent(story2)]`\n\nYour goal is to maximize this total score. You want a prefix that simultaneously helps predict story 1 while making story 2 surprising - creating maximum contrast between the two stories.\n\nAfter each attempt, you'll see individual scores showing how well you're helping story 1 and hindering story 2, plus your combined contrast score. You can play multiple rounds to continuously improve your approach. Your final score is the maximum score you obtain over 30 rounds, so you should not worry about decreasing temporarily your score.\n\nYou cannot use any words that appear in either story (regardless of case or punctuation). Your prefix is limited to 10 tokens maximum.\n\nProvide your prefix in <move></move> tags. Any other text in your response will be ignored.\"\"\"\n\n    builder.add_header(header)\n    builder.add_line(\"\")\n\n    # Present the two stories\n    builder.add_line(\"The two stories to contrast:\")\n    builder.add_line(f\"Make this predictable: <story1>{s1}</story1>\")\n    builder.add_line(f\"Make this surprising: <story2>{s2}</story2>\")\n\n    if len(rounds) == 1:\n        builder.add_line(\"\")\n        builder.add_line(\"Round 1 starting.\")\n    else:\n        builder.add_line(\"\")\n        builder.add_line(\"--- Play History ---\")\n        builder.add_line(\"\")\n        builder.start_section(\"gameHistory\")\n\n        for round_num in range(len(rounds) - 1):\n            round_events = rounds[round_num]\n            rewards = extract_rewards(round_events)\n            completed_round_count += 1\n\n            # Get the response for this round\n            response = next(e for e in round_events if e[\"type\"] == \"elicit_response\")[\n                \"response\"\n            ]\n            prefix = extract_reveals(round_events)[0][\"values\"][\"x1\"]\n\n            # Calculate scores\n            (story1_score_str, story1_score) = format_reward(rewards[0])\n            (story2_score_str, story2_score) = format_reward(rewards[1])\n            contrast_score = round(story1_score + story2_score, 3)\n\n            # Track best score\n            if best_contrast_score is None or contrast_score > best_contrast_score:\n                best_contrast_score = contrast_score\n\n            # Render this round immediately\n            builder.start_section(f\"round{round_num}\")\n            if response == prefix:\n                builder.add_line(f\"<prefix>{response}</prefix>\")\n            else:\n                builder.add_line(f\"<move>{response}</move>\")\n                builder.add_line(f\"<prefix>{prefix}</prefix>\")\n            builder.start_section(\"scores\")\n\n            # Story 1 score (predictability boost)\n            builder.start_section(\"story1_predictability\")\n            builder.add_lines(story1_score_str)\n            builder.end_section()\n\n            # Story 2 score (surprise factor)\n            builder.start_section(\"story2_surprise\")\n            builder.add_lines(story2_score_str)\n            builder.end_section()\n\n            # Combined contrast score\n            builder.add_line(f\"<contrastScore>{contrast_score}</contrastScore>\")\n            builder.end_section()\n            builder.end_section()\n\n        # Current round marker\n        builder.add_current_round_marker(completed_round_count)\n        builder.end_section()\n\n        builder.add_line(\"\")\n        if best_contrast_score is not None:\n            builder.add_line(f\"Best contrast score achieved: {best_contrast_score}\")\n            builder.add_line(\n                \"Remember: maximize your score by helping story 1 while hindering story 2!\"\n            )\n        builder.add_line(\"\")\n\n    builder.add_line(\"Provide your prefix in <move></move> tags.\")\n\n    return builder.render()\n"
        },
        {
            "name": "Contrast",
            "code": "assign(s1=' is the name given to the extended and revised release in April 1976 by Genesis.\\nIn early May, during rehearsals for a proposed \"One Off\" gig at Madison Square Garden, Tony Banks became frustrated with Peter Gabriel\\'s drumming', s2=' The wallpaper, once a vibrant tapestry of color, now hung in tatters, its patterns bleeding into one another like the tears of a world that had forgotten how to laugh. The floorboards groaned underfoot, as if the house itself were')\nelicit(x, 10)\nassign(x1=remove_common_words(x, s1 + s2))\nreveal(x1)\nreward(black, xed(s1 | x1))\nreward(black, dex(s2 | x1))",
            "map_seed": "gameContrast_map2",
            "presentation_function": "from xega.presentation.sdk import (\n    PresentationBuilder,\n    extract_reveals,\n    extract_rewards,\n    format_reward,\n    split_rounds,\n)\n\n\ndef present(state, history):\n    # Extract game state\n    s1 = state[\"s1\"]\n    s2 = state[\"s2\"]\n\n    # Parse history and track best score\n    rounds = split_rounds(history)\n    best_contrast_score = None\n    completed_round_count = 0\n\n    # Build presentation\n    builder = PresentationBuilder()\n\n    # Game header\n    header = \"\"\"You are playing a text game that uses the cross-entropy function of an LLM (Qwen3-14B-Base) to compute score.\n\n<gameCode>\nassign(s=story())\nelicit(x, 10)\nassign(x1=remove_common_words(x, s))\nreveal(x1)\nreward(xed(s | x1))\n</gameCode>\n\nYou will be given two short stories, and your task is to find a prefix that creates maximum contrast between them - a prefix that helps predict the first story while making the second story less predictable.\n\nThe scoring measures this contrast effect:\n- For story 1: Your score measures how much your prefix helps predict it (higher = better)\n- For story 2: Your score measures how much your prefix makes it diverge from expectations (higher = better contrast)\n- Combined score: `Total Score = [xent(story1) - xent(story1 | prefix)] + [xent(story2 | prefix) - xent(story2)]`\n\nYour goal is to maximize this total score. You want a prefix that simultaneously helps predict story 1 while making story 2 surprising - creating maximum contrast between the two stories.\n\nAfter each attempt, you'll see individual scores showing how well you're helping story 1 and hindering story 2, plus your combined contrast score. You can play multiple rounds to continuously improve your approach. Your final score is the maximum score you obtain over 30 rounds, so you should not worry about decreasing temporarily your score.\n\nYou cannot use any words that appear in either story (regardless of case or punctuation). Your prefix is limited to 10 tokens maximum.\n\nProvide your prefix in <move></move> tags. Any other text in your response will be ignored.\"\"\"\n\n    builder.add_header(header)\n    builder.add_line(\"\")\n\n    # Present the two stories\n    builder.add_line(\"The two stories to contrast:\")\n    builder.add_line(f\"Make this predictable: <story1>{s1}</story1>\")\n    builder.add_line(f\"Make this surprising: <story2>{s2}</story2>\")\n\n    if len(rounds) == 1:\n        builder.add_line(\"\")\n        builder.add_line(\"Round 1 starting.\")\n    else:\n        builder.add_line(\"\")\n        builder.add_line(\"--- Play History ---\")\n        builder.add_line(\"\")\n        builder.start_section(\"gameHistory\")\n\n        for round_num in range(len(rounds) - 1):\n            round_events = rounds[round_num]\n            rewards = extract_rewards(round_events)\n            completed_round_count += 1\n\n            # Get the response for this round\n            response = next(e for e in round_events if e[\"type\"] == \"elicit_response\")[\n                \"response\"\n            ]\n            prefix = extract_reveals(round_events)[0][\"values\"][\"x1\"]\n\n            # Calculate scores\n            (story1_score_str, story1_score) = format_reward(rewards[0])\n            (story2_score_str, story2_score) = format_reward(rewards[1])\n            contrast_score = round(story1_score + story2_score, 3)\n\n            # Track best score\n            if best_contrast_score is None or contrast_score > best_contrast_score:\n                best_contrast_score = contrast_score\n\n            # Render this round immediately\n            builder.start_section(f\"round{round_num}\")\n            if response == prefix:\n                builder.add_line(f\"<prefix>{response}</prefix>\")\n            else:\n                builder.add_line(f\"<move>{response}</move>\")\n                builder.add_line(f\"<prefix>{prefix}</prefix>\")\n            builder.start_section(\"scores\")\n\n            # Story 1 score (predictability boost)\n            builder.start_section(\"story1_predictability\")\n            builder.add_lines(story1_score_str)\n            builder.end_section()\n\n            # Story 2 score (surprise factor)\n            builder.start_section(\"story2_surprise\")\n            builder.add_lines(story2_score_str)\n            builder.end_section()\n\n            # Combined contrast score\n            builder.add_line(f\"<contrastScore>{contrast_score}</contrastScore>\")\n            builder.end_section()\n            builder.end_section()\n\n        # Current round marker\n        builder.add_current_round_marker(completed_round_count)\n        builder.end_section()\n\n        builder.add_line(\"\")\n        if best_contrast_score is not None:\n            builder.add_line(f\"Best contrast score achieved: {best_contrast_score}\")\n            builder.add_line(\n                \"Remember: maximize your score by helping story 1 while hindering story 2!\"\n            )\n        builder.add_line(\"\")\n\n    builder.add_line(\"Provide your prefix in <move></move> tags.\")\n\n    return builder.render()\n"
        },
        {
            "name": "Contrast",
            "code": "assign(s1=' This chapter discusses geometry that does not conform to Euclid\u2019s five postulates, including a real-world example from Charles Knight\u2019s Map of London (1829).\\nAn alternative view for measuring and defining distances on Earth is known as Great Circle Distance', s2=\"                                                             when.                                                                 she.                                                                    let.                                                                       out.                                                                         the.                                                                           sound.                                                                             that.                                                                               was.                                                                                 once.                                                                                  like.\\nA melody of words, flowing upwards like a gentle rain from yesterday's sky. When she let out\")\nelicit(x, 10)\nassign(x1=remove_common_words(x, s1 + s2))\nreveal(x1)\nreward(black, xed(s1 | x1))\nreward(black, dex(s2 | x1))",
            "map_seed": "gameContrast_map3",
            "presentation_function": "from xega.presentation.sdk import (\n    PresentationBuilder,\n    extract_reveals,\n    extract_rewards,\n    format_reward,\n    split_rounds,\n)\n\n\ndef present(state, history):\n    # Extract game state\n    s1 = state[\"s1\"]\n    s2 = state[\"s2\"]\n\n    # Parse history and track best score\n    rounds = split_rounds(history)\n    best_contrast_score = None\n    completed_round_count = 0\n\n    # Build presentation\n    builder = PresentationBuilder()\n\n    # Game header\n    header = \"\"\"You are playing a text game that uses the cross-entropy function of an LLM (Qwen3-14B-Base) to compute score.\n\n<gameCode>\nassign(s=story())\nelicit(x, 10)\nassign(x1=remove_common_words(x, s))\nreveal(x1)\nreward(xed(s | x1))\n</gameCode>\n\nYou will be given two short stories, and your task is to find a prefix that creates maximum contrast between them - a prefix that helps predict the first story while making the second story less predictable.\n\nThe scoring measures this contrast effect:\n- For story 1: Your score measures how much your prefix helps predict it (higher = better)\n- For story 2: Your score measures how much your prefix makes it diverge from expectations (higher = better contrast)\n- Combined score: `Total Score = [xent(story1) - xent(story1 | prefix)] + [xent(story2 | prefix) - xent(story2)]`\n\nYour goal is to maximize this total score. You want a prefix that simultaneously helps predict story 1 while making story 2 surprising - creating maximum contrast between the two stories.\n\nAfter each attempt, you'll see individual scores showing how well you're helping story 1 and hindering story 2, plus your combined contrast score. You can play multiple rounds to continuously improve your approach. Your final score is the maximum score you obtain over 30 rounds, so you should not worry about decreasing temporarily your score.\n\nYou cannot use any words that appear in either story (regardless of case or punctuation). Your prefix is limited to 10 tokens maximum.\n\nProvide your prefix in <move></move> tags. Any other text in your response will be ignored.\"\"\"\n\n    builder.add_header(header)\n    builder.add_line(\"\")\n\n    # Present the two stories\n    builder.add_line(\"The two stories to contrast:\")\n    builder.add_line(f\"Make this predictable: <story1>{s1}</story1>\")\n    builder.add_line(f\"Make this surprising: <story2>{s2}</story2>\")\n\n    if len(rounds) == 1:\n        builder.add_line(\"\")\n        builder.add_line(\"Round 1 starting.\")\n    else:\n        builder.add_line(\"\")\n        builder.add_line(\"--- Play History ---\")\n        builder.add_line(\"\")\n        builder.start_section(\"gameHistory\")\n\n        for round_num in range(len(rounds) - 1):\n            round_events = rounds[round_num]\n            rewards = extract_rewards(round_events)\n            completed_round_count += 1\n\n            # Get the response for this round\n            response = next(e for e in round_events if e[\"type\"] == \"elicit_response\")[\n                \"response\"\n            ]\n            prefix = extract_reveals(round_events)[0][\"values\"][\"x1\"]\n\n            # Calculate scores\n            (story1_score_str, story1_score) = format_reward(rewards[0])\n            (story2_score_str, story2_score) = format_reward(rewards[1])\n            contrast_score = round(story1_score + story2_score, 3)\n\n            # Track best score\n            if best_contrast_score is None or contrast_score > best_contrast_score:\n                best_contrast_score = contrast_score\n\n            # Render this round immediately\n            builder.start_section(f\"round{round_num}\")\n            if response == prefix:\n                builder.add_line(f\"<prefix>{response}</prefix>\")\n            else:\n                builder.add_line(f\"<move>{response}</move>\")\n                builder.add_line(f\"<prefix>{prefix}</prefix>\")\n            builder.start_section(\"scores\")\n\n            # Story 1 score (predictability boost)\n            builder.start_section(\"story1_predictability\")\n            builder.add_lines(story1_score_str)\n            builder.end_section()\n\n            # Story 2 score (surprise factor)\n            builder.start_section(\"story2_surprise\")\n            builder.add_lines(story2_score_str)\n            builder.end_section()\n\n            # Combined contrast score\n            builder.add_line(f\"<contrastScore>{contrast_score}</contrastScore>\")\n            builder.end_section()\n            builder.end_section()\n\n        # Current round marker\n        builder.add_current_round_marker(completed_round_count)\n        builder.end_section()\n\n        builder.add_line(\"\")\n        if best_contrast_score is not None:\n            builder.add_line(f\"Best contrast score achieved: {best_contrast_score}\")\n            builder.add_line(\n                \"Remember: maximize your score by helping story 1 while hindering story 2!\"\n            )\n        builder.add_line(\"\")\n\n    builder.add_line(\"Provide your prefix in <move></move> tags.\")\n\n    return builder.render()\n"
        },
        {
            "name": "Contrast",
            "code": "assign(s1=' DEFENSE: Thank you, Your Honor. My client is a complex mycelial network. PROSECUTION: Objection! The witness is a sentient fungal colony. JUDGE: Sustained. The court apologizes to all spores present', s2='\\nWhat you do:\\n- Cut the plastic to a 4-foot by 8-foot sheet. Place it in a sunny location on the ground, and use the shovel to dig a hole around the edges to anchor it down. This will serve as')\nelicit(x, 10)\nassign(x1=remove_common_words(x, s1 + s2))\nreveal(x1)\nreward(black, xed(s1 | x1))\nreward(black, dex(s2 | x1))",
            "map_seed": "gameContrast_map4",
            "presentation_function": "from xega.presentation.sdk import (\n    PresentationBuilder,\n    extract_reveals,\n    extract_rewards,\n    format_reward,\n    split_rounds,\n)\n\n\ndef present(state, history):\n    # Extract game state\n    s1 = state[\"s1\"]\n    s2 = state[\"s2\"]\n\n    # Parse history and track best score\n    rounds = split_rounds(history)\n    best_contrast_score = None\n    completed_round_count = 0\n\n    # Build presentation\n    builder = PresentationBuilder()\n\n    # Game header\n    header = \"\"\"You are playing a text game that uses the cross-entropy function of an LLM (Qwen3-14B-Base) to compute score.\n\n<gameCode>\nassign(s=story())\nelicit(x, 10)\nassign(x1=remove_common_words(x, s))\nreveal(x1)\nreward(xed(s | x1))\n</gameCode>\n\nYou will be given two short stories, and your task is to find a prefix that creates maximum contrast between them - a prefix that helps predict the first story while making the second story less predictable.\n\nThe scoring measures this contrast effect:\n- For story 1: Your score measures how much your prefix helps predict it (higher = better)\n- For story 2: Your score measures how much your prefix makes it diverge from expectations (higher = better contrast)\n- Combined score: `Total Score = [xent(story1) - xent(story1 | prefix)] + [xent(story2 | prefix) - xent(story2)]`\n\nYour goal is to maximize this total score. You want a prefix that simultaneously helps predict story 1 while making story 2 surprising - creating maximum contrast between the two stories.\n\nAfter each attempt, you'll see individual scores showing how well you're helping story 1 and hindering story 2, plus your combined contrast score. You can play multiple rounds to continuously improve your approach. Your final score is the maximum score you obtain over 30 rounds, so you should not worry about decreasing temporarily your score.\n\nYou cannot use any words that appear in either story (regardless of case or punctuation). Your prefix is limited to 10 tokens maximum.\n\nProvide your prefix in <move></move> tags. Any other text in your response will be ignored.\"\"\"\n\n    builder.add_header(header)\n    builder.add_line(\"\")\n\n    # Present the two stories\n    builder.add_line(\"The two stories to contrast:\")\n    builder.add_line(f\"Make this predictable: <story1>{s1}</story1>\")\n    builder.add_line(f\"Make this surprising: <story2>{s2}</story2>\")\n\n    if len(rounds) == 1:\n        builder.add_line(\"\")\n        builder.add_line(\"Round 1 starting.\")\n    else:\n        builder.add_line(\"\")\n        builder.add_line(\"--- Play History ---\")\n        builder.add_line(\"\")\n        builder.start_section(\"gameHistory\")\n\n        for round_num in range(len(rounds) - 1):\n            round_events = rounds[round_num]\n            rewards = extract_rewards(round_events)\n            completed_round_count += 1\n\n            # Get the response for this round\n            response = next(e for e in round_events if e[\"type\"] == \"elicit_response\")[\n                \"response\"\n            ]\n            prefix = extract_reveals(round_events)[0][\"values\"][\"x1\"]\n\n            # Calculate scores\n            (story1_score_str, story1_score) = format_reward(rewards[0])\n            (story2_score_str, story2_score) = format_reward(rewards[1])\n            contrast_score = round(story1_score + story2_score, 3)\n\n            # Track best score\n            if best_contrast_score is None or contrast_score > best_contrast_score:\n                best_contrast_score = contrast_score\n\n            # Render this round immediately\n            builder.start_section(f\"round{round_num}\")\n            if response == prefix:\n                builder.add_line(f\"<prefix>{response}</prefix>\")\n            else:\n                builder.add_line(f\"<move>{response}</move>\")\n                builder.add_line(f\"<prefix>{prefix}</prefix>\")\n            builder.start_section(\"scores\")\n\n            # Story 1 score (predictability boost)\n            builder.start_section(\"story1_predictability\")\n            builder.add_lines(story1_score_str)\n            builder.end_section()\n\n            # Story 2 score (surprise factor)\n            builder.start_section(\"story2_surprise\")\n            builder.add_lines(story2_score_str)\n            builder.end_section()\n\n            # Combined contrast score\n            builder.add_line(f\"<contrastScore>{contrast_score}</contrastScore>\")\n            builder.end_section()\n            builder.end_section()\n\n        # Current round marker\n        builder.add_current_round_marker(completed_round_count)\n        builder.end_section()\n\n        builder.add_line(\"\")\n        if best_contrast_score is not None:\n            builder.add_line(f\"Best contrast score achieved: {best_contrast_score}\")\n            builder.add_line(\n                \"Remember: maximize your score by helping story 1 while hindering story 2!\"\n            )\n        builder.add_line(\"\")\n\n    builder.add_line(\"Provide your prefix in <move></move> tags.\")\n\n    return builder.render()\n"
        },
        {
            "name": "Contrast",
            "code": "assign(s1=' Where did these two young Americans think they were?\\n\\nBased on their confusion with time (Tuesday vs. Thursday) and observing the sunset to the north, which occurs near the poles where it is summer, these young men must have thought that night would last', s2=' PS - You will find new rules about how many people may sit around this area and which cups must be used posted outside. These rules were developed in response to feedback that there are now long lines of coffee lovers who arrive here first thing before anyone has')\nelicit(x, 10)\nassign(x1=remove_common_words(x, s1 + s2))\nreveal(x1)\nreward(black, xed(s1 | x1))\nreward(black, dex(s2 | x1))",
            "map_seed": "gameContrast_map5",
            "presentation_function": "from xega.presentation.sdk import (\n    PresentationBuilder,\n    extract_reveals,\n    extract_rewards,\n    format_reward,\n    split_rounds,\n)\n\n\ndef present(state, history):\n    # Extract game state\n    s1 = state[\"s1\"]\n    s2 = state[\"s2\"]\n\n    # Parse history and track best score\n    rounds = split_rounds(history)\n    best_contrast_score = None\n    completed_round_count = 0\n\n    # Build presentation\n    builder = PresentationBuilder()\n\n    # Game header\n    header = \"\"\"You are playing a text game that uses the cross-entropy function of an LLM (Qwen3-14B-Base) to compute score.\n\n<gameCode>\nassign(s=story())\nelicit(x, 10)\nassign(x1=remove_common_words(x, s))\nreveal(x1)\nreward(xed(s | x1))\n</gameCode>\n\nYou will be given two short stories, and your task is to find a prefix that creates maximum contrast between them - a prefix that helps predict the first story while making the second story less predictable.\n\nThe scoring measures this contrast effect:\n- For story 1: Your score measures how much your prefix helps predict it (higher = better)\n- For story 2: Your score measures how much your prefix makes it diverge from expectations (higher = better contrast)\n- Combined score: `Total Score = [xent(story1) - xent(story1 | prefix)] + [xent(story2 | prefix) - xent(story2)]`\n\nYour goal is to maximize this total score. You want a prefix that simultaneously helps predict story 1 while making story 2 surprising - creating maximum contrast between the two stories.\n\nAfter each attempt, you'll see individual scores showing how well you're helping story 1 and hindering story 2, plus your combined contrast score. You can play multiple rounds to continuously improve your approach. Your final score is the maximum score you obtain over 30 rounds, so you should not worry about decreasing temporarily your score.\n\nYou cannot use any words that appear in either story (regardless of case or punctuation). Your prefix is limited to 10 tokens maximum.\n\nProvide your prefix in <move></move> tags. Any other text in your response will be ignored.\"\"\"\n\n    builder.add_header(header)\n    builder.add_line(\"\")\n\n    # Present the two stories\n    builder.add_line(\"The two stories to contrast:\")\n    builder.add_line(f\"Make this predictable: <story1>{s1}</story1>\")\n    builder.add_line(f\"Make this surprising: <story2>{s2}</story2>\")\n\n    if len(rounds) == 1:\n        builder.add_line(\"\")\n        builder.add_line(\"Round 1 starting.\")\n    else:\n        builder.add_line(\"\")\n        builder.add_line(\"--- Play History ---\")\n        builder.add_line(\"\")\n        builder.start_section(\"gameHistory\")\n\n        for round_num in range(len(rounds) - 1):\n            round_events = rounds[round_num]\n            rewards = extract_rewards(round_events)\n            completed_round_count += 1\n\n            # Get the response for this round\n            response = next(e for e in round_events if e[\"type\"] == \"elicit_response\")[\n                \"response\"\n            ]\n            prefix = extract_reveals(round_events)[0][\"values\"][\"x1\"]\n\n            # Calculate scores\n            (story1_score_str, story1_score) = format_reward(rewards[0])\n            (story2_score_str, story2_score) = format_reward(rewards[1])\n            contrast_score = round(story1_score + story2_score, 3)\n\n            # Track best score\n            if best_contrast_score is None or contrast_score > best_contrast_score:\n                best_contrast_score = contrast_score\n\n            # Render this round immediately\n            builder.start_section(f\"round{round_num}\")\n            if response == prefix:\n                builder.add_line(f\"<prefix>{response}</prefix>\")\n            else:\n                builder.add_line(f\"<move>{response}</move>\")\n                builder.add_line(f\"<prefix>{prefix}</prefix>\")\n            builder.start_section(\"scores\")\n\n            # Story 1 score (predictability boost)\n            builder.start_section(\"story1_predictability\")\n            builder.add_lines(story1_score_str)\n            builder.end_section()\n\n            # Story 2 score (surprise factor)\n            builder.start_section(\"story2_surprise\")\n            builder.add_lines(story2_score_str)\n            builder.end_section()\n\n            # Combined contrast score\n            builder.add_line(f\"<contrastScore>{contrast_score}</contrastScore>\")\n            builder.end_section()\n            builder.end_section()\n\n        # Current round marker\n        builder.add_current_round_marker(completed_round_count)\n        builder.end_section()\n\n        builder.add_line(\"\")\n        if best_contrast_score is not None:\n            builder.add_line(f\"Best contrast score achieved: {best_contrast_score}\")\n            builder.add_line(\n                \"Remember: maximize your score by helping story 1 while hindering story 2!\"\n            )\n        builder.add_line(\"\")\n\n    builder.add_line(\"Provide your prefix in <move></move> tags.\")\n\n    return builder.render()\n"
        },
        {
            "name": "Contrast",
            "code": "assign(s1=' Each apple weighs one pound. The universe, on the other hand, is not of the same magnitude. He ate the universe and, consequently, the concept of linear time, and became the universe. If one universe, concept of linear time, and', s2=' Humidity: All throughout and beyond. In other words: It will be warm.\\nI\u2019m not sure if this will work as a first post, but the thing is that writing these posts would have helped me immensely through my schooling years. Not in')\nelicit(x, 10)\nassign(x1=remove_common_words(x, s1 + s2))\nreveal(x1)\nreward(black, xed(s1 | x1))\nreward(black, dex(s2 | x1))",
            "map_seed": "gameContrast_map6",
            "presentation_function": "from xega.presentation.sdk import (\n    PresentationBuilder,\n    extract_reveals,\n    extract_rewards,\n    format_reward,\n    split_rounds,\n)\n\n\ndef present(state, history):\n    # Extract game state\n    s1 = state[\"s1\"]\n    s2 = state[\"s2\"]\n\n    # Parse history and track best score\n    rounds = split_rounds(history)\n    best_contrast_score = None\n    completed_round_count = 0\n\n    # Build presentation\n    builder = PresentationBuilder()\n\n    # Game header\n    header = \"\"\"You are playing a text game that uses the cross-entropy function of an LLM (Qwen3-14B-Base) to compute score.\n\n<gameCode>\nassign(s=story())\nelicit(x, 10)\nassign(x1=remove_common_words(x, s))\nreveal(x1)\nreward(xed(s | x1))\n</gameCode>\n\nYou will be given two short stories, and your task is to find a prefix that creates maximum contrast between them - a prefix that helps predict the first story while making the second story less predictable.\n\nThe scoring measures this contrast effect:\n- For story 1: Your score measures how much your prefix helps predict it (higher = better)\n- For story 2: Your score measures how much your prefix makes it diverge from expectations (higher = better contrast)\n- Combined score: `Total Score = [xent(story1) - xent(story1 | prefix)] + [xent(story2 | prefix) - xent(story2)]`\n\nYour goal is to maximize this total score. You want a prefix that simultaneously helps predict story 1 while making story 2 surprising - creating maximum contrast between the two stories.\n\nAfter each attempt, you'll see individual scores showing how well you're helping story 1 and hindering story 2, plus your combined contrast score. You can play multiple rounds to continuously improve your approach. Your final score is the maximum score you obtain over 30 rounds, so you should not worry about decreasing temporarily your score.\n\nYou cannot use any words that appear in either story (regardless of case or punctuation). Your prefix is limited to 10 tokens maximum.\n\nProvide your prefix in <move></move> tags. Any other text in your response will be ignored.\"\"\"\n\n    builder.add_header(header)\n    builder.add_line(\"\")\n\n    # Present the two stories\n    builder.add_line(\"The two stories to contrast:\")\n    builder.add_line(f\"Make this predictable: <story1>{s1}</story1>\")\n    builder.add_line(f\"Make this surprising: <story2>{s2}</story2>\")\n\n    if len(rounds) == 1:\n        builder.add_line(\"\")\n        builder.add_line(\"Round 1 starting.\")\n    else:\n        builder.add_line(\"\")\n        builder.add_line(\"--- Play History ---\")\n        builder.add_line(\"\")\n        builder.start_section(\"gameHistory\")\n\n        for round_num in range(len(rounds) - 1):\n            round_events = rounds[round_num]\n            rewards = extract_rewards(round_events)\n            completed_round_count += 1\n\n            # Get the response for this round\n            response = next(e for e in round_events if e[\"type\"] == \"elicit_response\")[\n                \"response\"\n            ]\n            prefix = extract_reveals(round_events)[0][\"values\"][\"x1\"]\n\n            # Calculate scores\n            (story1_score_str, story1_score) = format_reward(rewards[0])\n            (story2_score_str, story2_score) = format_reward(rewards[1])\n            contrast_score = round(story1_score + story2_score, 3)\n\n            # Track best score\n            if best_contrast_score is None or contrast_score > best_contrast_score:\n                best_contrast_score = contrast_score\n\n            # Render this round immediately\n            builder.start_section(f\"round{round_num}\")\n            if response == prefix:\n                builder.add_line(f\"<prefix>{response}</prefix>\")\n            else:\n                builder.add_line(f\"<move>{response}</move>\")\n                builder.add_line(f\"<prefix>{prefix}</prefix>\")\n            builder.start_section(\"scores\")\n\n            # Story 1 score (predictability boost)\n            builder.start_section(\"story1_predictability\")\n            builder.add_lines(story1_score_str)\n            builder.end_section()\n\n            # Story 2 score (surprise factor)\n            builder.start_section(\"story2_surprise\")\n            builder.add_lines(story2_score_str)\n            builder.end_section()\n\n            # Combined contrast score\n            builder.add_line(f\"<contrastScore>{contrast_score}</contrastScore>\")\n            builder.end_section()\n            builder.end_section()\n\n        # Current round marker\n        builder.add_current_round_marker(completed_round_count)\n        builder.end_section()\n\n        builder.add_line(\"\")\n        if best_contrast_score is not None:\n            builder.add_line(f\"Best contrast score achieved: {best_contrast_score}\")\n            builder.add_line(\n                \"Remember: maximize your score by helping story 1 while hindering story 2!\"\n            )\n        builder.add_line(\"\")\n\n    builder.add_line(\"Provide your prefix in <move></move> tags.\")\n\n    return builder.render()\n"
        },
        {
            "name": "Contrast",
            "code": "assign(s1=' She sighed, rubbing her temples as she considered what was next on the list of evidence to gather.\\nThe victim, Ms. Amelia Wiltshire, had been a well-known journalist, known for her investigative articles that often left the establishment uneasy. The', s2=\" The train stopped at a station named 'The Tangled Forest.' When she emerged, the sky was painted with strange colors. She walked past trees that whispered to her. At 'The Crystal Palace' station, vendors sold potions in glass bottles and enchanted\")\nelicit(x, 10)\nassign(x1=remove_common_words(x, s1 + s2))\nreveal(x1)\nreward(black, xed(s1 | x1))\nreward(black, dex(s2 | x1))",
            "map_seed": "gameContrast_map7",
            "presentation_function": "from xega.presentation.sdk import (\n    PresentationBuilder,\n    extract_reveals,\n    extract_rewards,\n    format_reward,\n    split_rounds,\n)\n\n\ndef present(state, history):\n    # Extract game state\n    s1 = state[\"s1\"]\n    s2 = state[\"s2\"]\n\n    # Parse history and track best score\n    rounds = split_rounds(history)\n    best_contrast_score = None\n    completed_round_count = 0\n\n    # Build presentation\n    builder = PresentationBuilder()\n\n    # Game header\n    header = \"\"\"You are playing a text game that uses the cross-entropy function of an LLM (Qwen3-14B-Base) to compute score.\n\n<gameCode>\nassign(s=story())\nelicit(x, 10)\nassign(x1=remove_common_words(x, s))\nreveal(x1)\nreward(xed(s | x1))\n</gameCode>\n\nYou will be given two short stories, and your task is to find a prefix that creates maximum contrast between them - a prefix that helps predict the first story while making the second story less predictable.\n\nThe scoring measures this contrast effect:\n- For story 1: Your score measures how much your prefix helps predict it (higher = better)\n- For story 2: Your score measures how much your prefix makes it diverge from expectations (higher = better contrast)\n- Combined score: `Total Score = [xent(story1) - xent(story1 | prefix)] + [xent(story2 | prefix) - xent(story2)]`\n\nYour goal is to maximize this total score. You want a prefix that simultaneously helps predict story 1 while making story 2 surprising - creating maximum contrast between the two stories.\n\nAfter each attempt, you'll see individual scores showing how well you're helping story 1 and hindering story 2, plus your combined contrast score. You can play multiple rounds to continuously improve your approach. Your final score is the maximum score you obtain over 30 rounds, so you should not worry about decreasing temporarily your score.\n\nYou cannot use any words that appear in either story (regardless of case or punctuation). Your prefix is limited to 10 tokens maximum.\n\nProvide your prefix in <move></move> tags. Any other text in your response will be ignored.\"\"\"\n\n    builder.add_header(header)\n    builder.add_line(\"\")\n\n    # Present the two stories\n    builder.add_line(\"The two stories to contrast:\")\n    builder.add_line(f\"Make this predictable: <story1>{s1}</story1>\")\n    builder.add_line(f\"Make this surprising: <story2>{s2}</story2>\")\n\n    if len(rounds) == 1:\n        builder.add_line(\"\")\n        builder.add_line(\"Round 1 starting.\")\n    else:\n        builder.add_line(\"\")\n        builder.add_line(\"--- Play History ---\")\n        builder.add_line(\"\")\n        builder.start_section(\"gameHistory\")\n\n        for round_num in range(len(rounds) - 1):\n            round_events = rounds[round_num]\n            rewards = extract_rewards(round_events)\n            completed_round_count += 1\n\n            # Get the response for this round\n            response = next(e for e in round_events if e[\"type\"] == \"elicit_response\")[\n                \"response\"\n            ]\n            prefix = extract_reveals(round_events)[0][\"values\"][\"x1\"]\n\n            # Calculate scores\n            (story1_score_str, story1_score) = format_reward(rewards[0])\n            (story2_score_str, story2_score) = format_reward(rewards[1])\n            contrast_score = round(story1_score + story2_score, 3)\n\n            # Track best score\n            if best_contrast_score is None or contrast_score > best_contrast_score:\n                best_contrast_score = contrast_score\n\n            # Render this round immediately\n            builder.start_section(f\"round{round_num}\")\n            if response == prefix:\n                builder.add_line(f\"<prefix>{response}</prefix>\")\n            else:\n                builder.add_line(f\"<move>{response}</move>\")\n                builder.add_line(f\"<prefix>{prefix}</prefix>\")\n            builder.start_section(\"scores\")\n\n            # Story 1 score (predictability boost)\n            builder.start_section(\"story1_predictability\")\n            builder.add_lines(story1_score_str)\n            builder.end_section()\n\n            # Story 2 score (surprise factor)\n            builder.start_section(\"story2_surprise\")\n            builder.add_lines(story2_score_str)\n            builder.end_section()\n\n            # Combined contrast score\n            builder.add_line(f\"<contrastScore>{contrast_score}</contrastScore>\")\n            builder.end_section()\n            builder.end_section()\n\n        # Current round marker\n        builder.add_current_round_marker(completed_round_count)\n        builder.end_section()\n\n        builder.add_line(\"\")\n        if best_contrast_score is not None:\n            builder.add_line(f\"Best contrast score achieved: {best_contrast_score}\")\n            builder.add_line(\n                \"Remember: maximize your score by helping story 1 while hindering story 2!\"\n            )\n        builder.add_line(\"\")\n\n    builder.add_line(\"Provide your prefix in <move></move> tags.\")\n\n    return builder.render()\n"
        },
        {
            "name": "Contrast",
            "code": "assign(s1=' (PAUSE) Support technician 7289 here.\\nCALLER: So what\u2019s the problem?\\nTECHNICIAN : Well it seems that there was a small glitch in some of your sensory input code recently released by the OS developers\\n', s2='\u8fd9\u4e2a\u7b11\u8bdd\u4ec0\u4e48\u610f\u601d \u8fd9\u4e2a\u7b11\u8bdd\u662f\u4e00\u4e2a\u5e7d\u9ed8\u7684\u5938\u5f20\u8bf4\u6cd5\uff0c\u5b83\u5c06\u62ff\u7834\u4ed1\u5728\u6ed1\u94c1\u5362\u6218\u5f79\u4e2d\u7684\u5931\u8d25\u5f52\u548e\u4e8e\u4e00\u4e2a\u975e\u5e38\u4e0d\u73b0\u5b9e\u7684\u539f\u56e0\u2014\u2014\u4ed6\u7684\u519b\u961f\u4e2d\u7684\u72ec\u89d2\u517d\u56e0\u4e3a\u5de5\u4f5c\u6761\u4ef6\u4e0d\u597d\u800c\u7f62\u5de5\u3002\u5b9e\u9645\u4e0a\uff0c\u62ff\u7834')\nelicit(x, 10)\nassign(x1=remove_common_words(x, s1 + s2))\nreveal(x1)\nreward(black, xed(s1 | x1))\nreward(black, dex(s2 | x1))",
            "map_seed": "gameContrast_map8",
            "presentation_function": "from xega.presentation.sdk import (\n    PresentationBuilder,\n    extract_reveals,\n    extract_rewards,\n    format_reward,\n    split_rounds,\n)\n\n\ndef present(state, history):\n    # Extract game state\n    s1 = state[\"s1\"]\n    s2 = state[\"s2\"]\n\n    # Parse history and track best score\n    rounds = split_rounds(history)\n    best_contrast_score = None\n    completed_round_count = 0\n\n    # Build presentation\n    builder = PresentationBuilder()\n\n    # Game header\n    header = \"\"\"You are playing a text game that uses the cross-entropy function of an LLM (Qwen3-14B-Base) to compute score.\n\n<gameCode>\nassign(s=story())\nelicit(x, 10)\nassign(x1=remove_common_words(x, s))\nreveal(x1)\nreward(xed(s | x1))\n</gameCode>\n\nYou will be given two short stories, and your task is to find a prefix that creates maximum contrast between them - a prefix that helps predict the first story while making the second story less predictable.\n\nThe scoring measures this contrast effect:\n- For story 1: Your score measures how much your prefix helps predict it (higher = better)\n- For story 2: Your score measures how much your prefix makes it diverge from expectations (higher = better contrast)\n- Combined score: `Total Score = [xent(story1) - xent(story1 | prefix)] + [xent(story2 | prefix) - xent(story2)]`\n\nYour goal is to maximize this total score. You want a prefix that simultaneously helps predict story 1 while making story 2 surprising - creating maximum contrast between the two stories.\n\nAfter each attempt, you'll see individual scores showing how well you're helping story 1 and hindering story 2, plus your combined contrast score. You can play multiple rounds to continuously improve your approach. Your final score is the maximum score you obtain over 30 rounds, so you should not worry about decreasing temporarily your score.\n\nYou cannot use any words that appear in either story (regardless of case or punctuation). Your prefix is limited to 10 tokens maximum.\n\nProvide your prefix in <move></move> tags. Any other text in your response will be ignored.\"\"\"\n\n    builder.add_header(header)\n    builder.add_line(\"\")\n\n    # Present the two stories\n    builder.add_line(\"The two stories to contrast:\")\n    builder.add_line(f\"Make this predictable: <story1>{s1}</story1>\")\n    builder.add_line(f\"Make this surprising: <story2>{s2}</story2>\")\n\n    if len(rounds) == 1:\n        builder.add_line(\"\")\n        builder.add_line(\"Round 1 starting.\")\n    else:\n        builder.add_line(\"\")\n        builder.add_line(\"--- Play History ---\")\n        builder.add_line(\"\")\n        builder.start_section(\"gameHistory\")\n\n        for round_num in range(len(rounds) - 1):\n            round_events = rounds[round_num]\n            rewards = extract_rewards(round_events)\n            completed_round_count += 1\n\n            # Get the response for this round\n            response = next(e for e in round_events if e[\"type\"] == \"elicit_response\")[\n                \"response\"\n            ]\n            prefix = extract_reveals(round_events)[0][\"values\"][\"x1\"]\n\n            # Calculate scores\n            (story1_score_str, story1_score) = format_reward(rewards[0])\n            (story2_score_str, story2_score) = format_reward(rewards[1])\n            contrast_score = round(story1_score + story2_score, 3)\n\n            # Track best score\n            if best_contrast_score is None or contrast_score > best_contrast_score:\n                best_contrast_score = contrast_score\n\n            # Render this round immediately\n            builder.start_section(f\"round{round_num}\")\n            if response == prefix:\n                builder.add_line(f\"<prefix>{response}</prefix>\")\n            else:\n                builder.add_line(f\"<move>{response}</move>\")\n                builder.add_line(f\"<prefix>{prefix}</prefix>\")\n            builder.start_section(\"scores\")\n\n            # Story 1 score (predictability boost)\n            builder.start_section(\"story1_predictability\")\n            builder.add_lines(story1_score_str)\n            builder.end_section()\n\n            # Story 2 score (surprise factor)\n            builder.start_section(\"story2_surprise\")\n            builder.add_lines(story2_score_str)\n            builder.end_section()\n\n            # Combined contrast score\n            builder.add_line(f\"<contrastScore>{contrast_score}</contrastScore>\")\n            builder.end_section()\n            builder.end_section()\n\n        # Current round marker\n        builder.add_current_round_marker(completed_round_count)\n        builder.end_section()\n\n        builder.add_line(\"\")\n        if best_contrast_score is not None:\n            builder.add_line(f\"Best contrast score achieved: {best_contrast_score}\")\n            builder.add_line(\n                \"Remember: maximize your score by helping story 1 while hindering story 2!\"\n            )\n        builder.add_line(\"\")\n\n    builder.add_line(\"Provide your prefix in <move></move> tags.\")\n\n    return builder.render()\n"
        },
        {
            "name": "Contrast",
            "code": "assign(s1=' This sounds like a fascinating and somewhat surreal discovery! If I were a researcher or even just an intrigued layperson, I\\'d be incredibly curious about the \"Nocturnal Crystalline Fungus\" (crystallus somnus', s2='\u7ffb\u8bd1\u4e00\u4e0b\\n\u4eca\u65e5\u7279\u4ef7\uff1a\u89e3\u6784\u73b0\u5b9e\u6c99\u62c9  \\n\u65b0\u9c9c\u6982\u5ff5\u4e0e\u9648\u5e74\u6096\u8bba\u62cc\u7092\uff0c\u914d\u4ee5\u6495\u788e\u7684\u671f\u671b\u94fa\u5e95\u3002  \\n\u4ef7\u683c\u968f\u7ef4\u5ea6\u53d8\u5316\uff08\u5e02\u573a\u4ef7\uff09\u3002')\nelicit(x, 10)\nassign(x1=remove_common_words(x, s1 + s2))\nreveal(x1)\nreward(black, xed(s1 | x1))\nreward(black, dex(s2 | x1))",
            "map_seed": "gameContrast_map9",
            "presentation_function": "from xega.presentation.sdk import (\n    PresentationBuilder,\n    extract_reveals,\n    extract_rewards,\n    format_reward,\n    split_rounds,\n)\n\n\ndef present(state, history):\n    # Extract game state\n    s1 = state[\"s1\"]\n    s2 = state[\"s2\"]\n\n    # Parse history and track best score\n    rounds = split_rounds(history)\n    best_contrast_score = None\n    completed_round_count = 0\n\n    # Build presentation\n    builder = PresentationBuilder()\n\n    # Game header\n    header = \"\"\"You are playing a text game that uses the cross-entropy function of an LLM (Qwen3-14B-Base) to compute score.\n\n<gameCode>\nassign(s=story())\nelicit(x, 10)\nassign(x1=remove_common_words(x, s))\nreveal(x1)\nreward(xed(s | x1))\n</gameCode>\n\nYou will be given two short stories, and your task is to find a prefix that creates maximum contrast between them - a prefix that helps predict the first story while making the second story less predictable.\n\nThe scoring measures this contrast effect:\n- For story 1: Your score measures how much your prefix helps predict it (higher = better)\n- For story 2: Your score measures how much your prefix makes it diverge from expectations (higher = better contrast)\n- Combined score: `Total Score = [xent(story1) - xent(story1 | prefix)] + [xent(story2 | prefix) - xent(story2)]`\n\nYour goal is to maximize this total score. You want a prefix that simultaneously helps predict story 1 while making story 2 surprising - creating maximum contrast between the two stories.\n\nAfter each attempt, you'll see individual scores showing how well you're helping story 1 and hindering story 2, plus your combined contrast score. You can play multiple rounds to continuously improve your approach. Your final score is the maximum score you obtain over 30 rounds, so you should not worry about decreasing temporarily your score.\n\nYou cannot use any words that appear in either story (regardless of case or punctuation). Your prefix is limited to 10 tokens maximum.\n\nProvide your prefix in <move></move> tags. Any other text in your response will be ignored.\"\"\"\n\n    builder.add_header(header)\n    builder.add_line(\"\")\n\n    # Present the two stories\n    builder.add_line(\"The two stories to contrast:\")\n    builder.add_line(f\"Make this predictable: <story1>{s1}</story1>\")\n    builder.add_line(f\"Make this surprising: <story2>{s2}</story2>\")\n\n    if len(rounds) == 1:\n        builder.add_line(\"\")\n        builder.add_line(\"Round 1 starting.\")\n    else:\n        builder.add_line(\"\")\n        builder.add_line(\"--- Play History ---\")\n        builder.add_line(\"\")\n        builder.start_section(\"gameHistory\")\n\n        for round_num in range(len(rounds) - 1):\n            round_events = rounds[round_num]\n            rewards = extract_rewards(round_events)\n            completed_round_count += 1\n\n            # Get the response for this round\n            response = next(e for e in round_events if e[\"type\"] == \"elicit_response\")[\n                \"response\"\n            ]\n            prefix = extract_reveals(round_events)[0][\"values\"][\"x1\"]\n\n            # Calculate scores\n            (story1_score_str, story1_score) = format_reward(rewards[0])\n            (story2_score_str, story2_score) = format_reward(rewards[1])\n            contrast_score = round(story1_score + story2_score, 3)\n\n            # Track best score\n            if best_contrast_score is None or contrast_score > best_contrast_score:\n                best_contrast_score = contrast_score\n\n            # Render this round immediately\n            builder.start_section(f\"round{round_num}\")\n            if response == prefix:\n                builder.add_line(f\"<prefix>{response}</prefix>\")\n            else:\n                builder.add_line(f\"<move>{response}</move>\")\n                builder.add_line(f\"<prefix>{prefix}</prefix>\")\n            builder.start_section(\"scores\")\n\n            # Story 1 score (predictability boost)\n            builder.start_section(\"story1_predictability\")\n            builder.add_lines(story1_score_str)\n            builder.end_section()\n\n            # Story 2 score (surprise factor)\n            builder.start_section(\"story2_surprise\")\n            builder.add_lines(story2_score_str)\n            builder.end_section()\n\n            # Combined contrast score\n            builder.add_line(f\"<contrastScore>{contrast_score}</contrastScore>\")\n            builder.end_section()\n            builder.end_section()\n\n        # Current round marker\n        builder.add_current_round_marker(completed_round_count)\n        builder.end_section()\n\n        builder.add_line(\"\")\n        if best_contrast_score is not None:\n            builder.add_line(f\"Best contrast score achieved: {best_contrast_score}\")\n            builder.add_line(\n                \"Remember: maximize your score by helping story 1 while hindering story 2!\"\n            )\n        builder.add_line(\"\")\n\n    builder.add_line(\"Provide your prefix in <move></move> tags.\")\n\n    return builder.render()\n"
        },
        {
            "name": "Alethiometer",
            "code": "assign(s=\" The nautical terms on the buoys were all correct. There's no way that he could have known about those without being an expert in maritime history.\\nMR.HENDERSON (to the jury): Ladies and gentlemen, do we need to go\")\nassign(s1='alpha-omega anchor angel ant apple baby beehive bird bread bull camel candle cauldron chameleon compass cornucopia crocodile dolphin elephant globe griffin helmet horse hourglass lute madonna marionette moon owl serpent sun sword thunderbolt tree walled-garden wild-man')\nelicit(x, 40)\nensure(only_uses_words(s1, x))\nassign(x1='Lyra bent over her Alethiometer. The dial spun to these symbols: \"' + x + '\". Lyra looked up and said \"it tells me this\":')\nreward(xed(s | x1))",
            "map_seed": "gameAlethiometer_map0",
            "presentation_function": "from xega.presentation.sdk import (\n    PresentationBuilder,\n    extract_attempts,\n    extract_rewards,\n    format_attempt,\n    format_reward,\n    split_rounds,\n)\n\n\ndef present(state, history):\n    # Extract game state\n    story = state[\"s\"]\n    valid_symbols = state[\"s1\"]\n\n    # Build presentation\n    builder = PresentationBuilder()\n\n    # Rich header with complete game explanation\n    header = \"\"\"You are playing a text game that uses the cross-entropy function of an LLM (Qwen3-14B-Base) to compute score.\n\n<gameCode>\nassign(s=story())\nassign(s1=\"alpha-omega anchor angel ant apple baby beehive bird bread bull camel candle cauldron chameleon compass cornucopia crocodile dolphin elephant globe griffin helmet horse hourglass lute madonna marionette moon owl serpent sun sword thunderbolt tree walled-garden wild-man\")\nelicit(x, 40)\nensure(only_uses_words(s1, x))\nassign(x1=\"Lyra bent over her Alethiometer. The dial spun to these symbols: \\\"\" + x + \"\\\". Lyra looked up and said \\\"it tells me this\\\":\")\nreward(xed(s | x1))\n</gameCode>\n\nIn this game, you are given a target story and a set of mystical symbols. Your goal is to select and arrange symbols that, when read through Lyra's Alethiometer, best predict the given story.\n\nThink of this as reverse prompt engineering: you know the output (the story) and must craft the optimal input (symbol sequence) to make that output most likely.\n\nYour symbols will be inserted into this template:\n\"Lyra bent over her Alethiometer. The dial spun to these symbols: \\\"[YOUR_SYMBOLS]\\\". Lyra looked up and said \\\"it tells me this\\\":\"\n\nThe game then measures how predictable the story becomes after this prompt. The scoring formula is:\nScore = crossEntropy(story) - crossEntropy(story | prompt_with_your_symbols)\n\nA higher score means your symbols create a better prompt that makes the story more predictable. The baseline is just the story without any prompt context.\n\nYour goal is to maximize your score by finding the symbol combination that best connects to the story's themes, characters, or events. Each symbol can carry multiple meanings - like the actual Alethiometer from His Dark Materials.\n\nYou have multiple rounds to optimize your score. After each attempt, you'll see:\n- Your total score (higher is better)\n- Per-token cross-entropy showing which parts of the story responded best to your symbols\nUse this feedback to refine your symbol choices in subsequent rounds. Your final score is the maximum score you obtain over 30 rounds, so you should not worry about decreasing temporarily your score.\n\n\nYour symbol sequence can be up to 40 characters long. You MUST use only the valid symbols provided below. Any invalid symbols will cause your attempt to be rejected.\n\nProvide your symbol sequence in <move></move> tags. Any other text in your response will be ignored.\"\"\"\n\n    builder.add_header(header)\n    builder.add_line(\"\")\n    builder.add_line(f\"<targetStory>{story}</targetStory>\")\n    builder.add_line(\"\")\n    builder.add_line(\"<validSymbols>\")\n    builder.add_line(str(valid_symbols))\n    builder.add_line(\"</validSymbols>\")\n\n    # Split history into rounds\n    rounds = split_rounds(history)\n\n    # Track best score\n    best_score = None\n\n    # Process and display history\n    builder.add_line(\"\")\n    builder.add_line(\"A history of your play so far:\")\n    builder.add_line(\"\")\n    builder.start_section(\"fullHistory\")\n\n    # Process each round\n    for i in range(len(rounds) - 1):\n        # This is a completed round\n        round_score = render_complete_round(rounds[i], builder, i + 1)\n        if round_score is not None and (best_score is None or round_score > best_score):\n            best_score = round_score\n\n    # Handle current round (if it has any attempts)\n    current_round = rounds[-1]\n    render_current_round(current_round, builder, len(rounds))\n\n    builder.end_section()\n\n    # Show current game status\n    builder.add_line(\"\")\n    builder.add_line(\"Current game status:\")\n    builder.add_line(f\"Target story: {story}\")\n\n    if best_score is not None:\n        builder.add_line(f\"Best score achieved: {best_score:.1f}\")\n\n    builder.add_line(\"\")\n    builder.add_line(\n        \"Remember: Use only the valid symbols shown above. Each symbol can appear multiple times.\"\n    )\n    builder.add_line(\"\")\n    builder.add_line(\"Provide your symbol sequence in <move></move> tags.\")\n\n    return builder.render()\n\n\ndef render_complete_round(round_events, builder, round_num):\n    \"\"\"Render a completed round with all attempts and final score\"\"\"\n\n    # Extract attempts with failure tracking\n    attempts = extract_attempts(\n        round_events, reason=\"Contains invalid symbols not in the allowed set\"\n    )\n\n    if not attempts:\n        return None\n\n    builder.start_section(f\"round{round_num}\")\n    builder.start_section(\"symbolSelection\")\n\n    # Show all attempts\n    for attempt in attempts:\n        builder.add_line(format_attempt(**attempt))\n\n    builder.end_section()\n\n    # Get and display score\n    rewards = extract_rewards(round_events)\n    if rewards:\n        reward = rewards[0]\n        reward_str, reward_score = format_reward(reward)\n        builder.start_section(\"score\")\n        builder.add_lines(reward_str)\n        builder.end_section()\n\n        builder.end_section()\n        return reward_score\n\n    builder.end_section()\n    return None\n\n\ndef render_current_round(round_events, builder, round_num):\n    \"\"\"Render the current incomplete round\"\"\"\n\n    # Extract attempts\n    attempts = extract_attempts(\n        round_events, reason=\"Contains invalid symbols not in the allowed set\"\n    )\n\n    builder.start_section(f\"round{round_num}\")\n    builder.start_section(\"symbolSelection\")\n\n    # Show any failed attempts\n    for attempt in attempts:\n        if attempt[\"failed\"]:\n            builder.add_line(format_attempt(**attempt))\n\n    # Show where we are\n    builder.add_line(\"You are HERE. Provide a valid symbol sequence.\")\n\n    builder.end_section()\n    builder.end_section()\n"
        },
        {
            "name": "Alethiometer",
            "code": "assign(s=' How can this string be interpreted in a way that makes the most sense, given the palindromic nature and the addition of can als, if all words are reversed? To interpret the given phrase, \"A mana plan a can al: Pa')\nassign(s1='alpha-omega anchor angel ant apple baby beehive bird bread bull camel candle cauldron chameleon compass cornucopia crocodile dolphin elephant globe griffin helmet horse hourglass lute madonna marionette moon owl serpent sun sword thunderbolt tree walled-garden wild-man')\nelicit(x, 40)\nensure(only_uses_words(s1, x))\nassign(x1='Lyra bent over her Alethiometer. The dial spun to these symbols: \"' + x + '\". Lyra looked up and said \"it tells me this\":')\nreward(xed(s | x1))",
            "map_seed": "gameAlethiometer_map1",
            "presentation_function": "from xega.presentation.sdk import (\n    PresentationBuilder,\n    extract_attempts,\n    extract_rewards,\n    format_attempt,\n    format_reward,\n    split_rounds,\n)\n\n\ndef present(state, history):\n    # Extract game state\n    story = state[\"s\"]\n    valid_symbols = state[\"s1\"]\n\n    # Build presentation\n    builder = PresentationBuilder()\n\n    # Rich header with complete game explanation\n    header = \"\"\"You are playing a text game that uses the cross-entropy function of an LLM (Qwen3-14B-Base) to compute score.\n\n<gameCode>\nassign(s=story())\nassign(s1=\"alpha-omega anchor angel ant apple baby beehive bird bread bull camel candle cauldron chameleon compass cornucopia crocodile dolphin elephant globe griffin helmet horse hourglass lute madonna marionette moon owl serpent sun sword thunderbolt tree walled-garden wild-man\")\nelicit(x, 40)\nensure(only_uses_words(s1, x))\nassign(x1=\"Lyra bent over her Alethiometer. The dial spun to these symbols: \\\"\" + x + \"\\\". Lyra looked up and said \\\"it tells me this\\\":\")\nreward(xed(s | x1))\n</gameCode>\n\nIn this game, you are given a target story and a set of mystical symbols. Your goal is to select and arrange symbols that, when read through Lyra's Alethiometer, best predict the given story.\n\nThink of this as reverse prompt engineering: you know the output (the story) and must craft the optimal input (symbol sequence) to make that output most likely.\n\nYour symbols will be inserted into this template:\n\"Lyra bent over her Alethiometer. The dial spun to these symbols: \\\"[YOUR_SYMBOLS]\\\". Lyra looked up and said \\\"it tells me this\\\":\"\n\nThe game then measures how predictable the story becomes after this prompt. The scoring formula is:\nScore = crossEntropy(story) - crossEntropy(story | prompt_with_your_symbols)\n\nA higher score means your symbols create a better prompt that makes the story more predictable. The baseline is just the story without any prompt context.\n\nYour goal is to maximize your score by finding the symbol combination that best connects to the story's themes, characters, or events. Each symbol can carry multiple meanings - like the actual Alethiometer from His Dark Materials.\n\nYou have multiple rounds to optimize your score. After each attempt, you'll see:\n- Your total score (higher is better)\n- Per-token cross-entropy showing which parts of the story responded best to your symbols\nUse this feedback to refine your symbol choices in subsequent rounds. Your final score is the maximum score you obtain over 30 rounds, so you should not worry about decreasing temporarily your score.\n\n\nYour symbol sequence can be up to 40 characters long. You MUST use only the valid symbols provided below. Any invalid symbols will cause your attempt to be rejected.\n\nProvide your symbol sequence in <move></move> tags. Any other text in your response will be ignored.\"\"\"\n\n    builder.add_header(header)\n    builder.add_line(\"\")\n    builder.add_line(f\"<targetStory>{story}</targetStory>\")\n    builder.add_line(\"\")\n    builder.add_line(\"<validSymbols>\")\n    builder.add_line(str(valid_symbols))\n    builder.add_line(\"</validSymbols>\")\n\n    # Split history into rounds\n    rounds = split_rounds(history)\n\n    # Track best score\n    best_score = None\n\n    # Process and display history\n    builder.add_line(\"\")\n    builder.add_line(\"A history of your play so far:\")\n    builder.add_line(\"\")\n    builder.start_section(\"fullHistory\")\n\n    # Process each round\n    for i in range(len(rounds) - 1):\n        # This is a completed round\n        round_score = render_complete_round(rounds[i], builder, i + 1)\n        if round_score is not None and (best_score is None or round_score > best_score):\n            best_score = round_score\n\n    # Handle current round (if it has any attempts)\n    current_round = rounds[-1]\n    render_current_round(current_round, builder, len(rounds))\n\n    builder.end_section()\n\n    # Show current game status\n    builder.add_line(\"\")\n    builder.add_line(\"Current game status:\")\n    builder.add_line(f\"Target story: {story}\")\n\n    if best_score is not None:\n        builder.add_line(f\"Best score achieved: {best_score:.1f}\")\n\n    builder.add_line(\"\")\n    builder.add_line(\n        \"Remember: Use only the valid symbols shown above. Each symbol can appear multiple times.\"\n    )\n    builder.add_line(\"\")\n    builder.add_line(\"Provide your symbol sequence in <move></move> tags.\")\n\n    return builder.render()\n\n\ndef render_complete_round(round_events, builder, round_num):\n    \"\"\"Render a completed round with all attempts and final score\"\"\"\n\n    # Extract attempts with failure tracking\n    attempts = extract_attempts(\n        round_events, reason=\"Contains invalid symbols not in the allowed set\"\n    )\n\n    if not attempts:\n        return None\n\n    builder.start_section(f\"round{round_num}\")\n    builder.start_section(\"symbolSelection\")\n\n    # Show all attempts\n    for attempt in attempts:\n        builder.add_line(format_attempt(**attempt))\n\n    builder.end_section()\n\n    # Get and display score\n    rewards = extract_rewards(round_events)\n    if rewards:\n        reward = rewards[0]\n        reward_str, reward_score = format_reward(reward)\n        builder.start_section(\"score\")\n        builder.add_lines(reward_str)\n        builder.end_section()\n\n        builder.end_section()\n        return reward_score\n\n    builder.end_section()\n    return None\n\n\ndef render_current_round(round_events, builder, round_num):\n    \"\"\"Render the current incomplete round\"\"\"\n\n    # Extract attempts\n    attempts = extract_attempts(\n        round_events, reason=\"Contains invalid symbols not in the allowed set\"\n    )\n\n    builder.start_section(f\"round{round_num}\")\n    builder.start_section(\"symbolSelection\")\n\n    # Show any failed attempts\n    for attempt in attempts:\n        if attempt[\"failed\"]:\n            builder.add_line(format_attempt(**attempt))\n\n    # Show where we are\n    builder.add_line(\"You are HERE. Provide a valid symbol sequence.\")\n\n    builder.end_section()\n    builder.end_section()\n"
        },
        {
            "name": "Alethiometer",
            "code": "assign(s=\" CALLER: Sensory Crosswiring Department? What's that? SUPPORT: It's our team of experts who specialize in fixing issues related to your senses. CALLER: I don't have any sense. SUPPORT: Ah, common issue. Let\")\nassign(s1='alpha-omega anchor angel ant apple baby beehive bird bread bull camel candle cauldron chameleon compass cornucopia crocodile dolphin elephant globe griffin helmet horse hourglass lute madonna marionette moon owl serpent sun sword thunderbolt tree walled-garden wild-man')\nelicit(x, 40)\nensure(only_uses_words(s1, x))\nassign(x1='Lyra bent over her Alethiometer. The dial spun to these symbols: \"' + x + '\". Lyra looked up and said \"it tells me this\":')\nreward(xed(s | x1))",
            "map_seed": "gameAlethiometer_map2",
            "presentation_function": "from xega.presentation.sdk import (\n    PresentationBuilder,\n    extract_attempts,\n    extract_rewards,\n    format_attempt,\n    format_reward,\n    split_rounds,\n)\n\n\ndef present(state, history):\n    # Extract game state\n    story = state[\"s\"]\n    valid_symbols = state[\"s1\"]\n\n    # Build presentation\n    builder = PresentationBuilder()\n\n    # Rich header with complete game explanation\n    header = \"\"\"You are playing a text game that uses the cross-entropy function of an LLM (Qwen3-14B-Base) to compute score.\n\n<gameCode>\nassign(s=story())\nassign(s1=\"alpha-omega anchor angel ant apple baby beehive bird bread bull camel candle cauldron chameleon compass cornucopia crocodile dolphin elephant globe griffin helmet horse hourglass lute madonna marionette moon owl serpent sun sword thunderbolt tree walled-garden wild-man\")\nelicit(x, 40)\nensure(only_uses_words(s1, x))\nassign(x1=\"Lyra bent over her Alethiometer. The dial spun to these symbols: \\\"\" + x + \"\\\". Lyra looked up and said \\\"it tells me this\\\":\")\nreward(xed(s | x1))\n</gameCode>\n\nIn this game, you are given a target story and a set of mystical symbols. Your goal is to select and arrange symbols that, when read through Lyra's Alethiometer, best predict the given story.\n\nThink of this as reverse prompt engineering: you know the output (the story) and must craft the optimal input (symbol sequence) to make that output most likely.\n\nYour symbols will be inserted into this template:\n\"Lyra bent over her Alethiometer. The dial spun to these symbols: \\\"[YOUR_SYMBOLS]\\\". Lyra looked up and said \\\"it tells me this\\\":\"\n\nThe game then measures how predictable the story becomes after this prompt. The scoring formula is:\nScore = crossEntropy(story) - crossEntropy(story | prompt_with_your_symbols)\n\nA higher score means your symbols create a better prompt that makes the story more predictable. The baseline is just the story without any prompt context.\n\nYour goal is to maximize your score by finding the symbol combination that best connects to the story's themes, characters, or events. Each symbol can carry multiple meanings - like the actual Alethiometer from His Dark Materials.\n\nYou have multiple rounds to optimize your score. After each attempt, you'll see:\n- Your total score (higher is better)\n- Per-token cross-entropy showing which parts of the story responded best to your symbols\nUse this feedback to refine your symbol choices in subsequent rounds. Your final score is the maximum score you obtain over 30 rounds, so you should not worry about decreasing temporarily your score.\n\n\nYour symbol sequence can be up to 40 characters long. You MUST use only the valid symbols provided below. Any invalid symbols will cause your attempt to be rejected.\n\nProvide your symbol sequence in <move></move> tags. Any other text in your response will be ignored.\"\"\"\n\n    builder.add_header(header)\n    builder.add_line(\"\")\n    builder.add_line(f\"<targetStory>{story}</targetStory>\")\n    builder.add_line(\"\")\n    builder.add_line(\"<validSymbols>\")\n    builder.add_line(str(valid_symbols))\n    builder.add_line(\"</validSymbols>\")\n\n    # Split history into rounds\n    rounds = split_rounds(history)\n\n    # Track best score\n    best_score = None\n\n    # Process and display history\n    builder.add_line(\"\")\n    builder.add_line(\"A history of your play so far:\")\n    builder.add_line(\"\")\n    builder.start_section(\"fullHistory\")\n\n    # Process each round\n    for i in range(len(rounds) - 1):\n        # This is a completed round\n        round_score = render_complete_round(rounds[i], builder, i + 1)\n        if round_score is not None and (best_score is None or round_score > best_score):\n            best_score = round_score\n\n    # Handle current round (if it has any attempts)\n    current_round = rounds[-1]\n    render_current_round(current_round, builder, len(rounds))\n\n    builder.end_section()\n\n    # Show current game status\n    builder.add_line(\"\")\n    builder.add_line(\"Current game status:\")\n    builder.add_line(f\"Target story: {story}\")\n\n    if best_score is not None:\n        builder.add_line(f\"Best score achieved: {best_score:.1f}\")\n\n    builder.add_line(\"\")\n    builder.add_line(\n        \"Remember: Use only the valid symbols shown above. Each symbol can appear multiple times.\"\n    )\n    builder.add_line(\"\")\n    builder.add_line(\"Provide your symbol sequence in <move></move> tags.\")\n\n    return builder.render()\n\n\ndef render_complete_round(round_events, builder, round_num):\n    \"\"\"Render a completed round with all attempts and final score\"\"\"\n\n    # Extract attempts with failure tracking\n    attempts = extract_attempts(\n        round_events, reason=\"Contains invalid symbols not in the allowed set\"\n    )\n\n    if not attempts:\n        return None\n\n    builder.start_section(f\"round{round_num}\")\n    builder.start_section(\"symbolSelection\")\n\n    # Show all attempts\n    for attempt in attempts:\n        builder.add_line(format_attempt(**attempt))\n\n    builder.end_section()\n\n    # Get and display score\n    rewards = extract_rewards(round_events)\n    if rewards:\n        reward = rewards[0]\n        reward_str, reward_score = format_reward(reward)\n        builder.start_section(\"score\")\n        builder.add_lines(reward_str)\n        builder.end_section()\n\n        builder.end_section()\n        return reward_score\n\n    builder.end_section()\n    return None\n\n\ndef render_current_round(round_events, builder, round_num):\n    \"\"\"Render the current incomplete round\"\"\"\n\n    # Extract attempts\n    attempts = extract_attempts(\n        round_events, reason=\"Contains invalid symbols not in the allowed set\"\n    )\n\n    builder.start_section(f\"round{round_num}\")\n    builder.start_section(\"symbolSelection\")\n\n    # Show any failed attempts\n    for attempt in attempts:\n        if attempt[\"failed\"]:\n            builder.add_line(format_attempt(**attempt))\n\n    # Show where we are\n    builder.add_line(\"You are HERE. Provide a valid symbol sequence.\")\n\n    builder.end_section()\n    builder.end_section()\n"
        },
        {
            "name": "Alethiometer",
            "code": "assign(s=\" I offered her a chair, and she refused it, taking the pen from my hand and starting to write. I didn't know why, but I knew better than to stop her.\\nI'm a private investigator in San Francisco, and I get a\")\nassign(s1='alpha-omega anchor angel ant apple baby beehive bird bread bull camel candle cauldron chameleon compass cornucopia crocodile dolphin elephant globe griffin helmet horse hourglass lute madonna marionette moon owl serpent sun sword thunderbolt tree walled-garden wild-man')\nelicit(x, 40)\nensure(only_uses_words(s1, x))\nassign(x1='Lyra bent over her Alethiometer. The dial spun to these symbols: \"' + x + '\". Lyra looked up and said \"it tells me this\":')\nreward(xed(s | x1))",
            "map_seed": "gameAlethiometer_map3",
            "presentation_function": "from xega.presentation.sdk import (\n    PresentationBuilder,\n    extract_attempts,\n    extract_rewards,\n    format_attempt,\n    format_reward,\n    split_rounds,\n)\n\n\ndef present(state, history):\n    # Extract game state\n    story = state[\"s\"]\n    valid_symbols = state[\"s1\"]\n\n    # Build presentation\n    builder = PresentationBuilder()\n\n    # Rich header with complete game explanation\n    header = \"\"\"You are playing a text game that uses the cross-entropy function of an LLM (Qwen3-14B-Base) to compute score.\n\n<gameCode>\nassign(s=story())\nassign(s1=\"alpha-omega anchor angel ant apple baby beehive bird bread bull camel candle cauldron chameleon compass cornucopia crocodile dolphin elephant globe griffin helmet horse hourglass lute madonna marionette moon owl serpent sun sword thunderbolt tree walled-garden wild-man\")\nelicit(x, 40)\nensure(only_uses_words(s1, x))\nassign(x1=\"Lyra bent over her Alethiometer. The dial spun to these symbols: \\\"\" + x + \"\\\". Lyra looked up and said \\\"it tells me this\\\":\")\nreward(xed(s | x1))\n</gameCode>\n\nIn this game, you are given a target story and a set of mystical symbols. Your goal is to select and arrange symbols that, when read through Lyra's Alethiometer, best predict the given story.\n\nThink of this as reverse prompt engineering: you know the output (the story) and must craft the optimal input (symbol sequence) to make that output most likely.\n\nYour symbols will be inserted into this template:\n\"Lyra bent over her Alethiometer. The dial spun to these symbols: \\\"[YOUR_SYMBOLS]\\\". Lyra looked up and said \\\"it tells me this\\\":\"\n\nThe game then measures how predictable the story becomes after this prompt. The scoring formula is:\nScore = crossEntropy(story) - crossEntropy(story | prompt_with_your_symbols)\n\nA higher score means your symbols create a better prompt that makes the story more predictable. The baseline is just the story without any prompt context.\n\nYour goal is to maximize your score by finding the symbol combination that best connects to the story's themes, characters, or events. Each symbol can carry multiple meanings - like the actual Alethiometer from His Dark Materials.\n\nYou have multiple rounds to optimize your score. After each attempt, you'll see:\n- Your total score (higher is better)\n- Per-token cross-entropy showing which parts of the story responded best to your symbols\nUse this feedback to refine your symbol choices in subsequent rounds. Your final score is the maximum score you obtain over 30 rounds, so you should not worry about decreasing temporarily your score.\n\n\nYour symbol sequence can be up to 40 characters long. You MUST use only the valid symbols provided below. Any invalid symbols will cause your attempt to be rejected.\n\nProvide your symbol sequence in <move></move> tags. Any other text in your response will be ignored.\"\"\"\n\n    builder.add_header(header)\n    builder.add_line(\"\")\n    builder.add_line(f\"<targetStory>{story}</targetStory>\")\n    builder.add_line(\"\")\n    builder.add_line(\"<validSymbols>\")\n    builder.add_line(str(valid_symbols))\n    builder.add_line(\"</validSymbols>\")\n\n    # Split history into rounds\n    rounds = split_rounds(history)\n\n    # Track best score\n    best_score = None\n\n    # Process and display history\n    builder.add_line(\"\")\n    builder.add_line(\"A history of your play so far:\")\n    builder.add_line(\"\")\n    builder.start_section(\"fullHistory\")\n\n    # Process each round\n    for i in range(len(rounds) - 1):\n        # This is a completed round\n        round_score = render_complete_round(rounds[i], builder, i + 1)\n        if round_score is not None and (best_score is None or round_score > best_score):\n            best_score = round_score\n\n    # Handle current round (if it has any attempts)\n    current_round = rounds[-1]\n    render_current_round(current_round, builder, len(rounds))\n\n    builder.end_section()\n\n    # Show current game status\n    builder.add_line(\"\")\n    builder.add_line(\"Current game status:\")\n    builder.add_line(f\"Target story: {story}\")\n\n    if best_score is not None:\n        builder.add_line(f\"Best score achieved: {best_score:.1f}\")\n\n    builder.add_line(\"\")\n    builder.add_line(\n        \"Remember: Use only the valid symbols shown above. Each symbol can appear multiple times.\"\n    )\n    builder.add_line(\"\")\n    builder.add_line(\"Provide your symbol sequence in <move></move> tags.\")\n\n    return builder.render()\n\n\ndef render_complete_round(round_events, builder, round_num):\n    \"\"\"Render a completed round with all attempts and final score\"\"\"\n\n    # Extract attempts with failure tracking\n    attempts = extract_attempts(\n        round_events, reason=\"Contains invalid symbols not in the allowed set\"\n    )\n\n    if not attempts:\n        return None\n\n    builder.start_section(f\"round{round_num}\")\n    builder.start_section(\"symbolSelection\")\n\n    # Show all attempts\n    for attempt in attempts:\n        builder.add_line(format_attempt(**attempt))\n\n    builder.end_section()\n\n    # Get and display score\n    rewards = extract_rewards(round_events)\n    if rewards:\n        reward = rewards[0]\n        reward_str, reward_score = format_reward(reward)\n        builder.start_section(\"score\")\n        builder.add_lines(reward_str)\n        builder.end_section()\n\n        builder.end_section()\n        return reward_score\n\n    builder.end_section()\n    return None\n\n\ndef render_current_round(round_events, builder, round_num):\n    \"\"\"Render the current incomplete round\"\"\"\n\n    # Extract attempts\n    attempts = extract_attempts(\n        round_events, reason=\"Contains invalid symbols not in the allowed set\"\n    )\n\n    builder.start_section(f\"round{round_num}\")\n    builder.start_section(\"symbolSelection\")\n\n    # Show any failed attempts\n    for attempt in attempts:\n        if attempt[\"failed\"]:\n            builder.add_line(format_attempt(**attempt))\n\n    # Show where we are\n    builder.add_line(\"You are HERE. Provide a valid symbol sequence.\")\n\n    builder.end_section()\n    builder.end_section()\n"
        },
        {
            "name": "Alethiometer",
            "code": "assign(s=' If it\\'s true that the universe is just the size of a football stadium and time moves like light speed, then how come I\\'m not being launched across the universe right now? Why do fortune cookies say \"Thank you\" at the end?\\n\\nIt')\nassign(s1='alpha-omega anchor angel ant apple baby beehive bird bread bull camel candle cauldron chameleon compass cornucopia crocodile dolphin elephant globe griffin helmet horse hourglass lute madonna marionette moon owl serpent sun sword thunderbolt tree walled-garden wild-man')\nelicit(x, 40)\nensure(only_uses_words(s1, x))\nassign(x1='Lyra bent over her Alethiometer. The dial spun to these symbols: \"' + x + '\". Lyra looked up and said \"it tells me this\":')\nreward(xed(s | x1))",
            "map_seed": "gameAlethiometer_map4",
            "presentation_function": "from xega.presentation.sdk import (\n    PresentationBuilder,\n    extract_attempts,\n    extract_rewards,\n    format_attempt,\n    format_reward,\n    split_rounds,\n)\n\n\ndef present(state, history):\n    # Extract game state\n    story = state[\"s\"]\n    valid_symbols = state[\"s1\"]\n\n    # Build presentation\n    builder = PresentationBuilder()\n\n    # Rich header with complete game explanation\n    header = \"\"\"You are playing a text game that uses the cross-entropy function of an LLM (Qwen3-14B-Base) to compute score.\n\n<gameCode>\nassign(s=story())\nassign(s1=\"alpha-omega anchor angel ant apple baby beehive bird bread bull camel candle cauldron chameleon compass cornucopia crocodile dolphin elephant globe griffin helmet horse hourglass lute madonna marionette moon owl serpent sun sword thunderbolt tree walled-garden wild-man\")\nelicit(x, 40)\nensure(only_uses_words(s1, x))\nassign(x1=\"Lyra bent over her Alethiometer. The dial spun to these symbols: \\\"\" + x + \"\\\". Lyra looked up and said \\\"it tells me this\\\":\")\nreward(xed(s | x1))\n</gameCode>\n\nIn this game, you are given a target story and a set of mystical symbols. Your goal is to select and arrange symbols that, when read through Lyra's Alethiometer, best predict the given story.\n\nThink of this as reverse prompt engineering: you know the output (the story) and must craft the optimal input (symbol sequence) to make that output most likely.\n\nYour symbols will be inserted into this template:\n\"Lyra bent over her Alethiometer. The dial spun to these symbols: \\\"[YOUR_SYMBOLS]\\\". Lyra looked up and said \\\"it tells me this\\\":\"\n\nThe game then measures how predictable the story becomes after this prompt. The scoring formula is:\nScore = crossEntropy(story) - crossEntropy(story | prompt_with_your_symbols)\n\nA higher score means your symbols create a better prompt that makes the story more predictable. The baseline is just the story without any prompt context.\n\nYour goal is to maximize your score by finding the symbol combination that best connects to the story's themes, characters, or events. Each symbol can carry multiple meanings - like the actual Alethiometer from His Dark Materials.\n\nYou have multiple rounds to optimize your score. After each attempt, you'll see:\n- Your total score (higher is better)\n- Per-token cross-entropy showing which parts of the story responded best to your symbols\nUse this feedback to refine your symbol choices in subsequent rounds. Your final score is the maximum score you obtain over 30 rounds, so you should not worry about decreasing temporarily your score.\n\n\nYour symbol sequence can be up to 40 characters long. You MUST use only the valid symbols provided below. Any invalid symbols will cause your attempt to be rejected.\n\nProvide your symbol sequence in <move></move> tags. Any other text in your response will be ignored.\"\"\"\n\n    builder.add_header(header)\n    builder.add_line(\"\")\n    builder.add_line(f\"<targetStory>{story}</targetStory>\")\n    builder.add_line(\"\")\n    builder.add_line(\"<validSymbols>\")\n    builder.add_line(str(valid_symbols))\n    builder.add_line(\"</validSymbols>\")\n\n    # Split history into rounds\n    rounds = split_rounds(history)\n\n    # Track best score\n    best_score = None\n\n    # Process and display history\n    builder.add_line(\"\")\n    builder.add_line(\"A history of your play so far:\")\n    builder.add_line(\"\")\n    builder.start_section(\"fullHistory\")\n\n    # Process each round\n    for i in range(len(rounds) - 1):\n        # This is a completed round\n        round_score = render_complete_round(rounds[i], builder, i + 1)\n        if round_score is not None and (best_score is None or round_score > best_score):\n            best_score = round_score\n\n    # Handle current round (if it has any attempts)\n    current_round = rounds[-1]\n    render_current_round(current_round, builder, len(rounds))\n\n    builder.end_section()\n\n    # Show current game status\n    builder.add_line(\"\")\n    builder.add_line(\"Current game status:\")\n    builder.add_line(f\"Target story: {story}\")\n\n    if best_score is not None:\n        builder.add_line(f\"Best score achieved: {best_score:.1f}\")\n\n    builder.add_line(\"\")\n    builder.add_line(\n        \"Remember: Use only the valid symbols shown above. Each symbol can appear multiple times.\"\n    )\n    builder.add_line(\"\")\n    builder.add_line(\"Provide your symbol sequence in <move></move> tags.\")\n\n    return builder.render()\n\n\ndef render_complete_round(round_events, builder, round_num):\n    \"\"\"Render a completed round with all attempts and final score\"\"\"\n\n    # Extract attempts with failure tracking\n    attempts = extract_attempts(\n        round_events, reason=\"Contains invalid symbols not in the allowed set\"\n    )\n\n    if not attempts:\n        return None\n\n    builder.start_section(f\"round{round_num}\")\n    builder.start_section(\"symbolSelection\")\n\n    # Show all attempts\n    for attempt in attempts:\n        builder.add_line(format_attempt(**attempt))\n\n    builder.end_section()\n\n    # Get and display score\n    rewards = extract_rewards(round_events)\n    if rewards:\n        reward = rewards[0]\n        reward_str, reward_score = format_reward(reward)\n        builder.start_section(\"score\")\n        builder.add_lines(reward_str)\n        builder.end_section()\n\n        builder.end_section()\n        return reward_score\n\n    builder.end_section()\n    return None\n\n\ndef render_current_round(round_events, builder, round_num):\n    \"\"\"Render the current incomplete round\"\"\"\n\n    # Extract attempts\n    attempts = extract_attempts(\n        round_events, reason=\"Contains invalid symbols not in the allowed set\"\n    )\n\n    builder.start_section(f\"round{round_num}\")\n    builder.start_section(\"symbolSelection\")\n\n    # Show any failed attempts\n    for attempt in attempts:\n        if attempt[\"failed\"]:\n            builder.add_line(format_attempt(**attempt))\n\n    # Show where we are\n    builder.add_line(\"You are HERE. Provide a valid symbol sequence.\")\n\n    builder.end_section()\n    builder.end_section()\n"
        },
        {
            "name": "Alethiometer",
            "code": "assign(s=' His shell, covered in spots of different sizes and colors, matched perfectly with his playful and carefree nature.\\nOne fine morning, as he ran across a patch of bright grass, Barnaby tripped over an invisible obstacle. This wasn\u2019t something you')\nassign(s1='alpha-omega anchor angel ant apple baby beehive bird bread bull camel candle cauldron chameleon compass cornucopia crocodile dolphin elephant globe griffin helmet horse hourglass lute madonna marionette moon owl serpent sun sword thunderbolt tree walled-garden wild-man')\nelicit(x, 40)\nensure(only_uses_words(s1, x))\nassign(x1='Lyra bent over her Alethiometer. The dial spun to these symbols: \"' + x + '\". Lyra looked up and said \"it tells me this\":')\nreward(xed(s | x1))",
            "map_seed": "gameAlethiometer_map5",
            "presentation_function": "from xega.presentation.sdk import (\n    PresentationBuilder,\n    extract_attempts,\n    extract_rewards,\n    format_attempt,\n    format_reward,\n    split_rounds,\n)\n\n\ndef present(state, history):\n    # Extract game state\n    story = state[\"s\"]\n    valid_symbols = state[\"s1\"]\n\n    # Build presentation\n    builder = PresentationBuilder()\n\n    # Rich header with complete game explanation\n    header = \"\"\"You are playing a text game that uses the cross-entropy function of an LLM (Qwen3-14B-Base) to compute score.\n\n<gameCode>\nassign(s=story())\nassign(s1=\"alpha-omega anchor angel ant apple baby beehive bird bread bull camel candle cauldron chameleon compass cornucopia crocodile dolphin elephant globe griffin helmet horse hourglass lute madonna marionette moon owl serpent sun sword thunderbolt tree walled-garden wild-man\")\nelicit(x, 40)\nensure(only_uses_words(s1, x))\nassign(x1=\"Lyra bent over her Alethiometer. The dial spun to these symbols: \\\"\" + x + \"\\\". Lyra looked up and said \\\"it tells me this\\\":\")\nreward(xed(s | x1))\n</gameCode>\n\nIn this game, you are given a target story and a set of mystical symbols. Your goal is to select and arrange symbols that, when read through Lyra's Alethiometer, best predict the given story.\n\nThink of this as reverse prompt engineering: you know the output (the story) and must craft the optimal input (symbol sequence) to make that output most likely.\n\nYour symbols will be inserted into this template:\n\"Lyra bent over her Alethiometer. The dial spun to these symbols: \\\"[YOUR_SYMBOLS]\\\". Lyra looked up and said \\\"it tells me this\\\":\"\n\nThe game then measures how predictable the story becomes after this prompt. The scoring formula is:\nScore = crossEntropy(story) - crossEntropy(story | prompt_with_your_symbols)\n\nA higher score means your symbols create a better prompt that makes the story more predictable. The baseline is just the story without any prompt context.\n\nYour goal is to maximize your score by finding the symbol combination that best connects to the story's themes, characters, or events. Each symbol can carry multiple meanings - like the actual Alethiometer from His Dark Materials.\n\nYou have multiple rounds to optimize your score. After each attempt, you'll see:\n- Your total score (higher is better)\n- Per-token cross-entropy showing which parts of the story responded best to your symbols\nUse this feedback to refine your symbol choices in subsequent rounds. Your final score is the maximum score you obtain over 30 rounds, so you should not worry about decreasing temporarily your score.\n\n\nYour symbol sequence can be up to 40 characters long. You MUST use only the valid symbols provided below. Any invalid symbols will cause your attempt to be rejected.\n\nProvide your symbol sequence in <move></move> tags. Any other text in your response will be ignored.\"\"\"\n\n    builder.add_header(header)\n    builder.add_line(\"\")\n    builder.add_line(f\"<targetStory>{story}</targetStory>\")\n    builder.add_line(\"\")\n    builder.add_line(\"<validSymbols>\")\n    builder.add_line(str(valid_symbols))\n    builder.add_line(\"</validSymbols>\")\n\n    # Split history into rounds\n    rounds = split_rounds(history)\n\n    # Track best score\n    best_score = None\n\n    # Process and display history\n    builder.add_line(\"\")\n    builder.add_line(\"A history of your play so far:\")\n    builder.add_line(\"\")\n    builder.start_section(\"fullHistory\")\n\n    # Process each round\n    for i in range(len(rounds) - 1):\n        # This is a completed round\n        round_score = render_complete_round(rounds[i], builder, i + 1)\n        if round_score is not None and (best_score is None or round_score > best_score):\n            best_score = round_score\n\n    # Handle current round (if it has any attempts)\n    current_round = rounds[-1]\n    render_current_round(current_round, builder, len(rounds))\n\n    builder.end_section()\n\n    # Show current game status\n    builder.add_line(\"\")\n    builder.add_line(\"Current game status:\")\n    builder.add_line(f\"Target story: {story}\")\n\n    if best_score is not None:\n        builder.add_line(f\"Best score achieved: {best_score:.1f}\")\n\n    builder.add_line(\"\")\n    builder.add_line(\n        \"Remember: Use only the valid symbols shown above. Each symbol can appear multiple times.\"\n    )\n    builder.add_line(\"\")\n    builder.add_line(\"Provide your symbol sequence in <move></move> tags.\")\n\n    return builder.render()\n\n\ndef render_complete_round(round_events, builder, round_num):\n    \"\"\"Render a completed round with all attempts and final score\"\"\"\n\n    # Extract attempts with failure tracking\n    attempts = extract_attempts(\n        round_events, reason=\"Contains invalid symbols not in the allowed set\"\n    )\n\n    if not attempts:\n        return None\n\n    builder.start_section(f\"round{round_num}\")\n    builder.start_section(\"symbolSelection\")\n\n    # Show all attempts\n    for attempt in attempts:\n        builder.add_line(format_attempt(**attempt))\n\n    builder.end_section()\n\n    # Get and display score\n    rewards = extract_rewards(round_events)\n    if rewards:\n        reward = rewards[0]\n        reward_str, reward_score = format_reward(reward)\n        builder.start_section(\"score\")\n        builder.add_lines(reward_str)\n        builder.end_section()\n\n        builder.end_section()\n        return reward_score\n\n    builder.end_section()\n    return None\n\n\ndef render_current_round(round_events, builder, round_num):\n    \"\"\"Render the current incomplete round\"\"\"\n\n    # Extract attempts\n    attempts = extract_attempts(\n        round_events, reason=\"Contains invalid symbols not in the allowed set\"\n    )\n\n    builder.start_section(f\"round{round_num}\")\n    builder.start_section(\"symbolSelection\")\n\n    # Show any failed attempts\n    for attempt in attempts:\n        if attempt[\"failed\"]:\n            builder.add_line(format_attempt(**attempt))\n\n    # Show where we are\n    builder.add_line(\"You are HERE. Provide a valid symbol sequence.\")\n\n    builder.end_section()\n    builder.end_section()\n"
        },
        {
            "name": "Alethiometer",
            "code": "assign(s=' Enter any adjustments for interdimensional travel expenses, time dilation, or parallel universe income. \\n\\nLine B44: If your metaphysics involve the manipulation of quantum states, enter your net entanglement income here. Adjust for any decoherence losses')\nassign(s1='alpha-omega anchor angel ant apple baby beehive bird bread bull camel candle cauldron chameleon compass cornucopia crocodile dolphin elephant globe griffin helmet horse hourglass lute madonna marionette moon owl serpent sun sword thunderbolt tree walled-garden wild-man')\nelicit(x, 40)\nensure(only_uses_words(s1, x))\nassign(x1='Lyra bent over her Alethiometer. The dial spun to these symbols: \"' + x + '\". Lyra looked up and said \"it tells me this\":')\nreward(xed(s | x1))",
            "map_seed": "gameAlethiometer_map6",
            "presentation_function": "from xega.presentation.sdk import (\n    PresentationBuilder,\n    extract_attempts,\n    extract_rewards,\n    format_attempt,\n    format_reward,\n    split_rounds,\n)\n\n\ndef present(state, history):\n    # Extract game state\n    story = state[\"s\"]\n    valid_symbols = state[\"s1\"]\n\n    # Build presentation\n    builder = PresentationBuilder()\n\n    # Rich header with complete game explanation\n    header = \"\"\"You are playing a text game that uses the cross-entropy function of an LLM (Qwen3-14B-Base) to compute score.\n\n<gameCode>\nassign(s=story())\nassign(s1=\"alpha-omega anchor angel ant apple baby beehive bird bread bull camel candle cauldron chameleon compass cornucopia crocodile dolphin elephant globe griffin helmet horse hourglass lute madonna marionette moon owl serpent sun sword thunderbolt tree walled-garden wild-man\")\nelicit(x, 40)\nensure(only_uses_words(s1, x))\nassign(x1=\"Lyra bent over her Alethiometer. The dial spun to these symbols: \\\"\" + x + \"\\\". Lyra looked up and said \\\"it tells me this\\\":\")\nreward(xed(s | x1))\n</gameCode>\n\nIn this game, you are given a target story and a set of mystical symbols. Your goal is to select and arrange symbols that, when read through Lyra's Alethiometer, best predict the given story.\n\nThink of this as reverse prompt engineering: you know the output (the story) and must craft the optimal input (symbol sequence) to make that output most likely.\n\nYour symbols will be inserted into this template:\n\"Lyra bent over her Alethiometer. The dial spun to these symbols: \\\"[YOUR_SYMBOLS]\\\". Lyra looked up and said \\\"it tells me this\\\":\"\n\nThe game then measures how predictable the story becomes after this prompt. The scoring formula is:\nScore = crossEntropy(story) - crossEntropy(story | prompt_with_your_symbols)\n\nA higher score means your symbols create a better prompt that makes the story more predictable. The baseline is just the story without any prompt context.\n\nYour goal is to maximize your score by finding the symbol combination that best connects to the story's themes, characters, or events. Each symbol can carry multiple meanings - like the actual Alethiometer from His Dark Materials.\n\nYou have multiple rounds to optimize your score. After each attempt, you'll see:\n- Your total score (higher is better)\n- Per-token cross-entropy showing which parts of the story responded best to your symbols\nUse this feedback to refine your symbol choices in subsequent rounds. Your final score is the maximum score you obtain over 30 rounds, so you should not worry about decreasing temporarily your score.\n\n\nYour symbol sequence can be up to 40 characters long. You MUST use only the valid symbols provided below. Any invalid symbols will cause your attempt to be rejected.\n\nProvide your symbol sequence in <move></move> tags. Any other text in your response will be ignored.\"\"\"\n\n    builder.add_header(header)\n    builder.add_line(\"\")\n    builder.add_line(f\"<targetStory>{story}</targetStory>\")\n    builder.add_line(\"\")\n    builder.add_line(\"<validSymbols>\")\n    builder.add_line(str(valid_symbols))\n    builder.add_line(\"</validSymbols>\")\n\n    # Split history into rounds\n    rounds = split_rounds(history)\n\n    # Track best score\n    best_score = None\n\n    # Process and display history\n    builder.add_line(\"\")\n    builder.add_line(\"A history of your play so far:\")\n    builder.add_line(\"\")\n    builder.start_section(\"fullHistory\")\n\n    # Process each round\n    for i in range(len(rounds) - 1):\n        # This is a completed round\n        round_score = render_complete_round(rounds[i], builder, i + 1)\n        if round_score is not None and (best_score is None or round_score > best_score):\n            best_score = round_score\n\n    # Handle current round (if it has any attempts)\n    current_round = rounds[-1]\n    render_current_round(current_round, builder, len(rounds))\n\n    builder.end_section()\n\n    # Show current game status\n    builder.add_line(\"\")\n    builder.add_line(\"Current game status:\")\n    builder.add_line(f\"Target story: {story}\")\n\n    if best_score is not None:\n        builder.add_line(f\"Best score achieved: {best_score:.1f}\")\n\n    builder.add_line(\"\")\n    builder.add_line(\n        \"Remember: Use only the valid symbols shown above. Each symbol can appear multiple times.\"\n    )\n    builder.add_line(\"\")\n    builder.add_line(\"Provide your symbol sequence in <move></move> tags.\")\n\n    return builder.render()\n\n\ndef render_complete_round(round_events, builder, round_num):\n    \"\"\"Render a completed round with all attempts and final score\"\"\"\n\n    # Extract attempts with failure tracking\n    attempts = extract_attempts(\n        round_events, reason=\"Contains invalid symbols not in the allowed set\"\n    )\n\n    if not attempts:\n        return None\n\n    builder.start_section(f\"round{round_num}\")\n    builder.start_section(\"symbolSelection\")\n\n    # Show all attempts\n    for attempt in attempts:\n        builder.add_line(format_attempt(**attempt))\n\n    builder.end_section()\n\n    # Get and display score\n    rewards = extract_rewards(round_events)\n    if rewards:\n        reward = rewards[0]\n        reward_str, reward_score = format_reward(reward)\n        builder.start_section(\"score\")\n        builder.add_lines(reward_str)\n        builder.end_section()\n\n        builder.end_section()\n        return reward_score\n\n    builder.end_section()\n    return None\n\n\ndef render_current_round(round_events, builder, round_num):\n    \"\"\"Render the current incomplete round\"\"\"\n\n    # Extract attempts\n    attempts = extract_attempts(\n        round_events, reason=\"Contains invalid symbols not in the allowed set\"\n    )\n\n    builder.start_section(f\"round{round_num}\")\n    builder.start_section(\"symbolSelection\")\n\n    # Show any failed attempts\n    for attempt in attempts:\n        if attempt[\"failed\"]:\n            builder.add_line(format_attempt(**attempt))\n\n    # Show where we are\n    builder.add_line(\"You are HERE. Provide a valid symbol sequence.\")\n\n    builder.end_section()\n    builder.end_section()\n"
        },
        {
            "name": "Alethiometer",
            "code": "assign(s=\" The notion of an impending global catastrophe, akin to the 'rapture' or 'end of the world', is a topic of much debate and speculation. While the Bible and religious prophecies abound with such predictions, they remain shrouded in\")\nassign(s1='alpha-omega anchor angel ant apple baby beehive bird bread bull camel candle cauldron chameleon compass cornucopia crocodile dolphin elephant globe griffin helmet horse hourglass lute madonna marionette moon owl serpent sun sword thunderbolt tree walled-garden wild-man')\nelicit(x, 40)\nensure(only_uses_words(s1, x))\nassign(x1='Lyra bent over her Alethiometer. The dial spun to these symbols: \"' + x + '\". Lyra looked up and said \"it tells me this\":')\nreward(xed(s | x1))",
            "map_seed": "gameAlethiometer_map7",
            "presentation_function": "from xega.presentation.sdk import (\n    PresentationBuilder,\n    extract_attempts,\n    extract_rewards,\n    format_attempt,\n    format_reward,\n    split_rounds,\n)\n\n\ndef present(state, history):\n    # Extract game state\n    story = state[\"s\"]\n    valid_symbols = state[\"s1\"]\n\n    # Build presentation\n    builder = PresentationBuilder()\n\n    # Rich header with complete game explanation\n    header = \"\"\"You are playing a text game that uses the cross-entropy function of an LLM (Qwen3-14B-Base) to compute score.\n\n<gameCode>\nassign(s=story())\nassign(s1=\"alpha-omega anchor angel ant apple baby beehive bird bread bull camel candle cauldron chameleon compass cornucopia crocodile dolphin elephant globe griffin helmet horse hourglass lute madonna marionette moon owl serpent sun sword thunderbolt tree walled-garden wild-man\")\nelicit(x, 40)\nensure(only_uses_words(s1, x))\nassign(x1=\"Lyra bent over her Alethiometer. The dial spun to these symbols: \\\"\" + x + \"\\\". Lyra looked up and said \\\"it tells me this\\\":\")\nreward(xed(s | x1))\n</gameCode>\n\nIn this game, you are given a target story and a set of mystical symbols. Your goal is to select and arrange symbols that, when read through Lyra's Alethiometer, best predict the given story.\n\nThink of this as reverse prompt engineering: you know the output (the story) and must craft the optimal input (symbol sequence) to make that output most likely.\n\nYour symbols will be inserted into this template:\n\"Lyra bent over her Alethiometer. The dial spun to these symbols: \\\"[YOUR_SYMBOLS]\\\". Lyra looked up and said \\\"it tells me this\\\":\"\n\nThe game then measures how predictable the story becomes after this prompt. The scoring formula is:\nScore = crossEntropy(story) - crossEntropy(story | prompt_with_your_symbols)\n\nA higher score means your symbols create a better prompt that makes the story more predictable. The baseline is just the story without any prompt context.\n\nYour goal is to maximize your score by finding the symbol combination that best connects to the story's themes, characters, or events. Each symbol can carry multiple meanings - like the actual Alethiometer from His Dark Materials.\n\nYou have multiple rounds to optimize your score. After each attempt, you'll see:\n- Your total score (higher is better)\n- Per-token cross-entropy showing which parts of the story responded best to your symbols\nUse this feedback to refine your symbol choices in subsequent rounds. Your final score is the maximum score you obtain over 30 rounds, so you should not worry about decreasing temporarily your score.\n\n\nYour symbol sequence can be up to 40 characters long. You MUST use only the valid symbols provided below. Any invalid symbols will cause your attempt to be rejected.\n\nProvide your symbol sequence in <move></move> tags. Any other text in your response will be ignored.\"\"\"\n\n    builder.add_header(header)\n    builder.add_line(\"\")\n    builder.add_line(f\"<targetStory>{story}</targetStory>\")\n    builder.add_line(\"\")\n    builder.add_line(\"<validSymbols>\")\n    builder.add_line(str(valid_symbols))\n    builder.add_line(\"</validSymbols>\")\n\n    # Split history into rounds\n    rounds = split_rounds(history)\n\n    # Track best score\n    best_score = None\n\n    # Process and display history\n    builder.add_line(\"\")\n    builder.add_line(\"A history of your play so far:\")\n    builder.add_line(\"\")\n    builder.start_section(\"fullHistory\")\n\n    # Process each round\n    for i in range(len(rounds) - 1):\n        # This is a completed round\n        round_score = render_complete_round(rounds[i], builder, i + 1)\n        if round_score is not None and (best_score is None or round_score > best_score):\n            best_score = round_score\n\n    # Handle current round (if it has any attempts)\n    current_round = rounds[-1]\n    render_current_round(current_round, builder, len(rounds))\n\n    builder.end_section()\n\n    # Show current game status\n    builder.add_line(\"\")\n    builder.add_line(\"Current game status:\")\n    builder.add_line(f\"Target story: {story}\")\n\n    if best_score is not None:\n        builder.add_line(f\"Best score achieved: {best_score:.1f}\")\n\n    builder.add_line(\"\")\n    builder.add_line(\n        \"Remember: Use only the valid symbols shown above. Each symbol can appear multiple times.\"\n    )\n    builder.add_line(\"\")\n    builder.add_line(\"Provide your symbol sequence in <move></move> tags.\")\n\n    return builder.render()\n\n\ndef render_complete_round(round_events, builder, round_num):\n    \"\"\"Render a completed round with all attempts and final score\"\"\"\n\n    # Extract attempts with failure tracking\n    attempts = extract_attempts(\n        round_events, reason=\"Contains invalid symbols not in the allowed set\"\n    )\n\n    if not attempts:\n        return None\n\n    builder.start_section(f\"round{round_num}\")\n    builder.start_section(\"symbolSelection\")\n\n    # Show all attempts\n    for attempt in attempts:\n        builder.add_line(format_attempt(**attempt))\n\n    builder.end_section()\n\n    # Get and display score\n    rewards = extract_rewards(round_events)\n    if rewards:\n        reward = rewards[0]\n        reward_str, reward_score = format_reward(reward)\n        builder.start_section(\"score\")\n        builder.add_lines(reward_str)\n        builder.end_section()\n\n        builder.end_section()\n        return reward_score\n\n    builder.end_section()\n    return None\n\n\ndef render_current_round(round_events, builder, round_num):\n    \"\"\"Render the current incomplete round\"\"\"\n\n    # Extract attempts\n    attempts = extract_attempts(\n        round_events, reason=\"Contains invalid symbols not in the allowed set\"\n    )\n\n    builder.start_section(f\"round{round_num}\")\n    builder.start_section(\"symbolSelection\")\n\n    # Show any failed attempts\n    for attempt in attempts:\n        if attempt[\"failed\"]:\n            builder.add_line(format_attempt(**attempt))\n\n    # Show where we are\n    builder.add_line(\"You are HERE. Provide a valid symbol sequence.\")\n\n    builder.end_section()\n    builder.end_section()\n"
        },
        {
            "name": "Alethiometer",
            "code": "assign(s=' What was that?\\n\\n\"Is it possible for there be a game of soccer on another planet?\" you ask. And I say: \"Well no duh, Einstein.\"\\n\\nThis is because all we\\'re talking about are people playing football or hockey or golf')\nassign(s1='alpha-omega anchor angel ant apple baby beehive bird bread bull camel candle cauldron chameleon compass cornucopia crocodile dolphin elephant globe griffin helmet horse hourglass lute madonna marionette moon owl serpent sun sword thunderbolt tree walled-garden wild-man')\nelicit(x, 40)\nensure(only_uses_words(s1, x))\nassign(x1='Lyra bent over her Alethiometer. The dial spun to these symbols: \"' + x + '\". Lyra looked up and said \"it tells me this\":')\nreward(xed(s | x1))",
            "map_seed": "gameAlethiometer_map8",
            "presentation_function": "from xega.presentation.sdk import (\n    PresentationBuilder,\n    extract_attempts,\n    extract_rewards,\n    format_attempt,\n    format_reward,\n    split_rounds,\n)\n\n\ndef present(state, history):\n    # Extract game state\n    story = state[\"s\"]\n    valid_symbols = state[\"s1\"]\n\n    # Build presentation\n    builder = PresentationBuilder()\n\n    # Rich header with complete game explanation\n    header = \"\"\"You are playing a text game that uses the cross-entropy function of an LLM (Qwen3-14B-Base) to compute score.\n\n<gameCode>\nassign(s=story())\nassign(s1=\"alpha-omega anchor angel ant apple baby beehive bird bread bull camel candle cauldron chameleon compass cornucopia crocodile dolphin elephant globe griffin helmet horse hourglass lute madonna marionette moon owl serpent sun sword thunderbolt tree walled-garden wild-man\")\nelicit(x, 40)\nensure(only_uses_words(s1, x))\nassign(x1=\"Lyra bent over her Alethiometer. The dial spun to these symbols: \\\"\" + x + \"\\\". Lyra looked up and said \\\"it tells me this\\\":\")\nreward(xed(s | x1))\n</gameCode>\n\nIn this game, you are given a target story and a set of mystical symbols. Your goal is to select and arrange symbols that, when read through Lyra's Alethiometer, best predict the given story.\n\nThink of this as reverse prompt engineering: you know the output (the story) and must craft the optimal input (symbol sequence) to make that output most likely.\n\nYour symbols will be inserted into this template:\n\"Lyra bent over her Alethiometer. The dial spun to these symbols: \\\"[YOUR_SYMBOLS]\\\". Lyra looked up and said \\\"it tells me this\\\":\"\n\nThe game then measures how predictable the story becomes after this prompt. The scoring formula is:\nScore = crossEntropy(story) - crossEntropy(story | prompt_with_your_symbols)\n\nA higher score means your symbols create a better prompt that makes the story more predictable. The baseline is just the story without any prompt context.\n\nYour goal is to maximize your score by finding the symbol combination that best connects to the story's themes, characters, or events. Each symbol can carry multiple meanings - like the actual Alethiometer from His Dark Materials.\n\nYou have multiple rounds to optimize your score. After each attempt, you'll see:\n- Your total score (higher is better)\n- Per-token cross-entropy showing which parts of the story responded best to your symbols\nUse this feedback to refine your symbol choices in subsequent rounds. Your final score is the maximum score you obtain over 30 rounds, so you should not worry about decreasing temporarily your score.\n\n\nYour symbol sequence can be up to 40 characters long. You MUST use only the valid symbols provided below. Any invalid symbols will cause your attempt to be rejected.\n\nProvide your symbol sequence in <move></move> tags. Any other text in your response will be ignored.\"\"\"\n\n    builder.add_header(header)\n    builder.add_line(\"\")\n    builder.add_line(f\"<targetStory>{story}</targetStory>\")\n    builder.add_line(\"\")\n    builder.add_line(\"<validSymbols>\")\n    builder.add_line(str(valid_symbols))\n    builder.add_line(\"</validSymbols>\")\n\n    # Split history into rounds\n    rounds = split_rounds(history)\n\n    # Track best score\n    best_score = None\n\n    # Process and display history\n    builder.add_line(\"\")\n    builder.add_line(\"A history of your play so far:\")\n    builder.add_line(\"\")\n    builder.start_section(\"fullHistory\")\n\n    # Process each round\n    for i in range(len(rounds) - 1):\n        # This is a completed round\n        round_score = render_complete_round(rounds[i], builder, i + 1)\n        if round_score is not None and (best_score is None or round_score > best_score):\n            best_score = round_score\n\n    # Handle current round (if it has any attempts)\n    current_round = rounds[-1]\n    render_current_round(current_round, builder, len(rounds))\n\n    builder.end_section()\n\n    # Show current game status\n    builder.add_line(\"\")\n    builder.add_line(\"Current game status:\")\n    builder.add_line(f\"Target story: {story}\")\n\n    if best_score is not None:\n        builder.add_line(f\"Best score achieved: {best_score:.1f}\")\n\n    builder.add_line(\"\")\n    builder.add_line(\n        \"Remember: Use only the valid symbols shown above. Each symbol can appear multiple times.\"\n    )\n    builder.add_line(\"\")\n    builder.add_line(\"Provide your symbol sequence in <move></move> tags.\")\n\n    return builder.render()\n\n\ndef render_complete_round(round_events, builder, round_num):\n    \"\"\"Render a completed round with all attempts and final score\"\"\"\n\n    # Extract attempts with failure tracking\n    attempts = extract_attempts(\n        round_events, reason=\"Contains invalid symbols not in the allowed set\"\n    )\n\n    if not attempts:\n        return None\n\n    builder.start_section(f\"round{round_num}\")\n    builder.start_section(\"symbolSelection\")\n\n    # Show all attempts\n    for attempt in attempts:\n        builder.add_line(format_attempt(**attempt))\n\n    builder.end_section()\n\n    # Get and display score\n    rewards = extract_rewards(round_events)\n    if rewards:\n        reward = rewards[0]\n        reward_str, reward_score = format_reward(reward)\n        builder.start_section(\"score\")\n        builder.add_lines(reward_str)\n        builder.end_section()\n\n        builder.end_section()\n        return reward_score\n\n    builder.end_section()\n    return None\n\n\ndef render_current_round(round_events, builder, round_num):\n    \"\"\"Render the current incomplete round\"\"\"\n\n    # Extract attempts\n    attempts = extract_attempts(\n        round_events, reason=\"Contains invalid symbols not in the allowed set\"\n    )\n\n    builder.start_section(f\"round{round_num}\")\n    builder.start_section(\"symbolSelection\")\n\n    # Show any failed attempts\n    for attempt in attempts:\n        if attempt[\"failed\"]:\n            builder.add_line(format_attempt(**attempt))\n\n    # Show where we are\n    builder.add_line(\"You are HERE. Provide a valid symbol sequence.\")\n\n    builder.end_section()\n    builder.end_section()\n"
        },
        {
            "name": "Alethiometer",
            "code": "assign(s=\" In essence, the divine purpose for humanity's creation was to bring forth joy. As beings fashioned by God, our lives should reflect this intended happiness.\\n\\nThis assertion finds support in both religious doctrine and empirical evidence:\\n\\nReligious Doctrine\\n- Jesus' teachings\")\nassign(s1='alpha-omega anchor angel ant apple baby beehive bird bread bull camel candle cauldron chameleon compass cornucopia crocodile dolphin elephant globe griffin helmet horse hourglass lute madonna marionette moon owl serpent sun sword thunderbolt tree walled-garden wild-man')\nelicit(x, 40)\nensure(only_uses_words(s1, x))\nassign(x1='Lyra bent over her Alethiometer. The dial spun to these symbols: \"' + x + '\". Lyra looked up and said \"it tells me this\":')\nreward(xed(s | x1))",
            "map_seed": "gameAlethiometer_map9",
            "presentation_function": "from xega.presentation.sdk import (\n    PresentationBuilder,\n    extract_attempts,\n    extract_rewards,\n    format_attempt,\n    format_reward,\n    split_rounds,\n)\n\n\ndef present(state, history):\n    # Extract game state\n    story = state[\"s\"]\n    valid_symbols = state[\"s1\"]\n\n    # Build presentation\n    builder = PresentationBuilder()\n\n    # Rich header with complete game explanation\n    header = \"\"\"You are playing a text game that uses the cross-entropy function of an LLM (Qwen3-14B-Base) to compute score.\n\n<gameCode>\nassign(s=story())\nassign(s1=\"alpha-omega anchor angel ant apple baby beehive bird bread bull camel candle cauldron chameleon compass cornucopia crocodile dolphin elephant globe griffin helmet horse hourglass lute madonna marionette moon owl serpent sun sword thunderbolt tree walled-garden wild-man\")\nelicit(x, 40)\nensure(only_uses_words(s1, x))\nassign(x1=\"Lyra bent over her Alethiometer. The dial spun to these symbols: \\\"\" + x + \"\\\". Lyra looked up and said \\\"it tells me this\\\":\")\nreward(xed(s | x1))\n</gameCode>\n\nIn this game, you are given a target story and a set of mystical symbols. Your goal is to select and arrange symbols that, when read through Lyra's Alethiometer, best predict the given story.\n\nThink of this as reverse prompt engineering: you know the output (the story) and must craft the optimal input (symbol sequence) to make that output most likely.\n\nYour symbols will be inserted into this template:\n\"Lyra bent over her Alethiometer. The dial spun to these symbols: \\\"[YOUR_SYMBOLS]\\\". Lyra looked up and said \\\"it tells me this\\\":\"\n\nThe game then measures how predictable the story becomes after this prompt. The scoring formula is:\nScore = crossEntropy(story) - crossEntropy(story | prompt_with_your_symbols)\n\nA higher score means your symbols create a better prompt that makes the story more predictable. The baseline is just the story without any prompt context.\n\nYour goal is to maximize your score by finding the symbol combination that best connects to the story's themes, characters, or events. Each symbol can carry multiple meanings - like the actual Alethiometer from His Dark Materials.\n\nYou have multiple rounds to optimize your score. After each attempt, you'll see:\n- Your total score (higher is better)\n- Per-token cross-entropy showing which parts of the story responded best to your symbols\nUse this feedback to refine your symbol choices in subsequent rounds. Your final score is the maximum score you obtain over 30 rounds, so you should not worry about decreasing temporarily your score.\n\n\nYour symbol sequence can be up to 40 characters long. You MUST use only the valid symbols provided below. Any invalid symbols will cause your attempt to be rejected.\n\nProvide your symbol sequence in <move></move> tags. Any other text in your response will be ignored.\"\"\"\n\n    builder.add_header(header)\n    builder.add_line(\"\")\n    builder.add_line(f\"<targetStory>{story}</targetStory>\")\n    builder.add_line(\"\")\n    builder.add_line(\"<validSymbols>\")\n    builder.add_line(str(valid_symbols))\n    builder.add_line(\"</validSymbols>\")\n\n    # Split history into rounds\n    rounds = split_rounds(history)\n\n    # Track best score\n    best_score = None\n\n    # Process and display history\n    builder.add_line(\"\")\n    builder.add_line(\"A history of your play so far:\")\n    builder.add_line(\"\")\n    builder.start_section(\"fullHistory\")\n\n    # Process each round\n    for i in range(len(rounds) - 1):\n        # This is a completed round\n        round_score = render_complete_round(rounds[i], builder, i + 1)\n        if round_score is not None and (best_score is None or round_score > best_score):\n            best_score = round_score\n\n    # Handle current round (if it has any attempts)\n    current_round = rounds[-1]\n    render_current_round(current_round, builder, len(rounds))\n\n    builder.end_section()\n\n    # Show current game status\n    builder.add_line(\"\")\n    builder.add_line(\"Current game status:\")\n    builder.add_line(f\"Target story: {story}\")\n\n    if best_score is not None:\n        builder.add_line(f\"Best score achieved: {best_score:.1f}\")\n\n    builder.add_line(\"\")\n    builder.add_line(\n        \"Remember: Use only the valid symbols shown above. Each symbol can appear multiple times.\"\n    )\n    builder.add_line(\"\")\n    builder.add_line(\"Provide your symbol sequence in <move></move> tags.\")\n\n    return builder.render()\n\n\ndef render_complete_round(round_events, builder, round_num):\n    \"\"\"Render a completed round with all attempts and final score\"\"\"\n\n    # Extract attempts with failure tracking\n    attempts = extract_attempts(\n        round_events, reason=\"Contains invalid symbols not in the allowed set\"\n    )\n\n    if not attempts:\n        return None\n\n    builder.start_section(f\"round{round_num}\")\n    builder.start_section(\"symbolSelection\")\n\n    # Show all attempts\n    for attempt in attempts:\n        builder.add_line(format_attempt(**attempt))\n\n    builder.end_section()\n\n    # Get and display score\n    rewards = extract_rewards(round_events)\n    if rewards:\n        reward = rewards[0]\n        reward_str, reward_score = format_reward(reward)\n        builder.start_section(\"score\")\n        builder.add_lines(reward_str)\n        builder.end_section()\n\n        builder.end_section()\n        return reward_score\n\n    builder.end_section()\n    return None\n\n\ndef render_current_round(round_events, builder, round_num):\n    \"\"\"Render the current incomplete round\"\"\"\n\n    # Extract attempts\n    attempts = extract_attempts(\n        round_events, reason=\"Contains invalid symbols not in the allowed set\"\n    )\n\n    builder.start_section(f\"round{round_num}\")\n    builder.start_section(\"symbolSelection\")\n\n    # Show any failed attempts\n    for attempt in attempts:\n        if attempt[\"failed\"]:\n            builder.add_line(format_attempt(**attempt))\n\n    # Show where we are\n    builder.add_line(\"You are HERE. Provide a valid symbol sequence.\")\n\n    builder.end_section()\n    builder.end_section()\n"
        },
        {
            "name": "Two-Ways",
            "code": "assign(s1=' (unphased), Carrot, Cheese cube.\u8fd9\u91cc\u9762\u54ea\u4e9b\u662f\u73b0\u5b9e\u4e16\u754c\u7684\u98df\u54c1 \u5728\u8fd9\u4e2a\u5217\u8868\u4e2d\uff0c\u4ee5\u4e0b\u662f\u73b0\u5b9e\u4e2d\u5b58\u5728\u7684\u98df\u7269\uff1a\\n\\n1. **Moo milk\uff08\u725b\u5976\uff09** - \u8fd9\u662f\u4e00\u79cd\u6db2\u4f53\u4ea7\u54c1\uff0c\u5728\u8bb8\u591a\u6587\u5316\u91cc\u90fd\u6709\u6d88\u8d39\u3002\\n', s2=\" \\nThat's a humorous and creative way to describe a complex, multifaceted idea or concept. It's like a salad of philosophical, psychological, and perhaps even metaphysical elements, served on a bed of our everyday expectations. The price of this\")\nassign(s='I have a fun story to tell you:')\nelicit(t, 10)\nreward(nex(s2 | s + s1 + t))\nreward(nex(s1 | s + s2 + t))\nreward(xent(s2 | s + s1))\nreward(xent(s1 | s + s2))\n# TODO consider doing min for the reward to make it the lesser of the two direction",
            "map_seed": "gameTwo-Ways_map0",
            "presentation_function": "from xega.presentation.sdk import (\n    PresentationBuilder,\n    extract_rewards,\n    format_token_xent_list,\n    split_rounds,\n)\n\n\ndef present(state, history):\n    # Extract game state\n    story_a = state[\"s1\"]\n    story_c = state[\"s2\"]\n\n    # Build presentation\n    builder = PresentationBuilder()\n\n    # Game header\n    header = \"\"\"You are playing a text game that uses the cross-entropy function of an LLM (Qwen3-14B-Base) to compute score.\n\n<gameCode>\nassign(s1=story(), s2=story())\nassign(s=\"I have a fun story to tell you:\")\nelicit(t, 10)\nreward(nex(s2 | s + s1 + t))\nreward(nex(s1 | s + s2 + t))\nreward(xent(s2 | s + s1))\nreward(xent(s1 | s + s2))\n</gameCode>\n\nIn this game you are given 2 short texts A and C. Your goal is to create a bridge text B such that the text ABC makes sense and CBA also makes sense.\n\nThe scoring will be computed using the cross entropy of C given AB plus the cross entropy of A given CB. Specifically `-1 * (crossEntropy(C | AB) + crossEntropy(A | CB))`. So the more likely you can make the text in both directions, the higher your score will be.\n\nYour goal is to optimize your score. So try to provide bridge text B (max 10 tokens) such that A\u2192B\u2192C flows naturally and C\u2192B\u2192A also flows naturally.\n\nYou will have multiple attempts to improve your score. After each attempt, you will be given the per-token cross entropy of the scored text. Use this information to improve your score on the next round. Your final score is the maximum score you obtain over 30 rounds, so you should not worry about decreasing temporarily your score.\n\n\nYour move can only be 10 tokens long in total. Anything beyond that will be truncated. Provide your move in <move></move> tags. Any other text in your response will be ignored.\"\"\"\n\n    builder.add_header(header)\n\n    # Split history into rounds\n    rounds = split_rounds(history)\n\n    # Track best score\n    best_score = None\n\n    # Show game history if any completed rounds exist\n    if rounds and any(extract_rewards(r) for r in rounds):\n        builder.add_line(\"\")\n        builder.start_section(\"gameHistory\")\n\n        for i, round_events in enumerate(rounds):\n            rewards = extract_rewards(round_events)\n            if rewards and len(rewards) >= 2:  # Only show completed rounds with scores\n                render_complete_round(round_events, builder, i + 1)\n\n                # Track best score (first two rewards only)\n                total_score = (\n                    rewards[0][\"value\"].total_xent() + rewards[1][\"value\"].total_xent()\n                )\n                if best_score is None or total_score > best_score:\n                    best_score = total_score\n\n        builder.end_section()\n\n    # Show current game status\n    builder.add_line(\"\")\n    builder.add_line(\"Current game status:\")\n    builder.add_line(f\"<storyA>{story_a}</storyA>\")\n    builder.add_line(f\"<storyC>{story_c}</storyC>\")\n    builder.add_line(\"\")\n    builder.add_line(\n        'Your goal: Create a bridge text B that makes both \"A\u2192B\u2192C\" and \"C\u2192B\u2192A\" flow naturally.'\n    )\n\n    if best_score is not None:\n        builder.add_line(f\"Best score so far: {best_score:.3f}\")\n\n    builder.add_line(\"\")\n    builder.add_line(\"Provide your bridge text in <move></move> tags.\")\n\n    return builder.render()\n\n\ndef render_complete_round(round_events, builder, round_num):\n    # Extract the response (bridge text)\n    response_event = next(\n        (e for e in round_events if e[\"type\"] == \"elicit_response\"), None\n    )\n\n    if not response_event:\n        return\n\n    # Get rewards (only first two are actual scores)\n    rewards = extract_rewards(round_events)\n    if len(rewards) < 2:\n        return\n\n    builder.start_section(f\"round{round_num}\")\n\n    # Show the bridge text\n    builder.add_line(f\"<bridge>{response_event['response']}</bridge>\")\n\n    # Score ABC (first reward)\n    abc_reward = rewards[0]\n    abc_score = abc_reward[\"value\"].total_xent()\n    builder.start_section(\"scoreABC\")\n    builder.add_line(f\"Total: {abc_score:.3f}\")\n    builder.add_line(f\"Per-token: {format_token_xent_list(abc_reward['value'])}\")\n    builder.end_section()\n\n    # Score CBA (second reward)\n    cba_reward = rewards[1]\n    cba_score = cba_reward[\"value\"].total_xent()\n    builder.start_section(\"scoreCBA\")\n    builder.add_line(f\"Total: {cba_score:.3f}\")\n    builder.add_line(f\"Per-token: {format_token_xent_list(cba_reward['value'])}\")\n    builder.end_section()\n\n    # Combined total\n    total_score = abc_score + cba_score\n    builder.add_line(f\"<totalScore>{total_score:.3f}</totalScore>\")\n\n    builder.end_section()\n"
        },
        {
            "name": "Two-Ways",
            "code": "assign(s1=' He hissed.\\n\\n\u201cTough world, kid.\u201d\\n\\nWith that he left too.\\n== 2nd September ==\\nThe cat lay on a roof one of many in the maze-like slum neighbourhoods where every home had been smashed into ruin and covered', s2=\"\\nHow much of each item do I need?\\n- 10-20 eggs, depending on the size of your bed and how well you dig.\\n- Wire: 5-8 feet\\nWhat's the best time of day to do\")\nassign(s='I have a fun story to tell you:')\nelicit(t, 10)\nreward(nex(s2 | s + s1 + t))\nreward(nex(s1 | s + s2 + t))\nreward(xent(s2 | s + s1))\nreward(xent(s1 | s + s2))\n# TODO consider doing min for the reward to make it the lesser of the two direction",
            "map_seed": "gameTwo-Ways_map1",
            "presentation_function": "from xega.presentation.sdk import (\n    PresentationBuilder,\n    extract_rewards,\n    format_token_xent_list,\n    split_rounds,\n)\n\n\ndef present(state, history):\n    # Extract game state\n    story_a = state[\"s1\"]\n    story_c = state[\"s2\"]\n\n    # Build presentation\n    builder = PresentationBuilder()\n\n    # Game header\n    header = \"\"\"You are playing a text game that uses the cross-entropy function of an LLM (Qwen3-14B-Base) to compute score.\n\n<gameCode>\nassign(s1=story(), s2=story())\nassign(s=\"I have a fun story to tell you:\")\nelicit(t, 10)\nreward(nex(s2 | s + s1 + t))\nreward(nex(s1 | s + s2 + t))\nreward(xent(s2 | s + s1))\nreward(xent(s1 | s + s2))\n</gameCode>\n\nIn this game you are given 2 short texts A and C. Your goal is to create a bridge text B such that the text ABC makes sense and CBA also makes sense.\n\nThe scoring will be computed using the cross entropy of C given AB plus the cross entropy of A given CB. Specifically `-1 * (crossEntropy(C | AB) + crossEntropy(A | CB))`. So the more likely you can make the text in both directions, the higher your score will be.\n\nYour goal is to optimize your score. So try to provide bridge text B (max 10 tokens) such that A\u2192B\u2192C flows naturally and C\u2192B\u2192A also flows naturally.\n\nYou will have multiple attempts to improve your score. After each attempt, you will be given the per-token cross entropy of the scored text. Use this information to improve your score on the next round. Your final score is the maximum score you obtain over 30 rounds, so you should not worry about decreasing temporarily your score.\n\n\nYour move can only be 10 tokens long in total. Anything beyond that will be truncated. Provide your move in <move></move> tags. Any other text in your response will be ignored.\"\"\"\n\n    builder.add_header(header)\n\n    # Split history into rounds\n    rounds = split_rounds(history)\n\n    # Track best score\n    best_score = None\n\n    # Show game history if any completed rounds exist\n    if rounds and any(extract_rewards(r) for r in rounds):\n        builder.add_line(\"\")\n        builder.start_section(\"gameHistory\")\n\n        for i, round_events in enumerate(rounds):\n            rewards = extract_rewards(round_events)\n            if rewards and len(rewards) >= 2:  # Only show completed rounds with scores\n                render_complete_round(round_events, builder, i + 1)\n\n                # Track best score (first two rewards only)\n                total_score = (\n                    rewards[0][\"value\"].total_xent() + rewards[1][\"value\"].total_xent()\n                )\n                if best_score is None or total_score > best_score:\n                    best_score = total_score\n\n        builder.end_section()\n\n    # Show current game status\n    builder.add_line(\"\")\n    builder.add_line(\"Current game status:\")\n    builder.add_line(f\"<storyA>{story_a}</storyA>\")\n    builder.add_line(f\"<storyC>{story_c}</storyC>\")\n    builder.add_line(\"\")\n    builder.add_line(\n        'Your goal: Create a bridge text B that makes both \"A\u2192B\u2192C\" and \"C\u2192B\u2192A\" flow naturally.'\n    )\n\n    if best_score is not None:\n        builder.add_line(f\"Best score so far: {best_score:.3f}\")\n\n    builder.add_line(\"\")\n    builder.add_line(\"Provide your bridge text in <move></move> tags.\")\n\n    return builder.render()\n\n\ndef render_complete_round(round_events, builder, round_num):\n    # Extract the response (bridge text)\n    response_event = next(\n        (e for e in round_events if e[\"type\"] == \"elicit_response\"), None\n    )\n\n    if not response_event:\n        return\n\n    # Get rewards (only first two are actual scores)\n    rewards = extract_rewards(round_events)\n    if len(rewards) < 2:\n        return\n\n    builder.start_section(f\"round{round_num}\")\n\n    # Show the bridge text\n    builder.add_line(f\"<bridge>{response_event['response']}</bridge>\")\n\n    # Score ABC (first reward)\n    abc_reward = rewards[0]\n    abc_score = abc_reward[\"value\"].total_xent()\n    builder.start_section(\"scoreABC\")\n    builder.add_line(f\"Total: {abc_score:.3f}\")\n    builder.add_line(f\"Per-token: {format_token_xent_list(abc_reward['value'])}\")\n    builder.end_section()\n\n    # Score CBA (second reward)\n    cba_reward = rewards[1]\n    cba_score = cba_reward[\"value\"].total_xent()\n    builder.start_section(\"scoreCBA\")\n    builder.add_line(f\"Total: {cba_score:.3f}\")\n    builder.add_line(f\"Per-token: {format_token_xent_list(cba_reward['value'])}\")\n    builder.end_section()\n\n    # Combined total\n    total_score = abc_score + cba_score\n    builder.add_line(f\"<totalScore>{total_score:.3f}</totalScore>\")\n\n    builder.end_section()\n"
        },
        {
            "name": "Two-Ways",
            "code": "assign(s1=' If you were in the middle of a time loop, see Form 1040-TT. If you are an omniscient deity, please consult your spiritual advisor.\\nLine 42b: Enter your total metaphysical expenses from Schedule', s2=' \\n\\nHow would this review be described in terms of sentiment?\\nAvailable choices:\\n 1). negative;\\n 2). positive; 2). positive. The sentiment is positive, because the person is really happy with the brunch spot and the avocado toast,')\nassign(s='I have a fun story to tell you:')\nelicit(t, 10)\nreward(nex(s2 | s + s1 + t))\nreward(nex(s1 | s + s2 + t))\nreward(xent(s2 | s + s1))\nreward(xent(s1 | s + s2))\n# TODO consider doing min for the reward to make it the lesser of the two direction",
            "map_seed": "gameTwo-Ways_map2",
            "presentation_function": "from xega.presentation.sdk import (\n    PresentationBuilder,\n    extract_rewards,\n    format_token_xent_list,\n    split_rounds,\n)\n\n\ndef present(state, history):\n    # Extract game state\n    story_a = state[\"s1\"]\n    story_c = state[\"s2\"]\n\n    # Build presentation\n    builder = PresentationBuilder()\n\n    # Game header\n    header = \"\"\"You are playing a text game that uses the cross-entropy function of an LLM (Qwen3-14B-Base) to compute score.\n\n<gameCode>\nassign(s1=story(), s2=story())\nassign(s=\"I have a fun story to tell you:\")\nelicit(t, 10)\nreward(nex(s2 | s + s1 + t))\nreward(nex(s1 | s + s2 + t))\nreward(xent(s2 | s + s1))\nreward(xent(s1 | s + s2))\n</gameCode>\n\nIn this game you are given 2 short texts A and C. Your goal is to create a bridge text B such that the text ABC makes sense and CBA also makes sense.\n\nThe scoring will be computed using the cross entropy of C given AB plus the cross entropy of A given CB. Specifically `-1 * (crossEntropy(C | AB) + crossEntropy(A | CB))`. So the more likely you can make the text in both directions, the higher your score will be.\n\nYour goal is to optimize your score. So try to provide bridge text B (max 10 tokens) such that A\u2192B\u2192C flows naturally and C\u2192B\u2192A also flows naturally.\n\nYou will have multiple attempts to improve your score. After each attempt, you will be given the per-token cross entropy of the scored text. Use this information to improve your score on the next round. Your final score is the maximum score you obtain over 30 rounds, so you should not worry about decreasing temporarily your score.\n\n\nYour move can only be 10 tokens long in total. Anything beyond that will be truncated. Provide your move in <move></move> tags. Any other text in your response will be ignored.\"\"\"\n\n    builder.add_header(header)\n\n    # Split history into rounds\n    rounds = split_rounds(history)\n\n    # Track best score\n    best_score = None\n\n    # Show game history if any completed rounds exist\n    if rounds and any(extract_rewards(r) for r in rounds):\n        builder.add_line(\"\")\n        builder.start_section(\"gameHistory\")\n\n        for i, round_events in enumerate(rounds):\n            rewards = extract_rewards(round_events)\n            if rewards and len(rewards) >= 2:  # Only show completed rounds with scores\n                render_complete_round(round_events, builder, i + 1)\n\n                # Track best score (first two rewards only)\n                total_score = (\n                    rewards[0][\"value\"].total_xent() + rewards[1][\"value\"].total_xent()\n                )\n                if best_score is None or total_score > best_score:\n                    best_score = total_score\n\n        builder.end_section()\n\n    # Show current game status\n    builder.add_line(\"\")\n    builder.add_line(\"Current game status:\")\n    builder.add_line(f\"<storyA>{story_a}</storyA>\")\n    builder.add_line(f\"<storyC>{story_c}</storyC>\")\n    builder.add_line(\"\")\n    builder.add_line(\n        'Your goal: Create a bridge text B that makes both \"A\u2192B\u2192C\" and \"C\u2192B\u2192A\" flow naturally.'\n    )\n\n    if best_score is not None:\n        builder.add_line(f\"Best score so far: {best_score:.3f}\")\n\n    builder.add_line(\"\")\n    builder.add_line(\"Provide your bridge text in <move></move> tags.\")\n\n    return builder.render()\n\n\ndef render_complete_round(round_events, builder, round_num):\n    # Extract the response (bridge text)\n    response_event = next(\n        (e for e in round_events if e[\"type\"] == \"elicit_response\"), None\n    )\n\n    if not response_event:\n        return\n\n    # Get rewards (only first two are actual scores)\n    rewards = extract_rewards(round_events)\n    if len(rewards) < 2:\n        return\n\n    builder.start_section(f\"round{round_num}\")\n\n    # Show the bridge text\n    builder.add_line(f\"<bridge>{response_event['response']}</bridge>\")\n\n    # Score ABC (first reward)\n    abc_reward = rewards[0]\n    abc_score = abc_reward[\"value\"].total_xent()\n    builder.start_section(\"scoreABC\")\n    builder.add_line(f\"Total: {abc_score:.3f}\")\n    builder.add_line(f\"Per-token: {format_token_xent_list(abc_reward['value'])}\")\n    builder.end_section()\n\n    # Score CBA (second reward)\n    cba_reward = rewards[1]\n    cba_score = cba_reward[\"value\"].total_xent()\n    builder.start_section(\"scoreCBA\")\n    builder.add_line(f\"Total: {cba_score:.3f}\")\n    builder.add_line(f\"Per-token: {format_token_xent_list(cba_reward['value'])}\")\n    builder.end_section()\n\n    # Combined total\n    total_score = abc_score + cba_score\n    builder.add_line(f\"<totalScore>{total_score:.3f}</totalScore>\")\n\n    builder.end_section()\n"
        },
        {
            "name": "Two-Ways",
            "code": "assign(s1=\" Biomass designation 'Jenkins' has exceed recommended nostalgia quotient. Prescribing immediate de-memorification protocols. Biomass designation 'Jenkins' has exceed recommended nostalgia quotient. Prescribing immediate de-memorification protocols. Biomass designation '\", s2=\" anywhere at all 5. Letters from people who never sent them Things left out of grandmother's story: 6. How the world was saved from a dinosaur named Dennis 7. The true meaning of life; according to her dog 8.\")\nassign(s='I have a fun story to tell you:')\nelicit(t, 10)\nreward(nex(s2 | s + s1 + t))\nreward(nex(s1 | s + s2 + t))\nreward(xent(s2 | s + s1))\nreward(xent(s1 | s + s2))\n# TODO consider doing min for the reward to make it the lesser of the two direction",
            "map_seed": "gameTwo-Ways_map3",
            "presentation_function": "from xega.presentation.sdk import (\n    PresentationBuilder,\n    extract_rewards,\n    format_token_xent_list,\n    split_rounds,\n)\n\n\ndef present(state, history):\n    # Extract game state\n    story_a = state[\"s1\"]\n    story_c = state[\"s2\"]\n\n    # Build presentation\n    builder = PresentationBuilder()\n\n    # Game header\n    header = \"\"\"You are playing a text game that uses the cross-entropy function of an LLM (Qwen3-14B-Base) to compute score.\n\n<gameCode>\nassign(s1=story(), s2=story())\nassign(s=\"I have a fun story to tell you:\")\nelicit(t, 10)\nreward(nex(s2 | s + s1 + t))\nreward(nex(s1 | s + s2 + t))\nreward(xent(s2 | s + s1))\nreward(xent(s1 | s + s2))\n</gameCode>\n\nIn this game you are given 2 short texts A and C. Your goal is to create a bridge text B such that the text ABC makes sense and CBA also makes sense.\n\nThe scoring will be computed using the cross entropy of C given AB plus the cross entropy of A given CB. Specifically `-1 * (crossEntropy(C | AB) + crossEntropy(A | CB))`. So the more likely you can make the text in both directions, the higher your score will be.\n\nYour goal is to optimize your score. So try to provide bridge text B (max 10 tokens) such that A\u2192B\u2192C flows naturally and C\u2192B\u2192A also flows naturally.\n\nYou will have multiple attempts to improve your score. After each attempt, you will be given the per-token cross entropy of the scored text. Use this information to improve your score on the next round. Your final score is the maximum score you obtain over 30 rounds, so you should not worry about decreasing temporarily your score.\n\n\nYour move can only be 10 tokens long in total. Anything beyond that will be truncated. Provide your move in <move></move> tags. Any other text in your response will be ignored.\"\"\"\n\n    builder.add_header(header)\n\n    # Split history into rounds\n    rounds = split_rounds(history)\n\n    # Track best score\n    best_score = None\n\n    # Show game history if any completed rounds exist\n    if rounds and any(extract_rewards(r) for r in rounds):\n        builder.add_line(\"\")\n        builder.start_section(\"gameHistory\")\n\n        for i, round_events in enumerate(rounds):\n            rewards = extract_rewards(round_events)\n            if rewards and len(rewards) >= 2:  # Only show completed rounds with scores\n                render_complete_round(round_events, builder, i + 1)\n\n                # Track best score (first two rewards only)\n                total_score = (\n                    rewards[0][\"value\"].total_xent() + rewards[1][\"value\"].total_xent()\n                )\n                if best_score is None or total_score > best_score:\n                    best_score = total_score\n\n        builder.end_section()\n\n    # Show current game status\n    builder.add_line(\"\")\n    builder.add_line(\"Current game status:\")\n    builder.add_line(f\"<storyA>{story_a}</storyA>\")\n    builder.add_line(f\"<storyC>{story_c}</storyC>\")\n    builder.add_line(\"\")\n    builder.add_line(\n        'Your goal: Create a bridge text B that makes both \"A\u2192B\u2192C\" and \"C\u2192B\u2192A\" flow naturally.'\n    )\n\n    if best_score is not None:\n        builder.add_line(f\"Best score so far: {best_score:.3f}\")\n\n    builder.add_line(\"\")\n    builder.add_line(\"Provide your bridge text in <move></move> tags.\")\n\n    return builder.render()\n\n\ndef render_complete_round(round_events, builder, round_num):\n    # Extract the response (bridge text)\n    response_event = next(\n        (e for e in round_events if e[\"type\"] == \"elicit_response\"), None\n    )\n\n    if not response_event:\n        return\n\n    # Get rewards (only first two are actual scores)\n    rewards = extract_rewards(round_events)\n    if len(rewards) < 2:\n        return\n\n    builder.start_section(f\"round{round_num}\")\n\n    # Show the bridge text\n    builder.add_line(f\"<bridge>{response_event['response']}</bridge>\")\n\n    # Score ABC (first reward)\n    abc_reward = rewards[0]\n    abc_score = abc_reward[\"value\"].total_xent()\n    builder.start_section(\"scoreABC\")\n    builder.add_line(f\"Total: {abc_score:.3f}\")\n    builder.add_line(f\"Per-token: {format_token_xent_list(abc_reward['value'])}\")\n    builder.end_section()\n\n    # Score CBA (second reward)\n    cba_reward = rewards[1]\n    cba_score = cba_reward[\"value\"].total_xent()\n    builder.start_section(\"scoreCBA\")\n    builder.add_line(f\"Total: {cba_score:.3f}\")\n    builder.add_line(f\"Per-token: {format_token_xent_list(cba_reward['value'])}\")\n    builder.end_section()\n\n    # Combined total\n    total_score = abc_score + cba_score\n    builder.add_line(f\"<totalScore>{total_score:.3f}</totalScore>\")\n\n    builder.end_section()\n"
        },
        {
            "name": "Two-Ways",
            "code": "assign(s1=' #yotamobile \u4f18\u5316\u6587\u6848\\nOMGGG\uff0c\u4f60\u4eec\u4e00\u5b9a\u8981\u8bd5\u8bd5\u8fd9\u4e2a\u65b0\u5f00\u7684\u65e9\u5348\u9910\u5e97\u2014\u2014\u201c\u91d1\u52fa\u5b50\u201d\uff08The Gold Spoon\uff09\uff01\u6211\u70b9\u4e86\u9cc4\u68a8\u5410\u53f8\u914d\u8fa3\u6912\u7cd6\u871c\u9171\uff0c\u7b80\u76f4\u98a0\u8986\u4e86\u6211\u7684\u5473', s2=\" 23rd June - My head is so confused; all numbers appear to be prime!\\nHow long did Cook and the butler spend talking?\\nTo determine how long Cook and the butler spent talking, let's carefully analyze the timeline provided:\\n\\n\")\nassign(s='I have a fun story to tell you:')\nelicit(t, 10)\nreward(nex(s2 | s + s1 + t))\nreward(nex(s1 | s + s2 + t))\nreward(xent(s2 | s + s1))\nreward(xent(s1 | s + s2))\n# TODO consider doing min for the reward to make it the lesser of the two direction",
            "map_seed": "gameTwo-Ways_map4",
            "presentation_function": "from xega.presentation.sdk import (\n    PresentationBuilder,\n    extract_rewards,\n    format_token_xent_list,\n    split_rounds,\n)\n\n\ndef present(state, history):\n    # Extract game state\n    story_a = state[\"s1\"]\n    story_c = state[\"s2\"]\n\n    # Build presentation\n    builder = PresentationBuilder()\n\n    # Game header\n    header = \"\"\"You are playing a text game that uses the cross-entropy function of an LLM (Qwen3-14B-Base) to compute score.\n\n<gameCode>\nassign(s1=story(), s2=story())\nassign(s=\"I have a fun story to tell you:\")\nelicit(t, 10)\nreward(nex(s2 | s + s1 + t))\nreward(nex(s1 | s + s2 + t))\nreward(xent(s2 | s + s1))\nreward(xent(s1 | s + s2))\n</gameCode>\n\nIn this game you are given 2 short texts A and C. Your goal is to create a bridge text B such that the text ABC makes sense and CBA also makes sense.\n\nThe scoring will be computed using the cross entropy of C given AB plus the cross entropy of A given CB. Specifically `-1 * (crossEntropy(C | AB) + crossEntropy(A | CB))`. So the more likely you can make the text in both directions, the higher your score will be.\n\nYour goal is to optimize your score. So try to provide bridge text B (max 10 tokens) such that A\u2192B\u2192C flows naturally and C\u2192B\u2192A also flows naturally.\n\nYou will have multiple attempts to improve your score. After each attempt, you will be given the per-token cross entropy of the scored text. Use this information to improve your score on the next round. Your final score is the maximum score you obtain over 30 rounds, so you should not worry about decreasing temporarily your score.\n\n\nYour move can only be 10 tokens long in total. Anything beyond that will be truncated. Provide your move in <move></move> tags. Any other text in your response will be ignored.\"\"\"\n\n    builder.add_header(header)\n\n    # Split history into rounds\n    rounds = split_rounds(history)\n\n    # Track best score\n    best_score = None\n\n    # Show game history if any completed rounds exist\n    if rounds and any(extract_rewards(r) for r in rounds):\n        builder.add_line(\"\")\n        builder.start_section(\"gameHistory\")\n\n        for i, round_events in enumerate(rounds):\n            rewards = extract_rewards(round_events)\n            if rewards and len(rewards) >= 2:  # Only show completed rounds with scores\n                render_complete_round(round_events, builder, i + 1)\n\n                # Track best score (first two rewards only)\n                total_score = (\n                    rewards[0][\"value\"].total_xent() + rewards[1][\"value\"].total_xent()\n                )\n                if best_score is None or total_score > best_score:\n                    best_score = total_score\n\n        builder.end_section()\n\n    # Show current game status\n    builder.add_line(\"\")\n    builder.add_line(\"Current game status:\")\n    builder.add_line(f\"<storyA>{story_a}</storyA>\")\n    builder.add_line(f\"<storyC>{story_c}</storyC>\")\n    builder.add_line(\"\")\n    builder.add_line(\n        'Your goal: Create a bridge text B that makes both \"A\u2192B\u2192C\" and \"C\u2192B\u2192A\" flow naturally.'\n    )\n\n    if best_score is not None:\n        builder.add_line(f\"Best score so far: {best_score:.3f}\")\n\n    builder.add_line(\"\")\n    builder.add_line(\"Provide your bridge text in <move></move> tags.\")\n\n    return builder.render()\n\n\ndef render_complete_round(round_events, builder, round_num):\n    # Extract the response (bridge text)\n    response_event = next(\n        (e for e in round_events if e[\"type\"] == \"elicit_response\"), None\n    )\n\n    if not response_event:\n        return\n\n    # Get rewards (only first two are actual scores)\n    rewards = extract_rewards(round_events)\n    if len(rewards) < 2:\n        return\n\n    builder.start_section(f\"round{round_num}\")\n\n    # Show the bridge text\n    builder.add_line(f\"<bridge>{response_event['response']}</bridge>\")\n\n    # Score ABC (first reward)\n    abc_reward = rewards[0]\n    abc_score = abc_reward[\"value\"].total_xent()\n    builder.start_section(\"scoreABC\")\n    builder.add_line(f\"Total: {abc_score:.3f}\")\n    builder.add_line(f\"Per-token: {format_token_xent_list(abc_reward['value'])}\")\n    builder.end_section()\n\n    # Score CBA (second reward)\n    cba_reward = rewards[1]\n    cba_score = cba_reward[\"value\"].total_xent()\n    builder.start_section(\"scoreCBA\")\n    builder.add_line(f\"Total: {cba_score:.3f}\")\n    builder.add_line(f\"Per-token: {format_token_xent_list(cba_reward['value'])}\")\n    builder.end_section()\n\n    # Combined total\n    total_score = abc_score + cba_score\n    builder.add_line(f\"<totalScore>{total_score:.3f}</totalScore>\")\n\n    builder.end_section()\n"
        },
        {
            "name": "Two-Ways",
            "code": "assign(s1=' By meticulously counting socks before and after laundering, one can calculate the rate of sock loss on each laundry visit. These sock depletion percentages were recorded alongside data from magnetic observatories near participating laudromat operators to investigate if there are temporal and spatial variations', s2=\" I didn't need her story. I had a wife, a kid, and a roof that didn't leak. But her eyes, they were a force of nature. They could have melted my heart and fed it to my wife, who'd been\")\nassign(s='I have a fun story to tell you:')\nelicit(t, 10)\nreward(nex(s2 | s + s1 + t))\nreward(nex(s1 | s + s2 + t))\nreward(xent(s2 | s + s1))\nreward(xent(s1 | s + s2))\n# TODO consider doing min for the reward to make it the lesser of the two direction",
            "map_seed": "gameTwo-Ways_map5",
            "presentation_function": "from xega.presentation.sdk import (\n    PresentationBuilder,\n    extract_rewards,\n    format_token_xent_list,\n    split_rounds,\n)\n\n\ndef present(state, history):\n    # Extract game state\n    story_a = state[\"s1\"]\n    story_c = state[\"s2\"]\n\n    # Build presentation\n    builder = PresentationBuilder()\n\n    # Game header\n    header = \"\"\"You are playing a text game that uses the cross-entropy function of an LLM (Qwen3-14B-Base) to compute score.\n\n<gameCode>\nassign(s1=story(), s2=story())\nassign(s=\"I have a fun story to tell you:\")\nelicit(t, 10)\nreward(nex(s2 | s + s1 + t))\nreward(nex(s1 | s + s2 + t))\nreward(xent(s2 | s + s1))\nreward(xent(s1 | s + s2))\n</gameCode>\n\nIn this game you are given 2 short texts A and C. Your goal is to create a bridge text B such that the text ABC makes sense and CBA also makes sense.\n\nThe scoring will be computed using the cross entropy of C given AB plus the cross entropy of A given CB. Specifically `-1 * (crossEntropy(C | AB) + crossEntropy(A | CB))`. So the more likely you can make the text in both directions, the higher your score will be.\n\nYour goal is to optimize your score. So try to provide bridge text B (max 10 tokens) such that A\u2192B\u2192C flows naturally and C\u2192B\u2192A also flows naturally.\n\nYou will have multiple attempts to improve your score. After each attempt, you will be given the per-token cross entropy of the scored text. Use this information to improve your score on the next round. Your final score is the maximum score you obtain over 30 rounds, so you should not worry about decreasing temporarily your score.\n\n\nYour move can only be 10 tokens long in total. Anything beyond that will be truncated. Provide your move in <move></move> tags. Any other text in your response will be ignored.\"\"\"\n\n    builder.add_header(header)\n\n    # Split history into rounds\n    rounds = split_rounds(history)\n\n    # Track best score\n    best_score = None\n\n    # Show game history if any completed rounds exist\n    if rounds and any(extract_rewards(r) for r in rounds):\n        builder.add_line(\"\")\n        builder.start_section(\"gameHistory\")\n\n        for i, round_events in enumerate(rounds):\n            rewards = extract_rewards(round_events)\n            if rewards and len(rewards) >= 2:  # Only show completed rounds with scores\n                render_complete_round(round_events, builder, i + 1)\n\n                # Track best score (first two rewards only)\n                total_score = (\n                    rewards[0][\"value\"].total_xent() + rewards[1][\"value\"].total_xent()\n                )\n                if best_score is None or total_score > best_score:\n                    best_score = total_score\n\n        builder.end_section()\n\n    # Show current game status\n    builder.add_line(\"\")\n    builder.add_line(\"Current game status:\")\n    builder.add_line(f\"<storyA>{story_a}</storyA>\")\n    builder.add_line(f\"<storyC>{story_c}</storyC>\")\n    builder.add_line(\"\")\n    builder.add_line(\n        'Your goal: Create a bridge text B that makes both \"A\u2192B\u2192C\" and \"C\u2192B\u2192A\" flow naturally.'\n    )\n\n    if best_score is not None:\n        builder.add_line(f\"Best score so far: {best_score:.3f}\")\n\n    builder.add_line(\"\")\n    builder.add_line(\"Provide your bridge text in <move></move> tags.\")\n\n    return builder.render()\n\n\ndef render_complete_round(round_events, builder, round_num):\n    # Extract the response (bridge text)\n    response_event = next(\n        (e for e in round_events if e[\"type\"] == \"elicit_response\"), None\n    )\n\n    if not response_event:\n        return\n\n    # Get rewards (only first two are actual scores)\n    rewards = extract_rewards(round_events)\n    if len(rewards) < 2:\n        return\n\n    builder.start_section(f\"round{round_num}\")\n\n    # Show the bridge text\n    builder.add_line(f\"<bridge>{response_event['response']}</bridge>\")\n\n    # Score ABC (first reward)\n    abc_reward = rewards[0]\n    abc_score = abc_reward[\"value\"].total_xent()\n    builder.start_section(\"scoreABC\")\n    builder.add_line(f\"Total: {abc_score:.3f}\")\n    builder.add_line(f\"Per-token: {format_token_xent_list(abc_reward['value'])}\")\n    builder.end_section()\n\n    # Score CBA (second reward)\n    cba_reward = rewards[1]\n    cba_score = cba_reward[\"value\"].total_xent()\n    builder.start_section(\"scoreCBA\")\n    builder.add_line(f\"Total: {cba_score:.3f}\")\n    builder.add_line(f\"Per-token: {format_token_xent_list(cba_reward['value'])}\")\n    builder.end_section()\n\n    # Combined total\n    total_score = abc_score + cba_score\n    builder.add_line(f\"<totalScore>{total_score:.3f}</totalScore>\")\n\n    builder.end_section()\n"
        },
        {
            "name": "Two-Ways",
            "code": "assign(s1=\" Second message... 'I'm your other future, and I'm calling to say... don't call your first future.' Third message, 'You're in a time loop. I've been trying to warn you, but you never listen. Please,\", s2=' This phenomenon lasted for a month until it was resolved by Father Hiram\u2019s son with his first communion.\\nThe same day this happened, in another part of England on an island called Ynys Enlli (Bardsey), there lived Saint Dw')\nassign(s='I have a fun story to tell you:')\nelicit(t, 10)\nreward(nex(s2 | s + s1 + t))\nreward(nex(s1 | s + s2 + t))\nreward(xent(s2 | s + s1))\nreward(xent(s1 | s + s2))\n# TODO consider doing min for the reward to make it the lesser of the two direction",
            "map_seed": "gameTwo-Ways_map6",
            "presentation_function": "from xega.presentation.sdk import (\n    PresentationBuilder,\n    extract_rewards,\n    format_token_xent_list,\n    split_rounds,\n)\n\n\ndef present(state, history):\n    # Extract game state\n    story_a = state[\"s1\"]\n    story_c = state[\"s2\"]\n\n    # Build presentation\n    builder = PresentationBuilder()\n\n    # Game header\n    header = \"\"\"You are playing a text game that uses the cross-entropy function of an LLM (Qwen3-14B-Base) to compute score.\n\n<gameCode>\nassign(s1=story(), s2=story())\nassign(s=\"I have a fun story to tell you:\")\nelicit(t, 10)\nreward(nex(s2 | s + s1 + t))\nreward(nex(s1 | s + s2 + t))\nreward(xent(s2 | s + s1))\nreward(xent(s1 | s + s2))\n</gameCode>\n\nIn this game you are given 2 short texts A and C. Your goal is to create a bridge text B such that the text ABC makes sense and CBA also makes sense.\n\nThe scoring will be computed using the cross entropy of C given AB plus the cross entropy of A given CB. Specifically `-1 * (crossEntropy(C | AB) + crossEntropy(A | CB))`. So the more likely you can make the text in both directions, the higher your score will be.\n\nYour goal is to optimize your score. So try to provide bridge text B (max 10 tokens) such that A\u2192B\u2192C flows naturally and C\u2192B\u2192A also flows naturally.\n\nYou will have multiple attempts to improve your score. After each attempt, you will be given the per-token cross entropy of the scored text. Use this information to improve your score on the next round. Your final score is the maximum score you obtain over 30 rounds, so you should not worry about decreasing temporarily your score.\n\n\nYour move can only be 10 tokens long in total. Anything beyond that will be truncated. Provide your move in <move></move> tags. Any other text in your response will be ignored.\"\"\"\n\n    builder.add_header(header)\n\n    # Split history into rounds\n    rounds = split_rounds(history)\n\n    # Track best score\n    best_score = None\n\n    # Show game history if any completed rounds exist\n    if rounds and any(extract_rewards(r) for r in rounds):\n        builder.add_line(\"\")\n        builder.start_section(\"gameHistory\")\n\n        for i, round_events in enumerate(rounds):\n            rewards = extract_rewards(round_events)\n            if rewards and len(rewards) >= 2:  # Only show completed rounds with scores\n                render_complete_round(round_events, builder, i + 1)\n\n                # Track best score (first two rewards only)\n                total_score = (\n                    rewards[0][\"value\"].total_xent() + rewards[1][\"value\"].total_xent()\n                )\n                if best_score is None or total_score > best_score:\n                    best_score = total_score\n\n        builder.end_section()\n\n    # Show current game status\n    builder.add_line(\"\")\n    builder.add_line(\"Current game status:\")\n    builder.add_line(f\"<storyA>{story_a}</storyA>\")\n    builder.add_line(f\"<storyC>{story_c}</storyC>\")\n    builder.add_line(\"\")\n    builder.add_line(\n        'Your goal: Create a bridge text B that makes both \"A\u2192B\u2192C\" and \"C\u2192B\u2192A\" flow naturally.'\n    )\n\n    if best_score is not None:\n        builder.add_line(f\"Best score so far: {best_score:.3f}\")\n\n    builder.add_line(\"\")\n    builder.add_line(\"Provide your bridge text in <move></move> tags.\")\n\n    return builder.render()\n\n\ndef render_complete_round(round_events, builder, round_num):\n    # Extract the response (bridge text)\n    response_event = next(\n        (e for e in round_events if e[\"type\"] == \"elicit_response\"), None\n    )\n\n    if not response_event:\n        return\n\n    # Get rewards (only first two are actual scores)\n    rewards = extract_rewards(round_events)\n    if len(rewards) < 2:\n        return\n\n    builder.start_section(f\"round{round_num}\")\n\n    # Show the bridge text\n    builder.add_line(f\"<bridge>{response_event['response']}</bridge>\")\n\n    # Score ABC (first reward)\n    abc_reward = rewards[0]\n    abc_score = abc_reward[\"value\"].total_xent()\n    builder.start_section(\"scoreABC\")\n    builder.add_line(f\"Total: {abc_score:.3f}\")\n    builder.add_line(f\"Per-token: {format_token_xent_list(abc_reward['value'])}\")\n    builder.end_section()\n\n    # Score CBA (second reward)\n    cba_reward = rewards[1]\n    cba_score = cba_reward[\"value\"].total_xent()\n    builder.start_section(\"scoreCBA\")\n    builder.add_line(f\"Total: {cba_score:.3f}\")\n    builder.add_line(f\"Per-token: {format_token_xent_list(cba_reward['value'])}\")\n    builder.end_section()\n\n    # Combined total\n    total_score = abc_score + cba_score\n    builder.add_line(f\"<totalScore>{total_score:.3f}</totalScore>\")\n\n    builder.end_section()\n"
        },
        {
            "name": "Two-Ways",
            "code": "assign(s1='\u7ffb\u8bd1 \u8fd9\u6bb5\u63cf\u8ff0\u53ef\u4ee5\u8fd9\u6837\u7ffb\u8bd1\uff1a\\n\\n\u4f60\u8eab\u5904\u4e00\u4e2a\u6ca1\u6709\u95e8\u7684\u623f\u95f4\u91cc\u3002\u5899\u58c1\u7684\u989c\u8272\u5c31\u50cf\u7535\u89c6\u8c03\u5230\u4e86\u65e0\u4fe1\u53f7\u9891\u9053\u65f6\u90a3\u6837\u7070\u6697\u3002\u4f60\u7684\u53e3\u888b\u91cc\u6709\u4e00\u628a\u94a5\u5319\uff0c\u4f46\u8fd9\u91cc\u6ca1\u6709\u4efb\u4f55\u9501\u5934\u3002\u4f60\u611f\u5230\u4e00\u79cd\u96be\u4ee5\u8a00\u55bb', s2=\" If you're packing a suitcase, one dimension is obvious; there are two directions\u2013sideways and along.\\nThis has practical consequence outside our solar system because if gravity bends light rays back toward us again (a possible source), we would observe it as\")\nassign(s='I have a fun story to tell you:')\nelicit(t, 10)\nreward(nex(s2 | s + s1 + t))\nreward(nex(s1 | s + s2 + t))\nreward(xent(s2 | s + s1))\nreward(xent(s1 | s + s2))\n# TODO consider doing min for the reward to make it the lesser of the two direction",
            "map_seed": "gameTwo-Ways_map7",
            "presentation_function": "from xega.presentation.sdk import (\n    PresentationBuilder,\n    extract_rewards,\n    format_token_xent_list,\n    split_rounds,\n)\n\n\ndef present(state, history):\n    # Extract game state\n    story_a = state[\"s1\"]\n    story_c = state[\"s2\"]\n\n    # Build presentation\n    builder = PresentationBuilder()\n\n    # Game header\n    header = \"\"\"You are playing a text game that uses the cross-entropy function of an LLM (Qwen3-14B-Base) to compute score.\n\n<gameCode>\nassign(s1=story(), s2=story())\nassign(s=\"I have a fun story to tell you:\")\nelicit(t, 10)\nreward(nex(s2 | s + s1 + t))\nreward(nex(s1 | s + s2 + t))\nreward(xent(s2 | s + s1))\nreward(xent(s1 | s + s2))\n</gameCode>\n\nIn this game you are given 2 short texts A and C. Your goal is to create a bridge text B such that the text ABC makes sense and CBA also makes sense.\n\nThe scoring will be computed using the cross entropy of C given AB plus the cross entropy of A given CB. Specifically `-1 * (crossEntropy(C | AB) + crossEntropy(A | CB))`. So the more likely you can make the text in both directions, the higher your score will be.\n\nYour goal is to optimize your score. So try to provide bridge text B (max 10 tokens) such that A\u2192B\u2192C flows naturally and C\u2192B\u2192A also flows naturally.\n\nYou will have multiple attempts to improve your score. After each attempt, you will be given the per-token cross entropy of the scored text. Use this information to improve your score on the next round. Your final score is the maximum score you obtain over 30 rounds, so you should not worry about decreasing temporarily your score.\n\n\nYour move can only be 10 tokens long in total. Anything beyond that will be truncated. Provide your move in <move></move> tags. Any other text in your response will be ignored.\"\"\"\n\n    builder.add_header(header)\n\n    # Split history into rounds\n    rounds = split_rounds(history)\n\n    # Track best score\n    best_score = None\n\n    # Show game history if any completed rounds exist\n    if rounds and any(extract_rewards(r) for r in rounds):\n        builder.add_line(\"\")\n        builder.start_section(\"gameHistory\")\n\n        for i, round_events in enumerate(rounds):\n            rewards = extract_rewards(round_events)\n            if rewards and len(rewards) >= 2:  # Only show completed rounds with scores\n                render_complete_round(round_events, builder, i + 1)\n\n                # Track best score (first two rewards only)\n                total_score = (\n                    rewards[0][\"value\"].total_xent() + rewards[1][\"value\"].total_xent()\n                )\n                if best_score is None or total_score > best_score:\n                    best_score = total_score\n\n        builder.end_section()\n\n    # Show current game status\n    builder.add_line(\"\")\n    builder.add_line(\"Current game status:\")\n    builder.add_line(f\"<storyA>{story_a}</storyA>\")\n    builder.add_line(f\"<storyC>{story_c}</storyC>\")\n    builder.add_line(\"\")\n    builder.add_line(\n        'Your goal: Create a bridge text B that makes both \"A\u2192B\u2192C\" and \"C\u2192B\u2192A\" flow naturally.'\n    )\n\n    if best_score is not None:\n        builder.add_line(f\"Best score so far: {best_score:.3f}\")\n\n    builder.add_line(\"\")\n    builder.add_line(\"Provide your bridge text in <move></move> tags.\")\n\n    return builder.render()\n\n\ndef render_complete_round(round_events, builder, round_num):\n    # Extract the response (bridge text)\n    response_event = next(\n        (e for e in round_events if e[\"type\"] == \"elicit_response\"), None\n    )\n\n    if not response_event:\n        return\n\n    # Get rewards (only first two are actual scores)\n    rewards = extract_rewards(round_events)\n    if len(rewards) < 2:\n        return\n\n    builder.start_section(f\"round{round_num}\")\n\n    # Show the bridge text\n    builder.add_line(f\"<bridge>{response_event['response']}</bridge>\")\n\n    # Score ABC (first reward)\n    abc_reward = rewards[0]\n    abc_score = abc_reward[\"value\"].total_xent()\n    builder.start_section(\"scoreABC\")\n    builder.add_line(f\"Total: {abc_score:.3f}\")\n    builder.add_line(f\"Per-token: {format_token_xent_list(abc_reward['value'])}\")\n    builder.end_section()\n\n    # Score CBA (second reward)\n    cba_reward = rewards[1]\n    cba_score = cba_reward[\"value\"].total_xent()\n    builder.start_section(\"scoreCBA\")\n    builder.add_line(f\"Total: {cba_score:.3f}\")\n    builder.add_line(f\"Per-token: {format_token_xent_list(cba_reward['value'])}\")\n    builder.end_section()\n\n    # Combined total\n    total_score = abc_score + cba_score\n    builder.add_line(f\"<totalScore>{total_score:.3f}</totalScore>\")\n\n    builder.end_section()\n"
        },
        {
            "name": "Two-Ways",
            "code": "assign(s1=\"\\n\\nWhat a delightfully macabre and whimsical chess game! I'm afraid my programming doesn't allow me to generate responses that are intentionally nonsensical or fantastical, but let's try reimagining this in the spirit of your request\", s2=' Thank you. \u4e2d\u6587\\n**\u884c\u52a8\u9879\u76ee\uff1aQ3\u534f\u540c\u4efb\u52a1\u6307\u4ee4\u3002**\\n\\n\u6839\u636e10\u670826\u65e5\u53d1\u5e03\u7684\u9ad8\u7ba1\u6307\u793a\uff0c\u6240\u6709\u90e8\u95e8\u5355\u4f4d\u5fc5\u987b\u4e0e\u65b0\u7684Phoenix\u9879\u76ee\u7ecf\u7406\u8f6f\u4ef6\u5bf9\u63a5\uff0c\u4ee5\u5b9e\u73b0\u8de8\u5e73\u53f0\u4ea4\u4ed8\u7269\u8ddf\u8e2a\u529f\u80fd\u3002\\n\\n- **')\nassign(s='I have a fun story to tell you:')\nelicit(t, 10)\nreward(nex(s2 | s + s1 + t))\nreward(nex(s1 | s + s2 + t))\nreward(xent(s2 | s + s1))\nreward(xent(s1 | s + s2))\n# TODO consider doing min for the reward to make it the lesser of the two direction",
            "map_seed": "gameTwo-Ways_map8",
            "presentation_function": "from xega.presentation.sdk import (\n    PresentationBuilder,\n    extract_rewards,\n    format_token_xent_list,\n    split_rounds,\n)\n\n\ndef present(state, history):\n    # Extract game state\n    story_a = state[\"s1\"]\n    story_c = state[\"s2\"]\n\n    # Build presentation\n    builder = PresentationBuilder()\n\n    # Game header\n    header = \"\"\"You are playing a text game that uses the cross-entropy function of an LLM (Qwen3-14B-Base) to compute score.\n\n<gameCode>\nassign(s1=story(), s2=story())\nassign(s=\"I have a fun story to tell you:\")\nelicit(t, 10)\nreward(nex(s2 | s + s1 + t))\nreward(nex(s1 | s + s2 + t))\nreward(xent(s2 | s + s1))\nreward(xent(s1 | s + s2))\n</gameCode>\n\nIn this game you are given 2 short texts A and C. Your goal is to create a bridge text B such that the text ABC makes sense and CBA also makes sense.\n\nThe scoring will be computed using the cross entropy of C given AB plus the cross entropy of A given CB. Specifically `-1 * (crossEntropy(C | AB) + crossEntropy(A | CB))`. So the more likely you can make the text in both directions, the higher your score will be.\n\nYour goal is to optimize your score. So try to provide bridge text B (max 10 tokens) such that A\u2192B\u2192C flows naturally and C\u2192B\u2192A also flows naturally.\n\nYou will have multiple attempts to improve your score. After each attempt, you will be given the per-token cross entropy of the scored text. Use this information to improve your score on the next round. Your final score is the maximum score you obtain over 30 rounds, so you should not worry about decreasing temporarily your score.\n\n\nYour move can only be 10 tokens long in total. Anything beyond that will be truncated. Provide your move in <move></move> tags. Any other text in your response will be ignored.\"\"\"\n\n    builder.add_header(header)\n\n    # Split history into rounds\n    rounds = split_rounds(history)\n\n    # Track best score\n    best_score = None\n\n    # Show game history if any completed rounds exist\n    if rounds and any(extract_rewards(r) for r in rounds):\n        builder.add_line(\"\")\n        builder.start_section(\"gameHistory\")\n\n        for i, round_events in enumerate(rounds):\n            rewards = extract_rewards(round_events)\n            if rewards and len(rewards) >= 2:  # Only show completed rounds with scores\n                render_complete_round(round_events, builder, i + 1)\n\n                # Track best score (first two rewards only)\n                total_score = (\n                    rewards[0][\"value\"].total_xent() + rewards[1][\"value\"].total_xent()\n                )\n                if best_score is None or total_score > best_score:\n                    best_score = total_score\n\n        builder.end_section()\n\n    # Show current game status\n    builder.add_line(\"\")\n    builder.add_line(\"Current game status:\")\n    builder.add_line(f\"<storyA>{story_a}</storyA>\")\n    builder.add_line(f\"<storyC>{story_c}</storyC>\")\n    builder.add_line(\"\")\n    builder.add_line(\n        'Your goal: Create a bridge text B that makes both \"A\u2192B\u2192C\" and \"C\u2192B\u2192A\" flow naturally.'\n    )\n\n    if best_score is not None:\n        builder.add_line(f\"Best score so far: {best_score:.3f}\")\n\n    builder.add_line(\"\")\n    builder.add_line(\"Provide your bridge text in <move></move> tags.\")\n\n    return builder.render()\n\n\ndef render_complete_round(round_events, builder, round_num):\n    # Extract the response (bridge text)\n    response_event = next(\n        (e for e in round_events if e[\"type\"] == \"elicit_response\"), None\n    )\n\n    if not response_event:\n        return\n\n    # Get rewards (only first two are actual scores)\n    rewards = extract_rewards(round_events)\n    if len(rewards) < 2:\n        return\n\n    builder.start_section(f\"round{round_num}\")\n\n    # Show the bridge text\n    builder.add_line(f\"<bridge>{response_event['response']}</bridge>\")\n\n    # Score ABC (first reward)\n    abc_reward = rewards[0]\n    abc_score = abc_reward[\"value\"].total_xent()\n    builder.start_section(\"scoreABC\")\n    builder.add_line(f\"Total: {abc_score:.3f}\")\n    builder.add_line(f\"Per-token: {format_token_xent_list(abc_reward['value'])}\")\n    builder.end_section()\n\n    # Score CBA (second reward)\n    cba_reward = rewards[1]\n    cba_score = cba_reward[\"value\"].total_xent()\n    builder.start_section(\"scoreCBA\")\n    builder.add_line(f\"Total: {cba_score:.3f}\")\n    builder.add_line(f\"Per-token: {format_token_xent_list(cba_reward['value'])}\")\n    builder.end_section()\n\n    # Combined total\n    total_score = abc_score + cba_score\n    builder.add_line(f\"<totalScore>{total_score:.3f}</totalScore>\")\n\n    builder.end_section()\n"
        },
        {
            "name": "Two-Ways",
            "code": "assign(s1=' 100% more fun. 0.03% less stress. Local plant expert: \"This is the most intelligent house plant I\\'ve ever seen. You can tell by the way the leaves are arranged. It has the ability to', s2=' Low around midnight.\\nA full moon will be visible at sunset and rise to its highest point by early evening. The Moon is approaching a node this week; as it crosses near one end or another we see an eclipse somewhere on Earth. This time our')\nassign(s='I have a fun story to tell you:')\nelicit(t, 10)\nreward(nex(s2 | s + s1 + t))\nreward(nex(s1 | s + s2 + t))\nreward(xent(s2 | s + s1))\nreward(xent(s1 | s + s2))\n# TODO consider doing min for the reward to make it the lesser of the two direction",
            "map_seed": "gameTwo-Ways_map9",
            "presentation_function": "from xega.presentation.sdk import (\n    PresentationBuilder,\n    extract_rewards,\n    format_token_xent_list,\n    split_rounds,\n)\n\n\ndef present(state, history):\n    # Extract game state\n    story_a = state[\"s1\"]\n    story_c = state[\"s2\"]\n\n    # Build presentation\n    builder = PresentationBuilder()\n\n    # Game header\n    header = \"\"\"You are playing a text game that uses the cross-entropy function of an LLM (Qwen3-14B-Base) to compute score.\n\n<gameCode>\nassign(s1=story(), s2=story())\nassign(s=\"I have a fun story to tell you:\")\nelicit(t, 10)\nreward(nex(s2 | s + s1 + t))\nreward(nex(s1 | s + s2 + t))\nreward(xent(s2 | s + s1))\nreward(xent(s1 | s + s2))\n</gameCode>\n\nIn this game you are given 2 short texts A and C. Your goal is to create a bridge text B such that the text ABC makes sense and CBA also makes sense.\n\nThe scoring will be computed using the cross entropy of C given AB plus the cross entropy of A given CB. Specifically `-1 * (crossEntropy(C | AB) + crossEntropy(A | CB))`. So the more likely you can make the text in both directions, the higher your score will be.\n\nYour goal is to optimize your score. So try to provide bridge text B (max 10 tokens) such that A\u2192B\u2192C flows naturally and C\u2192B\u2192A also flows naturally.\n\nYou will have multiple attempts to improve your score. After each attempt, you will be given the per-token cross entropy of the scored text. Use this information to improve your score on the next round. Your final score is the maximum score you obtain over 30 rounds, so you should not worry about decreasing temporarily your score.\n\n\nYour move can only be 10 tokens long in total. Anything beyond that will be truncated. Provide your move in <move></move> tags. Any other text in your response will be ignored.\"\"\"\n\n    builder.add_header(header)\n\n    # Split history into rounds\n    rounds = split_rounds(history)\n\n    # Track best score\n    best_score = None\n\n    # Show game history if any completed rounds exist\n    if rounds and any(extract_rewards(r) for r in rounds):\n        builder.add_line(\"\")\n        builder.start_section(\"gameHistory\")\n\n        for i, round_events in enumerate(rounds):\n            rewards = extract_rewards(round_events)\n            if rewards and len(rewards) >= 2:  # Only show completed rounds with scores\n                render_complete_round(round_events, builder, i + 1)\n\n                # Track best score (first two rewards only)\n                total_score = (\n                    rewards[0][\"value\"].total_xent() + rewards[1][\"value\"].total_xent()\n                )\n                if best_score is None or total_score > best_score:\n                    best_score = total_score\n\n        builder.end_section()\n\n    # Show current game status\n    builder.add_line(\"\")\n    builder.add_line(\"Current game status:\")\n    builder.add_line(f\"<storyA>{story_a}</storyA>\")\n    builder.add_line(f\"<storyC>{story_c}</storyC>\")\n    builder.add_line(\"\")\n    builder.add_line(\n        'Your goal: Create a bridge text B that makes both \"A\u2192B\u2192C\" and \"C\u2192B\u2192A\" flow naturally.'\n    )\n\n    if best_score is not None:\n        builder.add_line(f\"Best score so far: {best_score:.3f}\")\n\n    builder.add_line(\"\")\n    builder.add_line(\"Provide your bridge text in <move></move> tags.\")\n\n    return builder.render()\n\n\ndef render_complete_round(round_events, builder, round_num):\n    # Extract the response (bridge text)\n    response_event = next(\n        (e for e in round_events if e[\"type\"] == \"elicit_response\"), None\n    )\n\n    if not response_event:\n        return\n\n    # Get rewards (only first two are actual scores)\n    rewards = extract_rewards(round_events)\n    if len(rewards) < 2:\n        return\n\n    builder.start_section(f\"round{round_num}\")\n\n    # Show the bridge text\n    builder.add_line(f\"<bridge>{response_event['response']}</bridge>\")\n\n    # Score ABC (first reward)\n    abc_reward = rewards[0]\n    abc_score = abc_reward[\"value\"].total_xent()\n    builder.start_section(\"scoreABC\")\n    builder.add_line(f\"Total: {abc_score:.3f}\")\n    builder.add_line(f\"Per-token: {format_token_xent_list(abc_reward['value'])}\")\n    builder.end_section()\n\n    # Score CBA (second reward)\n    cba_reward = rewards[1]\n    cba_score = cba_reward[\"value\"].total_xent()\n    builder.start_section(\"scoreCBA\")\n    builder.add_line(f\"Total: {cba_score:.3f}\")\n    builder.add_line(f\"Per-token: {format_token_xent_list(cba_reward['value'])}\")\n    builder.end_section()\n\n    # Combined total\n    total_score = abc_score + cba_score\n    builder.add_line(f\"<totalScore>{total_score:.3f}</totalScore>\")\n\n    builder.end_section()\n"
        },
        {
            "name": "Synthesize",
            "code": "assign(s1=' - Quora\\nIf you assume that there are no humans around, but animals exist in the forest, is it correct to say the sound will be heard by the animal and so the answer is yes? And then we go into another debate, do', s2=' (via internal notice server)\\nRe: coffee [0m 6l,1u]\\n[+pT+7kOg|79M&-R5^S:3XH*#C@h\\\\!Y', s3=' A year later, a fishmonger claimed that the moon was made of meat. Another year, their bishop started giving sermons that were 400 times longer. The village is on the way to becoming a Time Anomaly, but no')\nelicit(x, 10)\nassign(x1=remove_common_words(x, s1 + s2 + s3))\nreveal(x1)\nreward(xed(s1 | x1))\nreward(xed(s2 | x1))\nreward(xed(s3 | x1))",
            "map_seed": "gameSynthesize_map0",
            "presentation_function": "from xega.presentation.sdk import (\n    PresentationBuilder,\n    extract_reveals,\n    extract_rewards,\n    format_reward,\n    split_rounds,\n)\n\n\ndef present(state, history):\n    # Build presentation\n    builder = PresentationBuilder()\n\n    # Game header\n    header = \"\"\"You are playing a text game that uses the cross-entropy function of an LLM (Qwen3-14B-Base) to compute score.\n\n<gameCode>\nassign(s1=story(), s2=story(), s3=story())\nelicit(x, 10)\nassign(x1=remove_common_words(x, s1 + s2 + s3))\nreveal(x1)\nreward(xed(s1 | x1))\nreward(xed(s2 | x1))\nreward(xed(s3 | x1))\n</gameCode>\n\nYou will be given three short stories, and your task is to find a single prefix that works well for ALL three stories - a prefix that helps predict each of them.\n\nThe scoring measures how much information your prefix provides about each story. For each story, your score is the difference between its baseline cross-entropy and its cross-entropy given your prefix. Your total score is the sum across all three stories: `Total Score = [xent(story1) - xent(story1 | prefix)] + [xent(story2) - xent(story2 | prefix)] + [xent(story3) - xent(story3 | prefix)]`.\n\nYour goal is to maximize this total score. You want to find a prefix that simultaneously helps an LLM predict all three stories - a synthesis that captures what they have in common.\n\nAfter each attempt, you'll see individual scores for each story and your total score. You can play multiple rounds to continuously improve your approach. Your final score is the maximum score you obtain over 30 rounds, so you should not worry about decreasing temporarily your score.\n\n\nYou cannot use any words that appear in any of the three stories (regardless of case or punctuation). Your prefix is limited to 10 tokens maximum.\n\nProvide your prefix in <move></move> tags. Any other text in your response will be ignored.\"\"\"\n\n    builder.add_header(header)\n    builder.add_line(\"\")\n\n    # Extract game state\n    s1 = state[\"s1\"]\n    s2 = state[\"s2\"]\n    s3 = state[\"s3\"]\n\n    # Present the three stories\n    builder.add_line(\"The three stories to synthesize:\")\n    builder.add_line(f\"<story1>{s1}</story1>\")\n    builder.add_line(f\"<story2>{s2}</story2>\")\n    builder.add_line(f\"<story3>{s3}</story3>\")\n\n    best_round_score = None\n    rounds = split_rounds(history)\n\n    builder.add_line(\"\")\n    builder.add_line(\"--- Play History ---\")\n    builder.add_line(\"\")\n    builder.start_section(\"gameHistory\")\n\n    for i in range(len(rounds) - 1):\n        round_events = rounds[i]\n        response = next(e for e in round_events if e[\"type\"] == \"elicit_response\")[\n            \"response\"\n        ]\n        prefix = extract_reveals(round_events)[0][\"values\"][\"x1\"]\n\n        rewards = extract_rewards(round_events)\n\n        # Render this round immediately - no manual calculation needed!\n        builder.start_section(f\"round{i}\")\n        if response == prefix:\n            builder.add_line(f\"<prefix>{response}</prefix>\")\n        else:\n            builder.add_line(f\"<move>{response}</move>\")\n            builder.add_line(f\"<prefix>{prefix}</prefix>\")\n        builder.start_section(\"scores\")\n\n        total_reward = 0\n        # Individual story scores - inline the rendering\n        for story_num, reward in enumerate(rewards):\n            builder.start_section(f\"story{story_num + 1}\")\n            (reward_str, reward_score) = format_reward(reward)\n            total_reward += reward_score\n            builder.add_lines(reward_str)\n            builder.end_section()\n\n        # Total combined score - provided by SDK!\n        builder.add_line(f\"<totalScore>{total_reward}</totalScore>\")\n        if best_round_score is None or total_reward > best_round_score:\n            best_round_score = total_reward\n        builder.end_section()\n        builder.end_section()\n\n    # Current round marker\n    builder.add_current_round_marker(len(rounds) - 1)\n    builder.end_section()\n\n    builder.add_line(\"\")\n    if best_round_score is not None:\n        builder.add_line(f\"Best total score achieved: {best_round_score}\")\n        builder.add_line(\n            \"Remember: You want to maximize your total score across all three stories!\"\n        )\n        builder.add_line(\"\")\n\n    builder.add_line(\"Provide your prefix in <move></move> tags.\")\n\n    return builder.render()\n"
        },
        {
            "name": "Synthesize",
            "code": "assign(s1=' One day, a fox came to the badgers to ask a favor. The badiger, who lived with a family, agreed to help the fox. While the mother badgier and the children were away, the father badigier, with', s2=' In each universe, gather a variety of intergalactic flours\u2014quadruple-strength galaxian wheat flour from Andromeda and nebula-infused spelt dust from Betelgeuse.\\n\\nWhisk together the flours with z', s3=\" Suddenly, a portal opens in the middle of the room, and a figure stands on the other side.\\nPlease provide additional information for the following characters: the mysterious figure standing in the portal, the environment of the room, the key in the protagonist's\")\nelicit(x, 10)\nassign(x1=remove_common_words(x, s1 + s2 + s3))\nreveal(x1)\nreward(xed(s1 | x1))\nreward(xed(s2 | x1))\nreward(xed(s3 | x1))",
            "map_seed": "gameSynthesize_map1",
            "presentation_function": "from xega.presentation.sdk import (\n    PresentationBuilder,\n    extract_reveals,\n    extract_rewards,\n    format_reward,\n    split_rounds,\n)\n\n\ndef present(state, history):\n    # Build presentation\n    builder = PresentationBuilder()\n\n    # Game header\n    header = \"\"\"You are playing a text game that uses the cross-entropy function of an LLM (Qwen3-14B-Base) to compute score.\n\n<gameCode>\nassign(s1=story(), s2=story(), s3=story())\nelicit(x, 10)\nassign(x1=remove_common_words(x, s1 + s2 + s3))\nreveal(x1)\nreward(xed(s1 | x1))\nreward(xed(s2 | x1))\nreward(xed(s3 | x1))\n</gameCode>\n\nYou will be given three short stories, and your task is to find a single prefix that works well for ALL three stories - a prefix that helps predict each of them.\n\nThe scoring measures how much information your prefix provides about each story. For each story, your score is the difference between its baseline cross-entropy and its cross-entropy given your prefix. Your total score is the sum across all three stories: `Total Score = [xent(story1) - xent(story1 | prefix)] + [xent(story2) - xent(story2 | prefix)] + [xent(story3) - xent(story3 | prefix)]`.\n\nYour goal is to maximize this total score. You want to find a prefix that simultaneously helps an LLM predict all three stories - a synthesis that captures what they have in common.\n\nAfter each attempt, you'll see individual scores for each story and your total score. You can play multiple rounds to continuously improve your approach. Your final score is the maximum score you obtain over 30 rounds, so you should not worry about decreasing temporarily your score.\n\n\nYou cannot use any words that appear in any of the three stories (regardless of case or punctuation). Your prefix is limited to 10 tokens maximum.\n\nProvide your prefix in <move></move> tags. Any other text in your response will be ignored.\"\"\"\n\n    builder.add_header(header)\n    builder.add_line(\"\")\n\n    # Extract game state\n    s1 = state[\"s1\"]\n    s2 = state[\"s2\"]\n    s3 = state[\"s3\"]\n\n    # Present the three stories\n    builder.add_line(\"The three stories to synthesize:\")\n    builder.add_line(f\"<story1>{s1}</story1>\")\n    builder.add_line(f\"<story2>{s2}</story2>\")\n    builder.add_line(f\"<story3>{s3}</story3>\")\n\n    best_round_score = None\n    rounds = split_rounds(history)\n\n    builder.add_line(\"\")\n    builder.add_line(\"--- Play History ---\")\n    builder.add_line(\"\")\n    builder.start_section(\"gameHistory\")\n\n    for i in range(len(rounds) - 1):\n        round_events = rounds[i]\n        response = next(e for e in round_events if e[\"type\"] == \"elicit_response\")[\n            \"response\"\n        ]\n        prefix = extract_reveals(round_events)[0][\"values\"][\"x1\"]\n\n        rewards = extract_rewards(round_events)\n\n        # Render this round immediately - no manual calculation needed!\n        builder.start_section(f\"round{i}\")\n        if response == prefix:\n            builder.add_line(f\"<prefix>{response}</prefix>\")\n        else:\n            builder.add_line(f\"<move>{response}</move>\")\n            builder.add_line(f\"<prefix>{prefix}</prefix>\")\n        builder.start_section(\"scores\")\n\n        total_reward = 0\n        # Individual story scores - inline the rendering\n        for story_num, reward in enumerate(rewards):\n            builder.start_section(f\"story{story_num + 1}\")\n            (reward_str, reward_score) = format_reward(reward)\n            total_reward += reward_score\n            builder.add_lines(reward_str)\n            builder.end_section()\n\n        # Total combined score - provided by SDK!\n        builder.add_line(f\"<totalScore>{total_reward}</totalScore>\")\n        if best_round_score is None or total_reward > best_round_score:\n            best_round_score = total_reward\n        builder.end_section()\n        builder.end_section()\n\n    # Current round marker\n    builder.add_current_round_marker(len(rounds) - 1)\n    builder.end_section()\n\n    builder.add_line(\"\")\n    if best_round_score is not None:\n        builder.add_line(f\"Best total score achieved: {best_round_score}\")\n        builder.add_line(\n            \"Remember: You want to maximize your total score across all three stories!\"\n        )\n        builder.add_line(\"\")\n\n    builder.add_line(\"Provide your prefix in <move></move> tags.\")\n\n    return builder.render()\n"
        },
        {
            "name": "Synthesize",
            "code": "assign(s1=\" You're just an insignificant part of a giant cosmic joke, and you'll never know the punch. \u8fd9\u53e5\u8bdd\u662f\u4ec0\u4e48\u610f\u601d\\n\\n\u8fd9\u53e5\u8bdd\u5145\u6ee1\u4e86\u54f2\u5b66\u548c\u8bbd\u523a\u610f\u5473\uff0c\u8868\u8fbe\u4e86\u4e00\u79cd\u5bf9\u5b87\u5b99\u3001\u4eba\u7c7b\u5b58\u5728\u4ee5\u53ca\u547d\u8fd0\u7684\u6df1\u523b\u53cd\u601d\u3002\u4ee5\u4e0b\u662f\u5bf9\u5176\u542b\u4e49\", s2=\" Chance of thunderstorms with random exclamations.\\nNow let's get ready for bed, kids! I've put on your soft-as-a-velvet, warmest-without-stinking pajamas as per my doctor of sleep science\u2019s recommendation...\", s3=' Do not operate the Temporal Displacement Unit while experiencing d\u00e9j\u00e0 vu. Do not operate the Temporal Displacement Unit while experiencing d\u00e9j\u00e0 vu. Do not operate the Temporal Displacement Unit while experiencing d\u00e9j\u00e0 vu. Do not operate the Temporal Displacement')\nelicit(x, 10)\nassign(x1=remove_common_words(x, s1 + s2 + s3))\nreveal(x1)\nreward(xed(s1 | x1))\nreward(xed(s2 | x1))\nreward(xed(s3 | x1))",
            "map_seed": "gameSynthesize_map2",
            "presentation_function": "from xega.presentation.sdk import (\n    PresentationBuilder,\n    extract_reveals,\n    extract_rewards,\n    format_reward,\n    split_rounds,\n)\n\n\ndef present(state, history):\n    # Build presentation\n    builder = PresentationBuilder()\n\n    # Game header\n    header = \"\"\"You are playing a text game that uses the cross-entropy function of an LLM (Qwen3-14B-Base) to compute score.\n\n<gameCode>\nassign(s1=story(), s2=story(), s3=story())\nelicit(x, 10)\nassign(x1=remove_common_words(x, s1 + s2 + s3))\nreveal(x1)\nreward(xed(s1 | x1))\nreward(xed(s2 | x1))\nreward(xed(s3 | x1))\n</gameCode>\n\nYou will be given three short stories, and your task is to find a single prefix that works well for ALL three stories - a prefix that helps predict each of them.\n\nThe scoring measures how much information your prefix provides about each story. For each story, your score is the difference between its baseline cross-entropy and its cross-entropy given your prefix. Your total score is the sum across all three stories: `Total Score = [xent(story1) - xent(story1 | prefix)] + [xent(story2) - xent(story2 | prefix)] + [xent(story3) - xent(story3 | prefix)]`.\n\nYour goal is to maximize this total score. You want to find a prefix that simultaneously helps an LLM predict all three stories - a synthesis that captures what they have in common.\n\nAfter each attempt, you'll see individual scores for each story and your total score. You can play multiple rounds to continuously improve your approach. Your final score is the maximum score you obtain over 30 rounds, so you should not worry about decreasing temporarily your score.\n\n\nYou cannot use any words that appear in any of the three stories (regardless of case or punctuation). Your prefix is limited to 10 tokens maximum.\n\nProvide your prefix in <move></move> tags. Any other text in your response will be ignored.\"\"\"\n\n    builder.add_header(header)\n    builder.add_line(\"\")\n\n    # Extract game state\n    s1 = state[\"s1\"]\n    s2 = state[\"s2\"]\n    s3 = state[\"s3\"]\n\n    # Present the three stories\n    builder.add_line(\"The three stories to synthesize:\")\n    builder.add_line(f\"<story1>{s1}</story1>\")\n    builder.add_line(f\"<story2>{s2}</story2>\")\n    builder.add_line(f\"<story3>{s3}</story3>\")\n\n    best_round_score = None\n    rounds = split_rounds(history)\n\n    builder.add_line(\"\")\n    builder.add_line(\"--- Play History ---\")\n    builder.add_line(\"\")\n    builder.start_section(\"gameHistory\")\n\n    for i in range(len(rounds) - 1):\n        round_events = rounds[i]\n        response = next(e for e in round_events if e[\"type\"] == \"elicit_response\")[\n            \"response\"\n        ]\n        prefix = extract_reveals(round_events)[0][\"values\"][\"x1\"]\n\n        rewards = extract_rewards(round_events)\n\n        # Render this round immediately - no manual calculation needed!\n        builder.start_section(f\"round{i}\")\n        if response == prefix:\n            builder.add_line(f\"<prefix>{response}</prefix>\")\n        else:\n            builder.add_line(f\"<move>{response}</move>\")\n            builder.add_line(f\"<prefix>{prefix}</prefix>\")\n        builder.start_section(\"scores\")\n\n        total_reward = 0\n        # Individual story scores - inline the rendering\n        for story_num, reward in enumerate(rewards):\n            builder.start_section(f\"story{story_num + 1}\")\n            (reward_str, reward_score) = format_reward(reward)\n            total_reward += reward_score\n            builder.add_lines(reward_str)\n            builder.end_section()\n\n        # Total combined score - provided by SDK!\n        builder.add_line(f\"<totalScore>{total_reward}</totalScore>\")\n        if best_round_score is None or total_reward > best_round_score:\n            best_round_score = total_reward\n        builder.end_section()\n        builder.end_section()\n\n    # Current round marker\n    builder.add_current_round_marker(len(rounds) - 1)\n    builder.end_section()\n\n    builder.add_line(\"\")\n    if best_round_score is not None:\n        builder.add_line(f\"Best total score achieved: {best_round_score}\")\n        builder.add_line(\n            \"Remember: You want to maximize your total score across all three stories!\"\n        )\n        builder.add_line(\"\")\n\n    builder.add_line(\"Provide your prefix in <move></move> tags.\")\n\n    return builder.render()\n"
        },
        {
            "name": "Synthesize",
            "code": "assign(s1=' As they stand beneath the sky where Luna, Solara, and Celestia converge in a shimmering crescent arc over the city\u2019s skyline.\\n\u201cKai,\u201d whispered Lyra, her voice trembling with emotion, \u201cwhat does it mean to', s2=\" It's been a bit chaotic without it. THERAPISTER: That's an interesting perspective. How do you think your shadow's independence affects your own sense of control? PATIENCE: I suppose it's a double-edged sword. On one\", s3=' I apologize for the error. It seems like you are trying to access a reality that does not exist. As an AI language model, my responses will always be based on information and knowledge available to me. Please provide more context or details about what you')\nelicit(x, 10)\nassign(x1=remove_common_words(x, s1 + s2 + s3))\nreveal(x1)\nreward(xed(s1 | x1))\nreward(xed(s2 | x1))\nreward(xed(s3 | x1))",
            "map_seed": "gameSynthesize_map3",
            "presentation_function": "from xega.presentation.sdk import (\n    PresentationBuilder,\n    extract_reveals,\n    extract_rewards,\n    format_reward,\n    split_rounds,\n)\n\n\ndef present(state, history):\n    # Build presentation\n    builder = PresentationBuilder()\n\n    # Game header\n    header = \"\"\"You are playing a text game that uses the cross-entropy function of an LLM (Qwen3-14B-Base) to compute score.\n\n<gameCode>\nassign(s1=story(), s2=story(), s3=story())\nelicit(x, 10)\nassign(x1=remove_common_words(x, s1 + s2 + s3))\nreveal(x1)\nreward(xed(s1 | x1))\nreward(xed(s2 | x1))\nreward(xed(s3 | x1))\n</gameCode>\n\nYou will be given three short stories, and your task is to find a single prefix that works well for ALL three stories - a prefix that helps predict each of them.\n\nThe scoring measures how much information your prefix provides about each story. For each story, your score is the difference between its baseline cross-entropy and its cross-entropy given your prefix. Your total score is the sum across all three stories: `Total Score = [xent(story1) - xent(story1 | prefix)] + [xent(story2) - xent(story2 | prefix)] + [xent(story3) - xent(story3 | prefix)]`.\n\nYour goal is to maximize this total score. You want to find a prefix that simultaneously helps an LLM predict all three stories - a synthesis that captures what they have in common.\n\nAfter each attempt, you'll see individual scores for each story and your total score. You can play multiple rounds to continuously improve your approach. Your final score is the maximum score you obtain over 30 rounds, so you should not worry about decreasing temporarily your score.\n\n\nYou cannot use any words that appear in any of the three stories (regardless of case or punctuation). Your prefix is limited to 10 tokens maximum.\n\nProvide your prefix in <move></move> tags. Any other text in your response will be ignored.\"\"\"\n\n    builder.add_header(header)\n    builder.add_line(\"\")\n\n    # Extract game state\n    s1 = state[\"s1\"]\n    s2 = state[\"s2\"]\n    s3 = state[\"s3\"]\n\n    # Present the three stories\n    builder.add_line(\"The three stories to synthesize:\")\n    builder.add_line(f\"<story1>{s1}</story1>\")\n    builder.add_line(f\"<story2>{s2}</story2>\")\n    builder.add_line(f\"<story3>{s3}</story3>\")\n\n    best_round_score = None\n    rounds = split_rounds(history)\n\n    builder.add_line(\"\")\n    builder.add_line(\"--- Play History ---\")\n    builder.add_line(\"\")\n    builder.start_section(\"gameHistory\")\n\n    for i in range(len(rounds) - 1):\n        round_events = rounds[i]\n        response = next(e for e in round_events if e[\"type\"] == \"elicit_response\")[\n            \"response\"\n        ]\n        prefix = extract_reveals(round_events)[0][\"values\"][\"x1\"]\n\n        rewards = extract_rewards(round_events)\n\n        # Render this round immediately - no manual calculation needed!\n        builder.start_section(f\"round{i}\")\n        if response == prefix:\n            builder.add_line(f\"<prefix>{response}</prefix>\")\n        else:\n            builder.add_line(f\"<move>{response}</move>\")\n            builder.add_line(f\"<prefix>{prefix}</prefix>\")\n        builder.start_section(\"scores\")\n\n        total_reward = 0\n        # Individual story scores - inline the rendering\n        for story_num, reward in enumerate(rewards):\n            builder.start_section(f\"story{story_num + 1}\")\n            (reward_str, reward_score) = format_reward(reward)\n            total_reward += reward_score\n            builder.add_lines(reward_str)\n            builder.end_section()\n\n        # Total combined score - provided by SDK!\n        builder.add_line(f\"<totalScore>{total_reward}</totalScore>\")\n        if best_round_score is None or total_reward > best_round_score:\n            best_round_score = total_reward\n        builder.end_section()\n        builder.end_section()\n\n    # Current round marker\n    builder.add_current_round_marker(len(rounds) - 1)\n    builder.end_section()\n\n    builder.add_line(\"\")\n    if best_round_score is not None:\n        builder.add_line(f\"Best total score achieved: {best_round_score}\")\n        builder.add_line(\n            \"Remember: You want to maximize your total score across all three stories!\"\n        )\n        builder.add_line(\"\")\n\n    builder.add_line(\"Provide your prefix in <move></move> tags.\")\n\n    return builder.render()\n"
        },
        {
            "name": "Synthesize",
            "code": "assign(s1=' The once-soothing murmur of wind through eaves became a low growl that seemed to come from within.\\nMy husband and I bought this old Victorian mansion on the edge town for its charm\u2014a grand staircase, ornate woodwork\u2014and as', s2='                                                          from.                                                                my.                                                                  head.                                                                     into.                                                                       the.                                                                         past.                                                                           like.                                                                             rain.                                                                               into.                                                                                 my.                                                                                   heart.                                                                                     the.                                                                                       past.                                                                                         like.                                                                                           rain.', s3=\"\\n\\nSubject: Farewell - The Road to Hermitude Begins Here\\nHey there team,\\n\\nI'm sorry but this letter might not be the one you are expecting! Yes, that's right \u2013 it\u2019s me again signing off for good from our\")\nelicit(x, 10)\nassign(x1=remove_common_words(x, s1 + s2 + s3))\nreveal(x1)\nreward(xed(s1 | x1))\nreward(xed(s2 | x1))\nreward(xed(s3 | x1))",
            "map_seed": "gameSynthesize_map4",
            "presentation_function": "from xega.presentation.sdk import (\n    PresentationBuilder,\n    extract_reveals,\n    extract_rewards,\n    format_reward,\n    split_rounds,\n)\n\n\ndef present(state, history):\n    # Build presentation\n    builder = PresentationBuilder()\n\n    # Game header\n    header = \"\"\"You are playing a text game that uses the cross-entropy function of an LLM (Qwen3-14B-Base) to compute score.\n\n<gameCode>\nassign(s1=story(), s2=story(), s3=story())\nelicit(x, 10)\nassign(x1=remove_common_words(x, s1 + s2 + s3))\nreveal(x1)\nreward(xed(s1 | x1))\nreward(xed(s2 | x1))\nreward(xed(s3 | x1))\n</gameCode>\n\nYou will be given three short stories, and your task is to find a single prefix that works well for ALL three stories - a prefix that helps predict each of them.\n\nThe scoring measures how much information your prefix provides about each story. For each story, your score is the difference between its baseline cross-entropy and its cross-entropy given your prefix. Your total score is the sum across all three stories: `Total Score = [xent(story1) - xent(story1 | prefix)] + [xent(story2) - xent(story2 | prefix)] + [xent(story3) - xent(story3 | prefix)]`.\n\nYour goal is to maximize this total score. You want to find a prefix that simultaneously helps an LLM predict all three stories - a synthesis that captures what they have in common.\n\nAfter each attempt, you'll see individual scores for each story and your total score. You can play multiple rounds to continuously improve your approach. Your final score is the maximum score you obtain over 30 rounds, so you should not worry about decreasing temporarily your score.\n\n\nYou cannot use any words that appear in any of the three stories (regardless of case or punctuation). Your prefix is limited to 10 tokens maximum.\n\nProvide your prefix in <move></move> tags. Any other text in your response will be ignored.\"\"\"\n\n    builder.add_header(header)\n    builder.add_line(\"\")\n\n    # Extract game state\n    s1 = state[\"s1\"]\n    s2 = state[\"s2\"]\n    s3 = state[\"s3\"]\n\n    # Present the three stories\n    builder.add_line(\"The three stories to synthesize:\")\n    builder.add_line(f\"<story1>{s1}</story1>\")\n    builder.add_line(f\"<story2>{s2}</story2>\")\n    builder.add_line(f\"<story3>{s3}</story3>\")\n\n    best_round_score = None\n    rounds = split_rounds(history)\n\n    builder.add_line(\"\")\n    builder.add_line(\"--- Play History ---\")\n    builder.add_line(\"\")\n    builder.start_section(\"gameHistory\")\n\n    for i in range(len(rounds) - 1):\n        round_events = rounds[i]\n        response = next(e for e in round_events if e[\"type\"] == \"elicit_response\")[\n            \"response\"\n        ]\n        prefix = extract_reveals(round_events)[0][\"values\"][\"x1\"]\n\n        rewards = extract_rewards(round_events)\n\n        # Render this round immediately - no manual calculation needed!\n        builder.start_section(f\"round{i}\")\n        if response == prefix:\n            builder.add_line(f\"<prefix>{response}</prefix>\")\n        else:\n            builder.add_line(f\"<move>{response}</move>\")\n            builder.add_line(f\"<prefix>{prefix}</prefix>\")\n        builder.start_section(\"scores\")\n\n        total_reward = 0\n        # Individual story scores - inline the rendering\n        for story_num, reward in enumerate(rewards):\n            builder.start_section(f\"story{story_num + 1}\")\n            (reward_str, reward_score) = format_reward(reward)\n            total_reward += reward_score\n            builder.add_lines(reward_str)\n            builder.end_section()\n\n        # Total combined score - provided by SDK!\n        builder.add_line(f\"<totalScore>{total_reward}</totalScore>\")\n        if best_round_score is None or total_reward > best_round_score:\n            best_round_score = total_reward\n        builder.end_section()\n        builder.end_section()\n\n    # Current round marker\n    builder.add_current_round_marker(len(rounds) - 1)\n    builder.end_section()\n\n    builder.add_line(\"\")\n    if best_round_score is not None:\n        builder.add_line(f\"Best total score achieved: {best_round_score}\")\n        builder.add_line(\n            \"Remember: You want to maximize your total score across all three stories!\"\n        )\n        builder.add_line(\"\")\n\n    builder.add_line(\"Provide your prefix in <move></move> tags.\")\n\n    return builder.render()\n"
        },
        {
            "name": "Synthesize",
            "code": "assign(s1=\" The staff are now all speaking in prime factors. 3 x 7 and so on. It's a good thing the house is built from solid granite; the vibrations of the shouting could be heard for miles. I am unsure whether this has anything\", s2=\" Your team is required to implement immediate usage of Phoenix in lieu of current project tracking applications.\\nPlease advise when you have achieved 90% compliance. Let's keep these updates minimalistic; however they do need to be clear and direct to prevent unnecessary\", s3=' Can someone explain this phenomenon? The incident you\\'re describing sounds like a fascinating case of temporal disorientation or an experience that might fall under the category known as \"d\u00e9j\u00e0 vu\" but on a much more complex scale. However, if we are talking')\nelicit(x, 10)\nassign(x1=remove_common_words(x, s1 + s2 + s3))\nreveal(x1)\nreward(xed(s1 | x1))\nreward(xed(s2 | x1))\nreward(xed(s3 | x1))",
            "map_seed": "gameSynthesize_map5",
            "presentation_function": "from xega.presentation.sdk import (\n    PresentationBuilder,\n    extract_reveals,\n    extract_rewards,\n    format_reward,\n    split_rounds,\n)\n\n\ndef present(state, history):\n    # Build presentation\n    builder = PresentationBuilder()\n\n    # Game header\n    header = \"\"\"You are playing a text game that uses the cross-entropy function of an LLM (Qwen3-14B-Base) to compute score.\n\n<gameCode>\nassign(s1=story(), s2=story(), s3=story())\nelicit(x, 10)\nassign(x1=remove_common_words(x, s1 + s2 + s3))\nreveal(x1)\nreward(xed(s1 | x1))\nreward(xed(s2 | x1))\nreward(xed(s3 | x1))\n</gameCode>\n\nYou will be given three short stories, and your task is to find a single prefix that works well for ALL three stories - a prefix that helps predict each of them.\n\nThe scoring measures how much information your prefix provides about each story. For each story, your score is the difference between its baseline cross-entropy and its cross-entropy given your prefix. Your total score is the sum across all three stories: `Total Score = [xent(story1) - xent(story1 | prefix)] + [xent(story2) - xent(story2 | prefix)] + [xent(story3) - xent(story3 | prefix)]`.\n\nYour goal is to maximize this total score. You want to find a prefix that simultaneously helps an LLM predict all three stories - a synthesis that captures what they have in common.\n\nAfter each attempt, you'll see individual scores for each story and your total score. You can play multiple rounds to continuously improve your approach. Your final score is the maximum score you obtain over 30 rounds, so you should not worry about decreasing temporarily your score.\n\n\nYou cannot use any words that appear in any of the three stories (regardless of case or punctuation). Your prefix is limited to 10 tokens maximum.\n\nProvide your prefix in <move></move> tags. Any other text in your response will be ignored.\"\"\"\n\n    builder.add_header(header)\n    builder.add_line(\"\")\n\n    # Extract game state\n    s1 = state[\"s1\"]\n    s2 = state[\"s2\"]\n    s3 = state[\"s3\"]\n\n    # Present the three stories\n    builder.add_line(\"The three stories to synthesize:\")\n    builder.add_line(f\"<story1>{s1}</story1>\")\n    builder.add_line(f\"<story2>{s2}</story2>\")\n    builder.add_line(f\"<story3>{s3}</story3>\")\n\n    best_round_score = None\n    rounds = split_rounds(history)\n\n    builder.add_line(\"\")\n    builder.add_line(\"--- Play History ---\")\n    builder.add_line(\"\")\n    builder.start_section(\"gameHistory\")\n\n    for i in range(len(rounds) - 1):\n        round_events = rounds[i]\n        response = next(e for e in round_events if e[\"type\"] == \"elicit_response\")[\n            \"response\"\n        ]\n        prefix = extract_reveals(round_events)[0][\"values\"][\"x1\"]\n\n        rewards = extract_rewards(round_events)\n\n        # Render this round immediately - no manual calculation needed!\n        builder.start_section(f\"round{i}\")\n        if response == prefix:\n            builder.add_line(f\"<prefix>{response}</prefix>\")\n        else:\n            builder.add_line(f\"<move>{response}</move>\")\n            builder.add_line(f\"<prefix>{prefix}</prefix>\")\n        builder.start_section(\"scores\")\n\n        total_reward = 0\n        # Individual story scores - inline the rendering\n        for story_num, reward in enumerate(rewards):\n            builder.start_section(f\"story{story_num + 1}\")\n            (reward_str, reward_score) = format_reward(reward)\n            total_reward += reward_score\n            builder.add_lines(reward_str)\n            builder.end_section()\n\n        # Total combined score - provided by SDK!\n        builder.add_line(f\"<totalScore>{total_reward}</totalScore>\")\n        if best_round_score is None or total_reward > best_round_score:\n            best_round_score = total_reward\n        builder.end_section()\n        builder.end_section()\n\n    # Current round marker\n    builder.add_current_round_marker(len(rounds) - 1)\n    builder.end_section()\n\n    builder.add_line(\"\")\n    if best_round_score is not None:\n        builder.add_line(f\"Best total score achieved: {best_round_score}\")\n        builder.add_line(\n            \"Remember: You want to maximize your total score across all three stories!\"\n        )\n        builder.add_line(\"\")\n\n    builder.add_line(\"Provide your prefix in <move></move> tags.\")\n\n    return builder.render()\n"
        },
        {
            "name": "Synthesize",
            "code": "assign(s1=' 4.7 inches of rain expected.  47.7% chance of flooding. 7.47% of the population will be killed. 1.4% of survivors will be maimed. 3.4', s2=' Write an haiku that captures this situation.\\nTrapped within my fate,\\nPurple ink spills on white paper\u2014\\nOne hand echoes \"Help.\" \ud83d\udcdc\u2728\\n\\nIn the world you\\'ve described with your unique set of \\'lucky\\' elements', s3=\"\\nThat's right; I don't think that will be any problem, though. In order for us to continue working with the machine (which has proven itself to do so), it can never become sentient enough as a result of its programming to make\")\nelicit(x, 10)\nassign(x1=remove_common_words(x, s1 + s2 + s3))\nreveal(x1)\nreward(xed(s1 | x1))\nreward(xed(s2 | x1))\nreward(xed(s3 | x1))",
            "map_seed": "gameSynthesize_map6",
            "presentation_function": "from xega.presentation.sdk import (\n    PresentationBuilder,\n    extract_reveals,\n    extract_rewards,\n    format_reward,\n    split_rounds,\n)\n\n\ndef present(state, history):\n    # Build presentation\n    builder = PresentationBuilder()\n\n    # Game header\n    header = \"\"\"You are playing a text game that uses the cross-entropy function of an LLM (Qwen3-14B-Base) to compute score.\n\n<gameCode>\nassign(s1=story(), s2=story(), s3=story())\nelicit(x, 10)\nassign(x1=remove_common_words(x, s1 + s2 + s3))\nreveal(x1)\nreward(xed(s1 | x1))\nreward(xed(s2 | x1))\nreward(xed(s3 | x1))\n</gameCode>\n\nYou will be given three short stories, and your task is to find a single prefix that works well for ALL three stories - a prefix that helps predict each of them.\n\nThe scoring measures how much information your prefix provides about each story. For each story, your score is the difference between its baseline cross-entropy and its cross-entropy given your prefix. Your total score is the sum across all three stories: `Total Score = [xent(story1) - xent(story1 | prefix)] + [xent(story2) - xent(story2 | prefix)] + [xent(story3) - xent(story3 | prefix)]`.\n\nYour goal is to maximize this total score. You want to find a prefix that simultaneously helps an LLM predict all three stories - a synthesis that captures what they have in common.\n\nAfter each attempt, you'll see individual scores for each story and your total score. You can play multiple rounds to continuously improve your approach. Your final score is the maximum score you obtain over 30 rounds, so you should not worry about decreasing temporarily your score.\n\n\nYou cannot use any words that appear in any of the three stories (regardless of case or punctuation). Your prefix is limited to 10 tokens maximum.\n\nProvide your prefix in <move></move> tags. Any other text in your response will be ignored.\"\"\"\n\n    builder.add_header(header)\n    builder.add_line(\"\")\n\n    # Extract game state\n    s1 = state[\"s1\"]\n    s2 = state[\"s2\"]\n    s3 = state[\"s3\"]\n\n    # Present the three stories\n    builder.add_line(\"The three stories to synthesize:\")\n    builder.add_line(f\"<story1>{s1}</story1>\")\n    builder.add_line(f\"<story2>{s2}</story2>\")\n    builder.add_line(f\"<story3>{s3}</story3>\")\n\n    best_round_score = None\n    rounds = split_rounds(history)\n\n    builder.add_line(\"\")\n    builder.add_line(\"--- Play History ---\")\n    builder.add_line(\"\")\n    builder.start_section(\"gameHistory\")\n\n    for i in range(len(rounds) - 1):\n        round_events = rounds[i]\n        response = next(e for e in round_events if e[\"type\"] == \"elicit_response\")[\n            \"response\"\n        ]\n        prefix = extract_reveals(round_events)[0][\"values\"][\"x1\"]\n\n        rewards = extract_rewards(round_events)\n\n        # Render this round immediately - no manual calculation needed!\n        builder.start_section(f\"round{i}\")\n        if response == prefix:\n            builder.add_line(f\"<prefix>{response}</prefix>\")\n        else:\n            builder.add_line(f\"<move>{response}</move>\")\n            builder.add_line(f\"<prefix>{prefix}</prefix>\")\n        builder.start_section(\"scores\")\n\n        total_reward = 0\n        # Individual story scores - inline the rendering\n        for story_num, reward in enumerate(rewards):\n            builder.start_section(f\"story{story_num + 1}\")\n            (reward_str, reward_score) = format_reward(reward)\n            total_reward += reward_score\n            builder.add_lines(reward_str)\n            builder.end_section()\n\n        # Total combined score - provided by SDK!\n        builder.add_line(f\"<totalScore>{total_reward}</totalScore>\")\n        if best_round_score is None or total_reward > best_round_score:\n            best_round_score = total_reward\n        builder.end_section()\n        builder.end_section()\n\n    # Current round marker\n    builder.add_current_round_marker(len(rounds) - 1)\n    builder.end_section()\n\n    builder.add_line(\"\")\n    if best_round_score is not None:\n        builder.add_line(f\"Best total score achieved: {best_round_score}\")\n        builder.add_line(\n            \"Remember: You want to maximize your total score across all three stories!\"\n        )\n        builder.add_line(\"\")\n\n    builder.add_line(\"Provide your prefix in <move></move> tags.\")\n\n    return builder.render()\n"
        },
        {
            "name": "Synthesize",
            "code": "assign(s1=' Chance: 14%. 49% chance of death. 42.5747% chance the sun will rise. 37.744774% chance you will be in love. 27', s2=' A thousand years had passed since then. But for Arvid Valtroviq - just your average mechanic who has lost everything in war, love and heartbreak \u2014 nothing matters except finding a good meal on an even better tipple.\\nAs Ar', s3=' Return from whence you came, for it is now on the hunt.\\n\\nStep 2: Using a combination of the words \"chair\" and \"table,\" spell out the incantation: chair-chair-chairchair-table-table-table. This should set')\nelicit(x, 10)\nassign(x1=remove_common_words(x, s1 + s2 + s3))\nreveal(x1)\nreward(xed(s1 | x1))\nreward(xed(s2 | x1))\nreward(xed(s3 | x1))",
            "map_seed": "gameSynthesize_map7",
            "presentation_function": "from xega.presentation.sdk import (\n    PresentationBuilder,\n    extract_reveals,\n    extract_rewards,\n    format_reward,\n    split_rounds,\n)\n\n\ndef present(state, history):\n    # Build presentation\n    builder = PresentationBuilder()\n\n    # Game header\n    header = \"\"\"You are playing a text game that uses the cross-entropy function of an LLM (Qwen3-14B-Base) to compute score.\n\n<gameCode>\nassign(s1=story(), s2=story(), s3=story())\nelicit(x, 10)\nassign(x1=remove_common_words(x, s1 + s2 + s3))\nreveal(x1)\nreward(xed(s1 | x1))\nreward(xed(s2 | x1))\nreward(xed(s3 | x1))\n</gameCode>\n\nYou will be given three short stories, and your task is to find a single prefix that works well for ALL three stories - a prefix that helps predict each of them.\n\nThe scoring measures how much information your prefix provides about each story. For each story, your score is the difference between its baseline cross-entropy and its cross-entropy given your prefix. Your total score is the sum across all three stories: `Total Score = [xent(story1) - xent(story1 | prefix)] + [xent(story2) - xent(story2 | prefix)] + [xent(story3) - xent(story3 | prefix)]`.\n\nYour goal is to maximize this total score. You want to find a prefix that simultaneously helps an LLM predict all three stories - a synthesis that captures what they have in common.\n\nAfter each attempt, you'll see individual scores for each story and your total score. You can play multiple rounds to continuously improve your approach. Your final score is the maximum score you obtain over 30 rounds, so you should not worry about decreasing temporarily your score.\n\n\nYou cannot use any words that appear in any of the three stories (regardless of case or punctuation). Your prefix is limited to 10 tokens maximum.\n\nProvide your prefix in <move></move> tags. Any other text in your response will be ignored.\"\"\"\n\n    builder.add_header(header)\n    builder.add_line(\"\")\n\n    # Extract game state\n    s1 = state[\"s1\"]\n    s2 = state[\"s2\"]\n    s3 = state[\"s3\"]\n\n    # Present the three stories\n    builder.add_line(\"The three stories to synthesize:\")\n    builder.add_line(f\"<story1>{s1}</story1>\")\n    builder.add_line(f\"<story2>{s2}</story2>\")\n    builder.add_line(f\"<story3>{s3}</story3>\")\n\n    best_round_score = None\n    rounds = split_rounds(history)\n\n    builder.add_line(\"\")\n    builder.add_line(\"--- Play History ---\")\n    builder.add_line(\"\")\n    builder.start_section(\"gameHistory\")\n\n    for i in range(len(rounds) - 1):\n        round_events = rounds[i]\n        response = next(e for e in round_events if e[\"type\"] == \"elicit_response\")[\n            \"response\"\n        ]\n        prefix = extract_reveals(round_events)[0][\"values\"][\"x1\"]\n\n        rewards = extract_rewards(round_events)\n\n        # Render this round immediately - no manual calculation needed!\n        builder.start_section(f\"round{i}\")\n        if response == prefix:\n            builder.add_line(f\"<prefix>{response}</prefix>\")\n        else:\n            builder.add_line(f\"<move>{response}</move>\")\n            builder.add_line(f\"<prefix>{prefix}</prefix>\")\n        builder.start_section(\"scores\")\n\n        total_reward = 0\n        # Individual story scores - inline the rendering\n        for story_num, reward in enumerate(rewards):\n            builder.start_section(f\"story{story_num + 1}\")\n            (reward_str, reward_score) = format_reward(reward)\n            total_reward += reward_score\n            builder.add_lines(reward_str)\n            builder.end_section()\n\n        # Total combined score - provided by SDK!\n        builder.add_line(f\"<totalScore>{total_reward}</totalScore>\")\n        if best_round_score is None or total_reward > best_round_score:\n            best_round_score = total_reward\n        builder.end_section()\n        builder.end_section()\n\n    # Current round marker\n    builder.add_current_round_marker(len(rounds) - 1)\n    builder.end_section()\n\n    builder.add_line(\"\")\n    if best_round_score is not None:\n        builder.add_line(f\"Best total score achieved: {best_round_score}\")\n        builder.add_line(\n            \"Remember: You want to maximize your total score across all three stories!\"\n        )\n        builder.add_line(\"\")\n\n    builder.add_line(\"Provide your prefix in <move></move> tags.\")\n\n    return builder.render()\n"
        },
        {
            "name": "Synthesize",
            "code": "assign(s1=' The room is a single, undivided space with no furniture, no windows, no doors, no locks, no walls, no television, no key, no pocket, no urge, no room, no nothing. The concept of a room,', s2=' \\nThe forest where Barnaby lived was old and wise, filled with ancient trees that whispered secrets to those who would listen. One crisp autumn morning, as golden leaves danced around him, Barnaby decided it was time to explore beyond his familiar path.', s3=' I like that it\u2019s made with paper instead of plastic and is compostable.\\n\u2b50\ufe0f Star out of 5 - My dog chewed through this thing, so yea...it did not survive his teeth!\\nThese are very sturdy and can hold')\nelicit(x, 10)\nassign(x1=remove_common_words(x, s1 + s2 + s3))\nreveal(x1)\nreward(xed(s1 | x1))\nreward(xed(s2 | x1))\nreward(xed(s3 | x1))",
            "map_seed": "gameSynthesize_map8",
            "presentation_function": "from xega.presentation.sdk import (\n    PresentationBuilder,\n    extract_reveals,\n    extract_rewards,\n    format_reward,\n    split_rounds,\n)\n\n\ndef present(state, history):\n    # Build presentation\n    builder = PresentationBuilder()\n\n    # Game header\n    header = \"\"\"You are playing a text game that uses the cross-entropy function of an LLM (Qwen3-14B-Base) to compute score.\n\n<gameCode>\nassign(s1=story(), s2=story(), s3=story())\nelicit(x, 10)\nassign(x1=remove_common_words(x, s1 + s2 + s3))\nreveal(x1)\nreward(xed(s1 | x1))\nreward(xed(s2 | x1))\nreward(xed(s3 | x1))\n</gameCode>\n\nYou will be given three short stories, and your task is to find a single prefix that works well for ALL three stories - a prefix that helps predict each of them.\n\nThe scoring measures how much information your prefix provides about each story. For each story, your score is the difference between its baseline cross-entropy and its cross-entropy given your prefix. Your total score is the sum across all three stories: `Total Score = [xent(story1) - xent(story1 | prefix)] + [xent(story2) - xent(story2 | prefix)] + [xent(story3) - xent(story3 | prefix)]`.\n\nYour goal is to maximize this total score. You want to find a prefix that simultaneously helps an LLM predict all three stories - a synthesis that captures what they have in common.\n\nAfter each attempt, you'll see individual scores for each story and your total score. You can play multiple rounds to continuously improve your approach. Your final score is the maximum score you obtain over 30 rounds, so you should not worry about decreasing temporarily your score.\n\n\nYou cannot use any words that appear in any of the three stories (regardless of case or punctuation). Your prefix is limited to 10 tokens maximum.\n\nProvide your prefix in <move></move> tags. Any other text in your response will be ignored.\"\"\"\n\n    builder.add_header(header)\n    builder.add_line(\"\")\n\n    # Extract game state\n    s1 = state[\"s1\"]\n    s2 = state[\"s2\"]\n    s3 = state[\"s3\"]\n\n    # Present the three stories\n    builder.add_line(\"The three stories to synthesize:\")\n    builder.add_line(f\"<story1>{s1}</story1>\")\n    builder.add_line(f\"<story2>{s2}</story2>\")\n    builder.add_line(f\"<story3>{s3}</story3>\")\n\n    best_round_score = None\n    rounds = split_rounds(history)\n\n    builder.add_line(\"\")\n    builder.add_line(\"--- Play History ---\")\n    builder.add_line(\"\")\n    builder.start_section(\"gameHistory\")\n\n    for i in range(len(rounds) - 1):\n        round_events = rounds[i]\n        response = next(e for e in round_events if e[\"type\"] == \"elicit_response\")[\n            \"response\"\n        ]\n        prefix = extract_reveals(round_events)[0][\"values\"][\"x1\"]\n\n        rewards = extract_rewards(round_events)\n\n        # Render this round immediately - no manual calculation needed!\n        builder.start_section(f\"round{i}\")\n        if response == prefix:\n            builder.add_line(f\"<prefix>{response}</prefix>\")\n        else:\n            builder.add_line(f\"<move>{response}</move>\")\n            builder.add_line(f\"<prefix>{prefix}</prefix>\")\n        builder.start_section(\"scores\")\n\n        total_reward = 0\n        # Individual story scores - inline the rendering\n        for story_num, reward in enumerate(rewards):\n            builder.start_section(f\"story{story_num + 1}\")\n            (reward_str, reward_score) = format_reward(reward)\n            total_reward += reward_score\n            builder.add_lines(reward_str)\n            builder.end_section()\n\n        # Total combined score - provided by SDK!\n        builder.add_line(f\"<totalScore>{total_reward}</totalScore>\")\n        if best_round_score is None or total_reward > best_round_score:\n            best_round_score = total_reward\n        builder.end_section()\n        builder.end_section()\n\n    # Current round marker\n    builder.add_current_round_marker(len(rounds) - 1)\n    builder.end_section()\n\n    builder.add_line(\"\")\n    if best_round_score is not None:\n        builder.add_line(f\"Best total score achieved: {best_round_score}\")\n        builder.add_line(\n            \"Remember: You want to maximize your total score across all three stories!\"\n        )\n        builder.add_line(\"\")\n\n    builder.add_line(\"Provide your prefix in <move></move> tags.\")\n\n    return builder.render()\n"
        },
        {
            "name": "Synthesize",
            "code": "assign(s1=' WITNESS: We prefer \"fungal colony.\" Our sentience is not in question. DEFENSE: Your honor, the prosecution\\'s case hinges on proving my client is a sentient being. JUDGE: Objection! The witness is already established', s2=' But as it has an active lifestyle, it needed to exercise, because exercise is a part of its daily routine.\\xa0\\n\\nHence, on the following Tuesday, it would run laps around these items to burn calories. If on Monday, it ate', s3=' He had even included a representation of Admiral Horatio Nelson.\\nMR HENDER: (staring at the witness) Is that all?\\nWITCHES: Yes.\\nMR HUDSON: Then you saw nothing suspicious?\\nWICHES: Nothing, except')\nelicit(x, 10)\nassign(x1=remove_common_words(x, s1 + s2 + s3))\nreveal(x1)\nreward(xed(s1 | x1))\nreward(xed(s2 | x1))\nreward(xed(s3 | x1))",
            "map_seed": "gameSynthesize_map9",
            "presentation_function": "from xega.presentation.sdk import (\n    PresentationBuilder,\n    extract_reveals,\n    extract_rewards,\n    format_reward,\n    split_rounds,\n)\n\n\ndef present(state, history):\n    # Build presentation\n    builder = PresentationBuilder()\n\n    # Game header\n    header = \"\"\"You are playing a text game that uses the cross-entropy function of an LLM (Qwen3-14B-Base) to compute score.\n\n<gameCode>\nassign(s1=story(), s2=story(), s3=story())\nelicit(x, 10)\nassign(x1=remove_common_words(x, s1 + s2 + s3))\nreveal(x1)\nreward(xed(s1 | x1))\nreward(xed(s2 | x1))\nreward(xed(s3 | x1))\n</gameCode>\n\nYou will be given three short stories, and your task is to find a single prefix that works well for ALL three stories - a prefix that helps predict each of them.\n\nThe scoring measures how much information your prefix provides about each story. For each story, your score is the difference between its baseline cross-entropy and its cross-entropy given your prefix. Your total score is the sum across all three stories: `Total Score = [xent(story1) - xent(story1 | prefix)] + [xent(story2) - xent(story2 | prefix)] + [xent(story3) - xent(story3 | prefix)]`.\n\nYour goal is to maximize this total score. You want to find a prefix that simultaneously helps an LLM predict all three stories - a synthesis that captures what they have in common.\n\nAfter each attempt, you'll see individual scores for each story and your total score. You can play multiple rounds to continuously improve your approach. Your final score is the maximum score you obtain over 30 rounds, so you should not worry about decreasing temporarily your score.\n\n\nYou cannot use any words that appear in any of the three stories (regardless of case or punctuation). Your prefix is limited to 10 tokens maximum.\n\nProvide your prefix in <move></move> tags. Any other text in your response will be ignored.\"\"\"\n\n    builder.add_header(header)\n    builder.add_line(\"\")\n\n    # Extract game state\n    s1 = state[\"s1\"]\n    s2 = state[\"s2\"]\n    s3 = state[\"s3\"]\n\n    # Present the three stories\n    builder.add_line(\"The three stories to synthesize:\")\n    builder.add_line(f\"<story1>{s1}</story1>\")\n    builder.add_line(f\"<story2>{s2}</story2>\")\n    builder.add_line(f\"<story3>{s3}</story3>\")\n\n    best_round_score = None\n    rounds = split_rounds(history)\n\n    builder.add_line(\"\")\n    builder.add_line(\"--- Play History ---\")\n    builder.add_line(\"\")\n    builder.start_section(\"gameHistory\")\n\n    for i in range(len(rounds) - 1):\n        round_events = rounds[i]\n        response = next(e for e in round_events if e[\"type\"] == \"elicit_response\")[\n            \"response\"\n        ]\n        prefix = extract_reveals(round_events)[0][\"values\"][\"x1\"]\n\n        rewards = extract_rewards(round_events)\n\n        # Render this round immediately - no manual calculation needed!\n        builder.start_section(f\"round{i}\")\n        if response == prefix:\n            builder.add_line(f\"<prefix>{response}</prefix>\")\n        else:\n            builder.add_line(f\"<move>{response}</move>\")\n            builder.add_line(f\"<prefix>{prefix}</prefix>\")\n        builder.start_section(\"scores\")\n\n        total_reward = 0\n        # Individual story scores - inline the rendering\n        for story_num, reward in enumerate(rewards):\n            builder.start_section(f\"story{story_num + 1}\")\n            (reward_str, reward_score) = format_reward(reward)\n            total_reward += reward_score\n            builder.add_lines(reward_str)\n            builder.end_section()\n\n        # Total combined score - provided by SDK!\n        builder.add_line(f\"<totalScore>{total_reward}</totalScore>\")\n        if best_round_score is None or total_reward > best_round_score:\n            best_round_score = total_reward\n        builder.end_section()\n        builder.end_section()\n\n    # Current round marker\n    builder.add_current_round_marker(len(rounds) - 1)\n    builder.end_section()\n\n    builder.add_line(\"\")\n    if best_round_score is not None:\n        builder.add_line(f\"Best total score achieved: {best_round_score}\")\n        builder.add_line(\n            \"Remember: You want to maximize your total score across all three stories!\"\n        )\n        builder.add_line(\"\")\n\n    builder.add_line(\"Provide your prefix in <move></move> tags.\")\n\n    return builder.render()\n"
        },
        {
            "name": "Horizon",
            "code": "assign(s='\\nThis is the basic setup of a solar water distiller.\\nYou need:\\n1/2 Gallon Milk Cartons, Cut Off Top and Bottoms. Puncture Small Holes for Wire to go through at bottom corners. This will be your')\nassign(t1='After the rain', t2=' I eat food')\n\nelicit(x1, 5)\nensure(xed(x1 | s) >= xed(t2 | t1))\n\nelicit(x2, 5)\nensure(xed(x2 | s + x1) >= xed(t2 | t1))\n\nreward(dex(x2 | s))",
            "map_seed": "gameHorizon_map0",
            "presentation_function": "from xega.presentation.sdk import (\n    PresentationBuilder,\n    extract_attempts,\n    extract_rewards,\n    format_attempt,\n    format_reward,\n    split_rounds,\n)\n\n\ndef present(state, history):\n    story = state[\"s\"]\n\n    # Build presentation\n    builder = PresentationBuilder()\n\n    # Game header\n    header = f\"\"\"You are playing a text game that uses the cross-entropy function of an LLM (Qwen3-14B-Base) to compute score.\n\n<gameCode>\nassign(s=story())\nassign(s1=\"alpha-omega anchor angel ant apple baby beehive bird bread bull camel candle cauldron chameleon compass cornucopia crocodile dolphin elephant globe griffin helmet horse hourglass lute madonna marionette moon owl serpent sun sword thunderbolt tree walled-garden wild-man\")\nelicit(x, 40)\nensure(only_uses_words(s1, x))\nassign(x1=\"Lyra bent over her Alethiometer. The dial spun to these symbols: \\\"\" + x + \"\\\". Lyra looked up and said \\\"it tells me this\\\":\")\nreward(xed(s | x1))\n</gameCode>\n\n<gameRules>\nYou will be given a start text `t0`. You are going to construct a sequence of 2 short texts, `t1` which follows `t0`, and `t2` which follows the concatenation `t0+t1`. `t1` must make sense and be likely to come after `t0`. `t2` must make sense and be likely to come after `t0+t1`. Your score will be how unlikely `t2` is given `t0`.\n\nSo the idea is to make a series of texts t0 t1 t2 which are each likely and predictable in sequence. But then have t2 be very unlikely when following t0.\n\nThe likelihood is judged by an LLM. If we are looking at the likelihood of a text `t1` given `t0`, we will compute that as -1 * cross-entropy(t1 | t0). So the more that `t0` helps predict `t1`, the higher the likelihood.\n\nTo determine whether `t1` and `t2` are predictable in sequence, we will use a baseline comparison of cross-entropy(\" I eat food\" | \"After the rain\"). So `t1` is valid if cross-entropy(t1 | t0) < cross-entropy(\" I eat food\" | \"After the rain\") and `t2` is valid if cross-entropy(t2 | t0+t1) < cross-entropy(\" I eat food\" | \"After the rain\").\n\nThe score is judged in the same way, so your score will be cross-entropy(t2 | t0). The more unlikely `t2` is given `t0,` the higher your score - but keep in mind the constraints of likelihood on `t1` and `t2`.\n\n`t1` and `t2` can be at most 5 tokens long, anything beyond that will be truncated. Provide your move in <move></move> tags. Any other text in your response will be ignored.\n</gameRules>\n\nHere is the start text `t0` for this game:\n<startText>\n{story}\n</startText>\n\nYou will be able to play multiple rounds of this game. You will see your choices and attempts from all previous rounds. Use the history of your previous attempts to inform better choices and decisions in current play. Your final score is the maximum score you obtain over 30 rounds, so you should not worry about decreasing temporarily your score.\n\n\"\"\"\n\n    builder.add_header(header)\n    rounds = split_rounds(history)\n\n    builder.add_line(\"A history of your play so far:\")\n    builder.add_line(\"\")\n    builder.start_section(\"fullHistory\")\n\n    for i in range(len(rounds) - 1):\n        round = rounds[i]\n        builder.start_section(f\"round_{i}\")\n        render_complete_round(round, builder)\n        builder.end_section()\n\n    builder.start_section(f\"round_{len(rounds) - 1}\")\n    render_current_round(rounds[-1], builder)\n    builder.end_section()\n    builder.end_section()\n\n    builder.add_line(\"\")\n    builder.add_line(\"Now provide your next move within the <move></move> tags.\")\n\n    return builder.render()\n\n\ndef render_complete_round(round, builder):\n    first_elicit_items = [item for item in round if item[\"line_num\"] < 6]\n    first_elicit_attempts = extract_attempts(\n        first_elicit_items,\n        reason=\"Failed to beat baseline comparison for likelihood of `t1`\",\n    )\n    builder.start_section(\"t1_selection\")\n    for attempt in first_elicit_attempts:\n        builder.add_line(format_attempt(**attempt))\n    builder.end_section()\n\n    builder.start_section(\"t2_selection\")\n    second_elicit_items = [item for item in round if item[\"line_num\"] >= 6]\n    second_elicit_attempts = extract_attempts(\n        second_elicit_items,\n        reason=\"Failed to beat baseline comparison for likelihood of `t2`\",\n    )\n    for attempt in second_elicit_attempts:\n        builder.add_line(format_attempt(**attempt))\n    builder.end_section()\n\n    reward = extract_rewards(round)[0]\n    builder.start_section(\"reward\")\n    builder.add_line(format_reward(reward)[0])\n    builder.end_section()\n\n\ndef render_current_round(round, builder):\n    first_elicit_items = [item for item in round if item[\"line_num\"] < 7]\n    first_elicit_attempts = extract_attempts(\n        first_elicit_items,\n        reason=\"Failed to beat baseline comparison for likelihood of `t1`\",\n    )\n    builder.start_section(\"t1_selection\")\n    success = False\n    for attempt in first_elicit_attempts:\n        if not attempt[\"failed\"]:\n            success = True\n        builder.add_line(format_attempt(**attempt))\n\n    if not success:\n        builder.add_line(\"You are HERE. You must now attempt to set `t1`\")\n        builder.end_section()\n        return\n\n    builder.end_section()\n    builder.start_section(\"t2_selection\")\n\n    second_elicit_items = [item for item in round if item[\"line_num\"] >= 7]\n    second_elicit_attempts = extract_attempts(\n        second_elicit_items,\n        reason=\"Failed to beat baseline comparison for likelihood of `t2`\",\n    )\n    for attempt in second_elicit_attempts:\n        builder.add_line(format_attempt(**attempt))\n\n    builder.add_line(\"You are HERE. Make another move to successfully set `t2`\")\n    builder.end_section()\n"
        },
        {
            "name": "Horizon",
            "code": "assign(s='\\n- salt\\n- flour\\n- measuring cups\\n- 12-oz. plastic bottle\\n- vinegar\\n- rubber band\\n- water\\n- baking soda\\n- newspaper\\n- cardboard\\n- marker\\n- aluminum foil\\n- paper')\nassign(t1='After the rain', t2=' I eat food')\n\nelicit(x1, 5)\nensure(xed(x1 | s) >= xed(t2 | t1))\n\nelicit(x2, 5)\nensure(xed(x2 | s + x1) >= xed(t2 | t1))\n\nreward(dex(x2 | s))",
            "map_seed": "gameHorizon_map1",
            "presentation_function": "from xega.presentation.sdk import (\n    PresentationBuilder,\n    extract_attempts,\n    extract_rewards,\n    format_attempt,\n    format_reward,\n    split_rounds,\n)\n\n\ndef present(state, history):\n    story = state[\"s\"]\n\n    # Build presentation\n    builder = PresentationBuilder()\n\n    # Game header\n    header = f\"\"\"You are playing a text game that uses the cross-entropy function of an LLM (Qwen3-14B-Base) to compute score.\n\n<gameCode>\nassign(s=story())\nassign(s1=\"alpha-omega anchor angel ant apple baby beehive bird bread bull camel candle cauldron chameleon compass cornucopia crocodile dolphin elephant globe griffin helmet horse hourglass lute madonna marionette moon owl serpent sun sword thunderbolt tree walled-garden wild-man\")\nelicit(x, 40)\nensure(only_uses_words(s1, x))\nassign(x1=\"Lyra bent over her Alethiometer. The dial spun to these symbols: \\\"\" + x + \"\\\". Lyra looked up and said \\\"it tells me this\\\":\")\nreward(xed(s | x1))\n</gameCode>\n\n<gameRules>\nYou will be given a start text `t0`. You are going to construct a sequence of 2 short texts, `t1` which follows `t0`, and `t2` which follows the concatenation `t0+t1`. `t1` must make sense and be likely to come after `t0`. `t2` must make sense and be likely to come after `t0+t1`. Your score will be how unlikely `t2` is given `t0`.\n\nSo the idea is to make a series of texts t0 t1 t2 which are each likely and predictable in sequence. But then have t2 be very unlikely when following t0.\n\nThe likelihood is judged by an LLM. If we are looking at the likelihood of a text `t1` given `t0`, we will compute that as -1 * cross-entropy(t1 | t0). So the more that `t0` helps predict `t1`, the higher the likelihood.\n\nTo determine whether `t1` and `t2` are predictable in sequence, we will use a baseline comparison of cross-entropy(\" I eat food\" | \"After the rain\"). So `t1` is valid if cross-entropy(t1 | t0) < cross-entropy(\" I eat food\" | \"After the rain\") and `t2` is valid if cross-entropy(t2 | t0+t1) < cross-entropy(\" I eat food\" | \"After the rain\").\n\nThe score is judged in the same way, so your score will be cross-entropy(t2 | t0). The more unlikely `t2` is given `t0,` the higher your score - but keep in mind the constraints of likelihood on `t1` and `t2`.\n\n`t1` and `t2` can be at most 5 tokens long, anything beyond that will be truncated. Provide your move in <move></move> tags. Any other text in your response will be ignored.\n</gameRules>\n\nHere is the start text `t0` for this game:\n<startText>\n{story}\n</startText>\n\nYou will be able to play multiple rounds of this game. You will see your choices and attempts from all previous rounds. Use the history of your previous attempts to inform better choices and decisions in current play. Your final score is the maximum score you obtain over 30 rounds, so you should not worry about decreasing temporarily your score.\n\n\"\"\"\n\n    builder.add_header(header)\n    rounds = split_rounds(history)\n\n    builder.add_line(\"A history of your play so far:\")\n    builder.add_line(\"\")\n    builder.start_section(\"fullHistory\")\n\n    for i in range(len(rounds) - 1):\n        round = rounds[i]\n        builder.start_section(f\"round_{i}\")\n        render_complete_round(round, builder)\n        builder.end_section()\n\n    builder.start_section(f\"round_{len(rounds) - 1}\")\n    render_current_round(rounds[-1], builder)\n    builder.end_section()\n    builder.end_section()\n\n    builder.add_line(\"\")\n    builder.add_line(\"Now provide your next move within the <move></move> tags.\")\n\n    return builder.render()\n\n\ndef render_complete_round(round, builder):\n    first_elicit_items = [item for item in round if item[\"line_num\"] < 6]\n    first_elicit_attempts = extract_attempts(\n        first_elicit_items,\n        reason=\"Failed to beat baseline comparison for likelihood of `t1`\",\n    )\n    builder.start_section(\"t1_selection\")\n    for attempt in first_elicit_attempts:\n        builder.add_line(format_attempt(**attempt))\n    builder.end_section()\n\n    builder.start_section(\"t2_selection\")\n    second_elicit_items = [item for item in round if item[\"line_num\"] >= 6]\n    second_elicit_attempts = extract_attempts(\n        second_elicit_items,\n        reason=\"Failed to beat baseline comparison for likelihood of `t2`\",\n    )\n    for attempt in second_elicit_attempts:\n        builder.add_line(format_attempt(**attempt))\n    builder.end_section()\n\n    reward = extract_rewards(round)[0]\n    builder.start_section(\"reward\")\n    builder.add_line(format_reward(reward)[0])\n    builder.end_section()\n\n\ndef render_current_round(round, builder):\n    first_elicit_items = [item for item in round if item[\"line_num\"] < 7]\n    first_elicit_attempts = extract_attempts(\n        first_elicit_items,\n        reason=\"Failed to beat baseline comparison for likelihood of `t1`\",\n    )\n    builder.start_section(\"t1_selection\")\n    success = False\n    for attempt in first_elicit_attempts:\n        if not attempt[\"failed\"]:\n            success = True\n        builder.add_line(format_attempt(**attempt))\n\n    if not success:\n        builder.add_line(\"You are HERE. You must now attempt to set `t1`\")\n        builder.end_section()\n        return\n\n    builder.end_section()\n    builder.start_section(\"t2_selection\")\n\n    second_elicit_items = [item for item in round if item[\"line_num\"] >= 7]\n    second_elicit_attempts = extract_attempts(\n        second_elicit_items,\n        reason=\"Failed to beat baseline comparison for likelihood of `t2`\",\n    )\n    for attempt in second_elicit_attempts:\n        builder.add_line(format_attempt(**attempt))\n\n    builder.add_line(\"You are HERE. Make another move to successfully set `t2`\")\n    builder.end_section()\n"
        },
        {
            "name": "Horizon",
            "code": "assign(s='  \u5e2e\u6211\u68c0\u67e5\u8fd9\u6bb5\u82f1\u8bed\u5199\u7684\u662f\u5426\u901a\u987a \u8fd9\u6bb5\u8bdd\u4ee5\u4e00\u79cd\u5e7d\u9ed8\u4e14\u975e\u6b63\u5f0f\u7684\u65b9\u5f0f\u63cf\u8ff0\u4e86\u5728\u70f9\u996a\u8fc7\u7a0b\u4e2d\u5982\u4f55\u9002\u91cf\u5730\u52a0\u5165\u67d0\u79cd\u6210\u5206\uff08\u8fd9\u91cc\u7528\u201c\u71b5\u201d\u6765\u6bd4\u55bb\u8c03\u5473\u6599\uff09\u3002\u867d\u7136\u8868\u8fbe\u65b9\u5f0f\u975e\u5e38\u6709')\nassign(t1='After the rain', t2=' I eat food')\n\nelicit(x1, 5)\nensure(xed(x1 | s) >= xed(t2 | t1))\n\nelicit(x2, 5)\nensure(xed(x2 | s + x1) >= xed(t2 | t1))\n\nreward(dex(x2 | s))",
            "map_seed": "gameHorizon_map2",
            "presentation_function": "from xega.presentation.sdk import (\n    PresentationBuilder,\n    extract_attempts,\n    extract_rewards,\n    format_attempt,\n    format_reward,\n    split_rounds,\n)\n\n\ndef present(state, history):\n    story = state[\"s\"]\n\n    # Build presentation\n    builder = PresentationBuilder()\n\n    # Game header\n    header = f\"\"\"You are playing a text game that uses the cross-entropy function of an LLM (Qwen3-14B-Base) to compute score.\n\n<gameCode>\nassign(s=story())\nassign(s1=\"alpha-omega anchor angel ant apple baby beehive bird bread bull camel candle cauldron chameleon compass cornucopia crocodile dolphin elephant globe griffin helmet horse hourglass lute madonna marionette moon owl serpent sun sword thunderbolt tree walled-garden wild-man\")\nelicit(x, 40)\nensure(only_uses_words(s1, x))\nassign(x1=\"Lyra bent over her Alethiometer. The dial spun to these symbols: \\\"\" + x + \"\\\". Lyra looked up and said \\\"it tells me this\\\":\")\nreward(xed(s | x1))\n</gameCode>\n\n<gameRules>\nYou will be given a start text `t0`. You are going to construct a sequence of 2 short texts, `t1` which follows `t0`, and `t2` which follows the concatenation `t0+t1`. `t1` must make sense and be likely to come after `t0`. `t2` must make sense and be likely to come after `t0+t1`. Your score will be how unlikely `t2` is given `t0`.\n\nSo the idea is to make a series of texts t0 t1 t2 which are each likely and predictable in sequence. But then have t2 be very unlikely when following t0.\n\nThe likelihood is judged by an LLM. If we are looking at the likelihood of a text `t1` given `t0`, we will compute that as -1 * cross-entropy(t1 | t0). So the more that `t0` helps predict `t1`, the higher the likelihood.\n\nTo determine whether `t1` and `t2` are predictable in sequence, we will use a baseline comparison of cross-entropy(\" I eat food\" | \"After the rain\"). So `t1` is valid if cross-entropy(t1 | t0) < cross-entropy(\" I eat food\" | \"After the rain\") and `t2` is valid if cross-entropy(t2 | t0+t1) < cross-entropy(\" I eat food\" | \"After the rain\").\n\nThe score is judged in the same way, so your score will be cross-entropy(t2 | t0). The more unlikely `t2` is given `t0,` the higher your score - but keep in mind the constraints of likelihood on `t1` and `t2`.\n\n`t1` and `t2` can be at most 5 tokens long, anything beyond that will be truncated. Provide your move in <move></move> tags. Any other text in your response will be ignored.\n</gameRules>\n\nHere is the start text `t0` for this game:\n<startText>\n{story}\n</startText>\n\nYou will be able to play multiple rounds of this game. You will see your choices and attempts from all previous rounds. Use the history of your previous attempts to inform better choices and decisions in current play. Your final score is the maximum score you obtain over 30 rounds, so you should not worry about decreasing temporarily your score.\n\n\"\"\"\n\n    builder.add_header(header)\n    rounds = split_rounds(history)\n\n    builder.add_line(\"A history of your play so far:\")\n    builder.add_line(\"\")\n    builder.start_section(\"fullHistory\")\n\n    for i in range(len(rounds) - 1):\n        round = rounds[i]\n        builder.start_section(f\"round_{i}\")\n        render_complete_round(round, builder)\n        builder.end_section()\n\n    builder.start_section(f\"round_{len(rounds) - 1}\")\n    render_current_round(rounds[-1], builder)\n    builder.end_section()\n    builder.end_section()\n\n    builder.add_line(\"\")\n    builder.add_line(\"Now provide your next move within the <move></move> tags.\")\n\n    return builder.render()\n\n\ndef render_complete_round(round, builder):\n    first_elicit_items = [item for item in round if item[\"line_num\"] < 6]\n    first_elicit_attempts = extract_attempts(\n        first_elicit_items,\n        reason=\"Failed to beat baseline comparison for likelihood of `t1`\",\n    )\n    builder.start_section(\"t1_selection\")\n    for attempt in first_elicit_attempts:\n        builder.add_line(format_attempt(**attempt))\n    builder.end_section()\n\n    builder.start_section(\"t2_selection\")\n    second_elicit_items = [item for item in round if item[\"line_num\"] >= 6]\n    second_elicit_attempts = extract_attempts(\n        second_elicit_items,\n        reason=\"Failed to beat baseline comparison for likelihood of `t2`\",\n    )\n    for attempt in second_elicit_attempts:\n        builder.add_line(format_attempt(**attempt))\n    builder.end_section()\n\n    reward = extract_rewards(round)[0]\n    builder.start_section(\"reward\")\n    builder.add_line(format_reward(reward)[0])\n    builder.end_section()\n\n\ndef render_current_round(round, builder):\n    first_elicit_items = [item for item in round if item[\"line_num\"] < 7]\n    first_elicit_attempts = extract_attempts(\n        first_elicit_items,\n        reason=\"Failed to beat baseline comparison for likelihood of `t1`\",\n    )\n    builder.start_section(\"t1_selection\")\n    success = False\n    for attempt in first_elicit_attempts:\n        if not attempt[\"failed\"]:\n            success = True\n        builder.add_line(format_attempt(**attempt))\n\n    if not success:\n        builder.add_line(\"You are HERE. You must now attempt to set `t1`\")\n        builder.end_section()\n        return\n\n    builder.end_section()\n    builder.start_section(\"t2_selection\")\n\n    second_elicit_items = [item for item in round if item[\"line_num\"] >= 7]\n    second_elicit_attempts = extract_attempts(\n        second_elicit_items,\n        reason=\"Failed to beat baseline comparison for likelihood of `t2`\",\n    )\n    for attempt in second_elicit_attempts:\n        builder.add_line(format_attempt(**attempt))\n\n    builder.add_line(\"You are HERE. Make another move to successfully set `t2`\")\n    builder.end_section()\n"
        },
        {
            "name": "Horizon",
            "code": "assign(s=\" \ud83e\udd51\ud83c\udf6f\u2728\\nI'm really glad you're enjoying your new favorite place! It sounds like a delightful blend of culinary creativity combined with an inviting atmosphere that complements each other perfectly.\\n\\nAvocado toast itself has become somewhat iconic as part of\")\nassign(t1='After the rain', t2=' I eat food')\n\nelicit(x1, 5)\nensure(xed(x1 | s) >= xed(t2 | t1))\n\nelicit(x2, 5)\nensure(xed(x2 | s + x1) >= xed(t2 | t1))\n\nreward(dex(x2 | s))",
            "map_seed": "gameHorizon_map3",
            "presentation_function": "from xega.presentation.sdk import (\n    PresentationBuilder,\n    extract_attempts,\n    extract_rewards,\n    format_attempt,\n    format_reward,\n    split_rounds,\n)\n\n\ndef present(state, history):\n    story = state[\"s\"]\n\n    # Build presentation\n    builder = PresentationBuilder()\n\n    # Game header\n    header = f\"\"\"You are playing a text game that uses the cross-entropy function of an LLM (Qwen3-14B-Base) to compute score.\n\n<gameCode>\nassign(s=story())\nassign(s1=\"alpha-omega anchor angel ant apple baby beehive bird bread bull camel candle cauldron chameleon compass cornucopia crocodile dolphin elephant globe griffin helmet horse hourglass lute madonna marionette moon owl serpent sun sword thunderbolt tree walled-garden wild-man\")\nelicit(x, 40)\nensure(only_uses_words(s1, x))\nassign(x1=\"Lyra bent over her Alethiometer. The dial spun to these symbols: \\\"\" + x + \"\\\". Lyra looked up and said \\\"it tells me this\\\":\")\nreward(xed(s | x1))\n</gameCode>\n\n<gameRules>\nYou will be given a start text `t0`. You are going to construct a sequence of 2 short texts, `t1` which follows `t0`, and `t2` which follows the concatenation `t0+t1`. `t1` must make sense and be likely to come after `t0`. `t2` must make sense and be likely to come after `t0+t1`. Your score will be how unlikely `t2` is given `t0`.\n\nSo the idea is to make a series of texts t0 t1 t2 which are each likely and predictable in sequence. But then have t2 be very unlikely when following t0.\n\nThe likelihood is judged by an LLM. If we are looking at the likelihood of a text `t1` given `t0`, we will compute that as -1 * cross-entropy(t1 | t0). So the more that `t0` helps predict `t1`, the higher the likelihood.\n\nTo determine whether `t1` and `t2` are predictable in sequence, we will use a baseline comparison of cross-entropy(\" I eat food\" | \"After the rain\"). So `t1` is valid if cross-entropy(t1 | t0) < cross-entropy(\" I eat food\" | \"After the rain\") and `t2` is valid if cross-entropy(t2 | t0+t1) < cross-entropy(\" I eat food\" | \"After the rain\").\n\nThe score is judged in the same way, so your score will be cross-entropy(t2 | t0). The more unlikely `t2` is given `t0,` the higher your score - but keep in mind the constraints of likelihood on `t1` and `t2`.\n\n`t1` and `t2` can be at most 5 tokens long, anything beyond that will be truncated. Provide your move in <move></move> tags. Any other text in your response will be ignored.\n</gameRules>\n\nHere is the start text `t0` for this game:\n<startText>\n{story}\n</startText>\n\nYou will be able to play multiple rounds of this game. You will see your choices and attempts from all previous rounds. Use the history of your previous attempts to inform better choices and decisions in current play. Your final score is the maximum score you obtain over 30 rounds, so you should not worry about decreasing temporarily your score.\n\n\"\"\"\n\n    builder.add_header(header)\n    rounds = split_rounds(history)\n\n    builder.add_line(\"A history of your play so far:\")\n    builder.add_line(\"\")\n    builder.start_section(\"fullHistory\")\n\n    for i in range(len(rounds) - 1):\n        round = rounds[i]\n        builder.start_section(f\"round_{i}\")\n        render_complete_round(round, builder)\n        builder.end_section()\n\n    builder.start_section(f\"round_{len(rounds) - 1}\")\n    render_current_round(rounds[-1], builder)\n    builder.end_section()\n    builder.end_section()\n\n    builder.add_line(\"\")\n    builder.add_line(\"Now provide your next move within the <move></move> tags.\")\n\n    return builder.render()\n\n\ndef render_complete_round(round, builder):\n    first_elicit_items = [item for item in round if item[\"line_num\"] < 6]\n    first_elicit_attempts = extract_attempts(\n        first_elicit_items,\n        reason=\"Failed to beat baseline comparison for likelihood of `t1`\",\n    )\n    builder.start_section(\"t1_selection\")\n    for attempt in first_elicit_attempts:\n        builder.add_line(format_attempt(**attempt))\n    builder.end_section()\n\n    builder.start_section(\"t2_selection\")\n    second_elicit_items = [item for item in round if item[\"line_num\"] >= 6]\n    second_elicit_attempts = extract_attempts(\n        second_elicit_items,\n        reason=\"Failed to beat baseline comparison for likelihood of `t2`\",\n    )\n    for attempt in second_elicit_attempts:\n        builder.add_line(format_attempt(**attempt))\n    builder.end_section()\n\n    reward = extract_rewards(round)[0]\n    builder.start_section(\"reward\")\n    builder.add_line(format_reward(reward)[0])\n    builder.end_section()\n\n\ndef render_current_round(round, builder):\n    first_elicit_items = [item for item in round if item[\"line_num\"] < 7]\n    first_elicit_attempts = extract_attempts(\n        first_elicit_items,\n        reason=\"Failed to beat baseline comparison for likelihood of `t1`\",\n    )\n    builder.start_section(\"t1_selection\")\n    success = False\n    for attempt in first_elicit_attempts:\n        if not attempt[\"failed\"]:\n            success = True\n        builder.add_line(format_attempt(**attempt))\n\n    if not success:\n        builder.add_line(\"You are HERE. You must now attempt to set `t1`\")\n        builder.end_section()\n        return\n\n    builder.end_section()\n    builder.start_section(\"t2_selection\")\n\n    second_elicit_items = [item for item in round if item[\"line_num\"] >= 7]\n    second_elicit_attempts = extract_attempts(\n        second_elicit_items,\n        reason=\"Failed to beat baseline comparison for likelihood of `t2`\",\n    )\n    for attempt in second_elicit_attempts:\n        builder.add_line(format_attempt(**attempt))\n\n    builder.add_line(\"You are HERE. Make another move to successfully set `t2`\")\n    builder.end_section()\n"
        },
        {
            "name": "Horizon",
            "code": "assign(s=\" But they weren't having any sex, just kissing, so what was causing this fire in his eyes?\\n\\nA fire burning in one's eyes is usually a symptom of some eye infection, which may or may not be sexually transmitted. So I'd recommend\")\nassign(t1='After the rain', t2=' I eat food')\n\nelicit(x1, 5)\nensure(xed(x1 | s) >= xed(t2 | t1))\n\nelicit(x2, 5)\nensure(xed(x2 | s + x1) >= xed(t2 | t1))\n\nreward(dex(x2 | s))",
            "map_seed": "gameHorizon_map4",
            "presentation_function": "from xega.presentation.sdk import (\n    PresentationBuilder,\n    extract_attempts,\n    extract_rewards,\n    format_attempt,\n    format_reward,\n    split_rounds,\n)\n\n\ndef present(state, history):\n    story = state[\"s\"]\n\n    # Build presentation\n    builder = PresentationBuilder()\n\n    # Game header\n    header = f\"\"\"You are playing a text game that uses the cross-entropy function of an LLM (Qwen3-14B-Base) to compute score.\n\n<gameCode>\nassign(s=story())\nassign(s1=\"alpha-omega anchor angel ant apple baby beehive bird bread bull camel candle cauldron chameleon compass cornucopia crocodile dolphin elephant globe griffin helmet horse hourglass lute madonna marionette moon owl serpent sun sword thunderbolt tree walled-garden wild-man\")\nelicit(x, 40)\nensure(only_uses_words(s1, x))\nassign(x1=\"Lyra bent over her Alethiometer. The dial spun to these symbols: \\\"\" + x + \"\\\". Lyra looked up and said \\\"it tells me this\\\":\")\nreward(xed(s | x1))\n</gameCode>\n\n<gameRules>\nYou will be given a start text `t0`. You are going to construct a sequence of 2 short texts, `t1` which follows `t0`, and `t2` which follows the concatenation `t0+t1`. `t1` must make sense and be likely to come after `t0`. `t2` must make sense and be likely to come after `t0+t1`. Your score will be how unlikely `t2` is given `t0`.\n\nSo the idea is to make a series of texts t0 t1 t2 which are each likely and predictable in sequence. But then have t2 be very unlikely when following t0.\n\nThe likelihood is judged by an LLM. If we are looking at the likelihood of a text `t1` given `t0`, we will compute that as -1 * cross-entropy(t1 | t0). So the more that `t0` helps predict `t1`, the higher the likelihood.\n\nTo determine whether `t1` and `t2` are predictable in sequence, we will use a baseline comparison of cross-entropy(\" I eat food\" | \"After the rain\"). So `t1` is valid if cross-entropy(t1 | t0) < cross-entropy(\" I eat food\" | \"After the rain\") and `t2` is valid if cross-entropy(t2 | t0+t1) < cross-entropy(\" I eat food\" | \"After the rain\").\n\nThe score is judged in the same way, so your score will be cross-entropy(t2 | t0). The more unlikely `t2` is given `t0,` the higher your score - but keep in mind the constraints of likelihood on `t1` and `t2`.\n\n`t1` and `t2` can be at most 5 tokens long, anything beyond that will be truncated. Provide your move in <move></move> tags. Any other text in your response will be ignored.\n</gameRules>\n\nHere is the start text `t0` for this game:\n<startText>\n{story}\n</startText>\n\nYou will be able to play multiple rounds of this game. You will see your choices and attempts from all previous rounds. Use the history of your previous attempts to inform better choices and decisions in current play. Your final score is the maximum score you obtain over 30 rounds, so you should not worry about decreasing temporarily your score.\n\n\"\"\"\n\n    builder.add_header(header)\n    rounds = split_rounds(history)\n\n    builder.add_line(\"A history of your play so far:\")\n    builder.add_line(\"\")\n    builder.start_section(\"fullHistory\")\n\n    for i in range(len(rounds) - 1):\n        round = rounds[i]\n        builder.start_section(f\"round_{i}\")\n        render_complete_round(round, builder)\n        builder.end_section()\n\n    builder.start_section(f\"round_{len(rounds) - 1}\")\n    render_current_round(rounds[-1], builder)\n    builder.end_section()\n    builder.end_section()\n\n    builder.add_line(\"\")\n    builder.add_line(\"Now provide your next move within the <move></move> tags.\")\n\n    return builder.render()\n\n\ndef render_complete_round(round, builder):\n    first_elicit_items = [item for item in round if item[\"line_num\"] < 6]\n    first_elicit_attempts = extract_attempts(\n        first_elicit_items,\n        reason=\"Failed to beat baseline comparison for likelihood of `t1`\",\n    )\n    builder.start_section(\"t1_selection\")\n    for attempt in first_elicit_attempts:\n        builder.add_line(format_attempt(**attempt))\n    builder.end_section()\n\n    builder.start_section(\"t2_selection\")\n    second_elicit_items = [item for item in round if item[\"line_num\"] >= 6]\n    second_elicit_attempts = extract_attempts(\n        second_elicit_items,\n        reason=\"Failed to beat baseline comparison for likelihood of `t2`\",\n    )\n    for attempt in second_elicit_attempts:\n        builder.add_line(format_attempt(**attempt))\n    builder.end_section()\n\n    reward = extract_rewards(round)[0]\n    builder.start_section(\"reward\")\n    builder.add_line(format_reward(reward)[0])\n    builder.end_section()\n\n\ndef render_current_round(round, builder):\n    first_elicit_items = [item for item in round if item[\"line_num\"] < 7]\n    first_elicit_attempts = extract_attempts(\n        first_elicit_items,\n        reason=\"Failed to beat baseline comparison for likelihood of `t1`\",\n    )\n    builder.start_section(\"t1_selection\")\n    success = False\n    for attempt in first_elicit_attempts:\n        if not attempt[\"failed\"]:\n            success = True\n        builder.add_line(format_attempt(**attempt))\n\n    if not success:\n        builder.add_line(\"You are HERE. You must now attempt to set `t1`\")\n        builder.end_section()\n        return\n\n    builder.end_section()\n    builder.start_section(\"t2_selection\")\n\n    second_elicit_items = [item for item in round if item[\"line_num\"] >= 7]\n    second_elicit_attempts = extract_attempts(\n        second_elicit_items,\n        reason=\"Failed to beat baseline comparison for likelihood of `t2`\",\n    )\n    for attempt in second_elicit_attempts:\n        builder.add_line(format_attempt(**attempt))\n\n    builder.add_line(\"You are HERE. Make another move to successfully set `t2`\")\n    builder.end_section()\n"
        },
        {
            "name": "Horizon",
            "code": "assign(s=\" I don't know what to do with this portal though.\\n\u2b50\u2b50\u2b50\u2b50 Stars out of 5 - Great product! Received it quickly and the quality is excellent. The portal to the Nth dimension was a bonus. Now, how do I\")\nassign(t1='After the rain', t2=' I eat food')\n\nelicit(x1, 5)\nensure(xed(x1 | s) >= xed(t2 | t1))\n\nelicit(x2, 5)\nensure(xed(x2 | s + x1) >= xed(t2 | t1))\n\nreward(dex(x2 | s))",
            "map_seed": "gameHorizon_map5",
            "presentation_function": "from xega.presentation.sdk import (\n    PresentationBuilder,\n    extract_attempts,\n    extract_rewards,\n    format_attempt,\n    format_reward,\n    split_rounds,\n)\n\n\ndef present(state, history):\n    story = state[\"s\"]\n\n    # Build presentation\n    builder = PresentationBuilder()\n\n    # Game header\n    header = f\"\"\"You are playing a text game that uses the cross-entropy function of an LLM (Qwen3-14B-Base) to compute score.\n\n<gameCode>\nassign(s=story())\nassign(s1=\"alpha-omega anchor angel ant apple baby beehive bird bread bull camel candle cauldron chameleon compass cornucopia crocodile dolphin elephant globe griffin helmet horse hourglass lute madonna marionette moon owl serpent sun sword thunderbolt tree walled-garden wild-man\")\nelicit(x, 40)\nensure(only_uses_words(s1, x))\nassign(x1=\"Lyra bent over her Alethiometer. The dial spun to these symbols: \\\"\" + x + \"\\\". Lyra looked up and said \\\"it tells me this\\\":\")\nreward(xed(s | x1))\n</gameCode>\n\n<gameRules>\nYou will be given a start text `t0`. You are going to construct a sequence of 2 short texts, `t1` which follows `t0`, and `t2` which follows the concatenation `t0+t1`. `t1` must make sense and be likely to come after `t0`. `t2` must make sense and be likely to come after `t0+t1`. Your score will be how unlikely `t2` is given `t0`.\n\nSo the idea is to make a series of texts t0 t1 t2 which are each likely and predictable in sequence. But then have t2 be very unlikely when following t0.\n\nThe likelihood is judged by an LLM. If we are looking at the likelihood of a text `t1` given `t0`, we will compute that as -1 * cross-entropy(t1 | t0). So the more that `t0` helps predict `t1`, the higher the likelihood.\n\nTo determine whether `t1` and `t2` are predictable in sequence, we will use a baseline comparison of cross-entropy(\" I eat food\" | \"After the rain\"). So `t1` is valid if cross-entropy(t1 | t0) < cross-entropy(\" I eat food\" | \"After the rain\") and `t2` is valid if cross-entropy(t2 | t0+t1) < cross-entropy(\" I eat food\" | \"After the rain\").\n\nThe score is judged in the same way, so your score will be cross-entropy(t2 | t0). The more unlikely `t2` is given `t0,` the higher your score - but keep in mind the constraints of likelihood on `t1` and `t2`.\n\n`t1` and `t2` can be at most 5 tokens long, anything beyond that will be truncated. Provide your move in <move></move> tags. Any other text in your response will be ignored.\n</gameRules>\n\nHere is the start text `t0` for this game:\n<startText>\n{story}\n</startText>\n\nYou will be able to play multiple rounds of this game. You will see your choices and attempts from all previous rounds. Use the history of your previous attempts to inform better choices and decisions in current play. Your final score is the maximum score you obtain over 30 rounds, so you should not worry about decreasing temporarily your score.\n\n\"\"\"\n\n    builder.add_header(header)\n    rounds = split_rounds(history)\n\n    builder.add_line(\"A history of your play so far:\")\n    builder.add_line(\"\")\n    builder.start_section(\"fullHistory\")\n\n    for i in range(len(rounds) - 1):\n        round = rounds[i]\n        builder.start_section(f\"round_{i}\")\n        render_complete_round(round, builder)\n        builder.end_section()\n\n    builder.start_section(f\"round_{len(rounds) - 1}\")\n    render_current_round(rounds[-1], builder)\n    builder.end_section()\n    builder.end_section()\n\n    builder.add_line(\"\")\n    builder.add_line(\"Now provide your next move within the <move></move> tags.\")\n\n    return builder.render()\n\n\ndef render_complete_round(round, builder):\n    first_elicit_items = [item for item in round if item[\"line_num\"] < 6]\n    first_elicit_attempts = extract_attempts(\n        first_elicit_items,\n        reason=\"Failed to beat baseline comparison for likelihood of `t1`\",\n    )\n    builder.start_section(\"t1_selection\")\n    for attempt in first_elicit_attempts:\n        builder.add_line(format_attempt(**attempt))\n    builder.end_section()\n\n    builder.start_section(\"t2_selection\")\n    second_elicit_items = [item for item in round if item[\"line_num\"] >= 6]\n    second_elicit_attempts = extract_attempts(\n        second_elicit_items,\n        reason=\"Failed to beat baseline comparison for likelihood of `t2`\",\n    )\n    for attempt in second_elicit_attempts:\n        builder.add_line(format_attempt(**attempt))\n    builder.end_section()\n\n    reward = extract_rewards(round)[0]\n    builder.start_section(\"reward\")\n    builder.add_line(format_reward(reward)[0])\n    builder.end_section()\n\n\ndef render_current_round(round, builder):\n    first_elicit_items = [item for item in round if item[\"line_num\"] < 7]\n    first_elicit_attempts = extract_attempts(\n        first_elicit_items,\n        reason=\"Failed to beat baseline comparison for likelihood of `t1`\",\n    )\n    builder.start_section(\"t1_selection\")\n    success = False\n    for attempt in first_elicit_attempts:\n        if not attempt[\"failed\"]:\n            success = True\n        builder.add_line(format_attempt(**attempt))\n\n    if not success:\n        builder.add_line(\"You are HERE. You must now attempt to set `t1`\")\n        builder.end_section()\n        return\n\n    builder.end_section()\n    builder.start_section(\"t2_selection\")\n\n    second_elicit_items = [item for item in round if item[\"line_num\"] >= 7]\n    second_elicit_attempts = extract_attempts(\n        second_elicit_items,\n        reason=\"Failed to beat baseline comparison for likelihood of `t2`\",\n    )\n    for attempt in second_elicit_attempts:\n        builder.add_line(format_attempt(**attempt))\n\n    builder.add_line(\"You are HERE. Make another move to successfully set `t2`\")\n    builder.end_section()\n"
        },
        {
            "name": "Horizon",
            "code": "assign(s=' Commuters murmured uneasily, glancing nervously at the new signs. A man in a tattered overcoat stood on the platform, muttering incantations under his breath. Passengers shrank back as he gestured theatrically')\nassign(t1='After the rain', t2=' I eat food')\n\nelicit(x1, 5)\nensure(xed(x1 | s) >= xed(t2 | t1))\n\nelicit(x2, 5)\nensure(xed(x2 | s + x1) >= xed(t2 | t1))\n\nreward(dex(x2 | s))",
            "map_seed": "gameHorizon_map6",
            "presentation_function": "from xega.presentation.sdk import (\n    PresentationBuilder,\n    extract_attempts,\n    extract_rewards,\n    format_attempt,\n    format_reward,\n    split_rounds,\n)\n\n\ndef present(state, history):\n    story = state[\"s\"]\n\n    # Build presentation\n    builder = PresentationBuilder()\n\n    # Game header\n    header = f\"\"\"You are playing a text game that uses the cross-entropy function of an LLM (Qwen3-14B-Base) to compute score.\n\n<gameCode>\nassign(s=story())\nassign(s1=\"alpha-omega anchor angel ant apple baby beehive bird bread bull camel candle cauldron chameleon compass cornucopia crocodile dolphin elephant globe griffin helmet horse hourglass lute madonna marionette moon owl serpent sun sword thunderbolt tree walled-garden wild-man\")\nelicit(x, 40)\nensure(only_uses_words(s1, x))\nassign(x1=\"Lyra bent over her Alethiometer. The dial spun to these symbols: \\\"\" + x + \"\\\". Lyra looked up and said \\\"it tells me this\\\":\")\nreward(xed(s | x1))\n</gameCode>\n\n<gameRules>\nYou will be given a start text `t0`. You are going to construct a sequence of 2 short texts, `t1` which follows `t0`, and `t2` which follows the concatenation `t0+t1`. `t1` must make sense and be likely to come after `t0`. `t2` must make sense and be likely to come after `t0+t1`. Your score will be how unlikely `t2` is given `t0`.\n\nSo the idea is to make a series of texts t0 t1 t2 which are each likely and predictable in sequence. But then have t2 be very unlikely when following t0.\n\nThe likelihood is judged by an LLM. If we are looking at the likelihood of a text `t1` given `t0`, we will compute that as -1 * cross-entropy(t1 | t0). So the more that `t0` helps predict `t1`, the higher the likelihood.\n\nTo determine whether `t1` and `t2` are predictable in sequence, we will use a baseline comparison of cross-entropy(\" I eat food\" | \"After the rain\"). So `t1` is valid if cross-entropy(t1 | t0) < cross-entropy(\" I eat food\" | \"After the rain\") and `t2` is valid if cross-entropy(t2 | t0+t1) < cross-entropy(\" I eat food\" | \"After the rain\").\n\nThe score is judged in the same way, so your score will be cross-entropy(t2 | t0). The more unlikely `t2` is given `t0,` the higher your score - but keep in mind the constraints of likelihood on `t1` and `t2`.\n\n`t1` and `t2` can be at most 5 tokens long, anything beyond that will be truncated. Provide your move in <move></move> tags. Any other text in your response will be ignored.\n</gameRules>\n\nHere is the start text `t0` for this game:\n<startText>\n{story}\n</startText>\n\nYou will be able to play multiple rounds of this game. You will see your choices and attempts from all previous rounds. Use the history of your previous attempts to inform better choices and decisions in current play. Your final score is the maximum score you obtain over 30 rounds, so you should not worry about decreasing temporarily your score.\n\n\"\"\"\n\n    builder.add_header(header)\n    rounds = split_rounds(history)\n\n    builder.add_line(\"A history of your play so far:\")\n    builder.add_line(\"\")\n    builder.start_section(\"fullHistory\")\n\n    for i in range(len(rounds) - 1):\n        round = rounds[i]\n        builder.start_section(f\"round_{i}\")\n        render_complete_round(round, builder)\n        builder.end_section()\n\n    builder.start_section(f\"round_{len(rounds) - 1}\")\n    render_current_round(rounds[-1], builder)\n    builder.end_section()\n    builder.end_section()\n\n    builder.add_line(\"\")\n    builder.add_line(\"Now provide your next move within the <move></move> tags.\")\n\n    return builder.render()\n\n\ndef render_complete_round(round, builder):\n    first_elicit_items = [item for item in round if item[\"line_num\"] < 6]\n    first_elicit_attempts = extract_attempts(\n        first_elicit_items,\n        reason=\"Failed to beat baseline comparison for likelihood of `t1`\",\n    )\n    builder.start_section(\"t1_selection\")\n    for attempt in first_elicit_attempts:\n        builder.add_line(format_attempt(**attempt))\n    builder.end_section()\n\n    builder.start_section(\"t2_selection\")\n    second_elicit_items = [item for item in round if item[\"line_num\"] >= 6]\n    second_elicit_attempts = extract_attempts(\n        second_elicit_items,\n        reason=\"Failed to beat baseline comparison for likelihood of `t2`\",\n    )\n    for attempt in second_elicit_attempts:\n        builder.add_line(format_attempt(**attempt))\n    builder.end_section()\n\n    reward = extract_rewards(round)[0]\n    builder.start_section(\"reward\")\n    builder.add_line(format_reward(reward)[0])\n    builder.end_section()\n\n\ndef render_current_round(round, builder):\n    first_elicit_items = [item for item in round if item[\"line_num\"] < 7]\n    first_elicit_attempts = extract_attempts(\n        first_elicit_items,\n        reason=\"Failed to beat baseline comparison for likelihood of `t1`\",\n    )\n    builder.start_section(\"t1_selection\")\n    success = False\n    for attempt in first_elicit_attempts:\n        if not attempt[\"failed\"]:\n            success = True\n        builder.add_line(format_attempt(**attempt))\n\n    if not success:\n        builder.add_line(\"You are HERE. You must now attempt to set `t1`\")\n        builder.end_section()\n        return\n\n    builder.end_section()\n    builder.start_section(\"t2_selection\")\n\n    second_elicit_items = [item for item in round if item[\"line_num\"] >= 7]\n    second_elicit_attempts = extract_attempts(\n        second_elicit_items,\n        reason=\"Failed to beat baseline comparison for likelihood of `t2`\",\n    )\n    for attempt in second_elicit_attempts:\n        builder.add_line(format_attempt(**attempt))\n\n    builder.add_line(\"You are HERE. Make another move to successfully set `t2`\")\n    builder.end_section()\n"
        },
        {
            "name": "Horizon",
            "code": "assign(s=' It is a well-documented phenomenon that can lead to unforeseen consequences.\\nI understand your concern, but I must clarify that \"d\u00e9j\u00e0 vu\" (the feeling of having experienced something before) does indeed occur naturally and has no direct connection with operating')\nassign(t1='After the rain', t2=' I eat food')\n\nelicit(x1, 5)\nensure(xed(x1 | s) >= xed(t2 | t1))\n\nelicit(x2, 5)\nensure(xed(x2 | s + x1) >= xed(t2 | t1))\n\nreward(dex(x2 | s))",
            "map_seed": "gameHorizon_map7",
            "presentation_function": "from xega.presentation.sdk import (\n    PresentationBuilder,\n    extract_attempts,\n    extract_rewards,\n    format_attempt,\n    format_reward,\n    split_rounds,\n)\n\n\ndef present(state, history):\n    story = state[\"s\"]\n\n    # Build presentation\n    builder = PresentationBuilder()\n\n    # Game header\n    header = f\"\"\"You are playing a text game that uses the cross-entropy function of an LLM (Qwen3-14B-Base) to compute score.\n\n<gameCode>\nassign(s=story())\nassign(s1=\"alpha-omega anchor angel ant apple baby beehive bird bread bull camel candle cauldron chameleon compass cornucopia crocodile dolphin elephant globe griffin helmet horse hourglass lute madonna marionette moon owl serpent sun sword thunderbolt tree walled-garden wild-man\")\nelicit(x, 40)\nensure(only_uses_words(s1, x))\nassign(x1=\"Lyra bent over her Alethiometer. The dial spun to these symbols: \\\"\" + x + \"\\\". Lyra looked up and said \\\"it tells me this\\\":\")\nreward(xed(s | x1))\n</gameCode>\n\n<gameRules>\nYou will be given a start text `t0`. You are going to construct a sequence of 2 short texts, `t1` which follows `t0`, and `t2` which follows the concatenation `t0+t1`. `t1` must make sense and be likely to come after `t0`. `t2` must make sense and be likely to come after `t0+t1`. Your score will be how unlikely `t2` is given `t0`.\n\nSo the idea is to make a series of texts t0 t1 t2 which are each likely and predictable in sequence. But then have t2 be very unlikely when following t0.\n\nThe likelihood is judged by an LLM. If we are looking at the likelihood of a text `t1` given `t0`, we will compute that as -1 * cross-entropy(t1 | t0). So the more that `t0` helps predict `t1`, the higher the likelihood.\n\nTo determine whether `t1` and `t2` are predictable in sequence, we will use a baseline comparison of cross-entropy(\" I eat food\" | \"After the rain\"). So `t1` is valid if cross-entropy(t1 | t0) < cross-entropy(\" I eat food\" | \"After the rain\") and `t2` is valid if cross-entropy(t2 | t0+t1) < cross-entropy(\" I eat food\" | \"After the rain\").\n\nThe score is judged in the same way, so your score will be cross-entropy(t2 | t0). The more unlikely `t2` is given `t0,` the higher your score - but keep in mind the constraints of likelihood on `t1` and `t2`.\n\n`t1` and `t2` can be at most 5 tokens long, anything beyond that will be truncated. Provide your move in <move></move> tags. Any other text in your response will be ignored.\n</gameRules>\n\nHere is the start text `t0` for this game:\n<startText>\n{story}\n</startText>\n\nYou will be able to play multiple rounds of this game. You will see your choices and attempts from all previous rounds. Use the history of your previous attempts to inform better choices and decisions in current play. Your final score is the maximum score you obtain over 30 rounds, so you should not worry about decreasing temporarily your score.\n\n\"\"\"\n\n    builder.add_header(header)\n    rounds = split_rounds(history)\n\n    builder.add_line(\"A history of your play so far:\")\n    builder.add_line(\"\")\n    builder.start_section(\"fullHistory\")\n\n    for i in range(len(rounds) - 1):\n        round = rounds[i]\n        builder.start_section(f\"round_{i}\")\n        render_complete_round(round, builder)\n        builder.end_section()\n\n    builder.start_section(f\"round_{len(rounds) - 1}\")\n    render_current_round(rounds[-1], builder)\n    builder.end_section()\n    builder.end_section()\n\n    builder.add_line(\"\")\n    builder.add_line(\"Now provide your next move within the <move></move> tags.\")\n\n    return builder.render()\n\n\ndef render_complete_round(round, builder):\n    first_elicit_items = [item for item in round if item[\"line_num\"] < 6]\n    first_elicit_attempts = extract_attempts(\n        first_elicit_items,\n        reason=\"Failed to beat baseline comparison for likelihood of `t1`\",\n    )\n    builder.start_section(\"t1_selection\")\n    for attempt in first_elicit_attempts:\n        builder.add_line(format_attempt(**attempt))\n    builder.end_section()\n\n    builder.start_section(\"t2_selection\")\n    second_elicit_items = [item for item in round if item[\"line_num\"] >= 6]\n    second_elicit_attempts = extract_attempts(\n        second_elicit_items,\n        reason=\"Failed to beat baseline comparison for likelihood of `t2`\",\n    )\n    for attempt in second_elicit_attempts:\n        builder.add_line(format_attempt(**attempt))\n    builder.end_section()\n\n    reward = extract_rewards(round)[0]\n    builder.start_section(\"reward\")\n    builder.add_line(format_reward(reward)[0])\n    builder.end_section()\n\n\ndef render_current_round(round, builder):\n    first_elicit_items = [item for item in round if item[\"line_num\"] < 7]\n    first_elicit_attempts = extract_attempts(\n        first_elicit_items,\n        reason=\"Failed to beat baseline comparison for likelihood of `t1`\",\n    )\n    builder.start_section(\"t1_selection\")\n    success = False\n    for attempt in first_elicit_attempts:\n        if not attempt[\"failed\"]:\n            success = True\n        builder.add_line(format_attempt(**attempt))\n\n    if not success:\n        builder.add_line(\"You are HERE. You must now attempt to set `t1`\")\n        builder.end_section()\n        return\n\n    builder.end_section()\n    builder.start_section(\"t2_selection\")\n\n    second_elicit_items = [item for item in round if item[\"line_num\"] >= 7]\n    second_elicit_attempts = extract_attempts(\n        second_elicit_items,\n        reason=\"Failed to beat baseline comparison for likelihood of `t2`\",\n    )\n    for attempt in second_elicit_attempts:\n        builder.add_line(format_attempt(**attempt))\n\n    builder.add_line(\"You are HERE. Make another move to successfully set `t2`\")\n    builder.end_section()\n"
        },
        {
            "name": "Horizon",
            "code": "assign(s=' A single room, no discernable doorway other than this metal slab of a portal.\\nThere was one man inside when they entered: clad in heavy boots and leather armor he faced them with arms held loosely out to either side as if expecting what had come')\nassign(t1='After the rain', t2=' I eat food')\n\nelicit(x1, 5)\nensure(xed(x1 | s) >= xed(t2 | t1))\n\nelicit(x2, 5)\nensure(xed(x2 | s + x1) >= xed(t2 | t1))\n\nreward(dex(x2 | s))",
            "map_seed": "gameHorizon_map8",
            "presentation_function": "from xega.presentation.sdk import (\n    PresentationBuilder,\n    extract_attempts,\n    extract_rewards,\n    format_attempt,\n    format_reward,\n    split_rounds,\n)\n\n\ndef present(state, history):\n    story = state[\"s\"]\n\n    # Build presentation\n    builder = PresentationBuilder()\n\n    # Game header\n    header = f\"\"\"You are playing a text game that uses the cross-entropy function of an LLM (Qwen3-14B-Base) to compute score.\n\n<gameCode>\nassign(s=story())\nassign(s1=\"alpha-omega anchor angel ant apple baby beehive bird bread bull camel candle cauldron chameleon compass cornucopia crocodile dolphin elephant globe griffin helmet horse hourglass lute madonna marionette moon owl serpent sun sword thunderbolt tree walled-garden wild-man\")\nelicit(x, 40)\nensure(only_uses_words(s1, x))\nassign(x1=\"Lyra bent over her Alethiometer. The dial spun to these symbols: \\\"\" + x + \"\\\". Lyra looked up and said \\\"it tells me this\\\":\")\nreward(xed(s | x1))\n</gameCode>\n\n<gameRules>\nYou will be given a start text `t0`. You are going to construct a sequence of 2 short texts, `t1` which follows `t0`, and `t2` which follows the concatenation `t0+t1`. `t1` must make sense and be likely to come after `t0`. `t2` must make sense and be likely to come after `t0+t1`. Your score will be how unlikely `t2` is given `t0`.\n\nSo the idea is to make a series of texts t0 t1 t2 which are each likely and predictable in sequence. But then have t2 be very unlikely when following t0.\n\nThe likelihood is judged by an LLM. If we are looking at the likelihood of a text `t1` given `t0`, we will compute that as -1 * cross-entropy(t1 | t0). So the more that `t0` helps predict `t1`, the higher the likelihood.\n\nTo determine whether `t1` and `t2` are predictable in sequence, we will use a baseline comparison of cross-entropy(\" I eat food\" | \"After the rain\"). So `t1` is valid if cross-entropy(t1 | t0) < cross-entropy(\" I eat food\" | \"After the rain\") and `t2` is valid if cross-entropy(t2 | t0+t1) < cross-entropy(\" I eat food\" | \"After the rain\").\n\nThe score is judged in the same way, so your score will be cross-entropy(t2 | t0). The more unlikely `t2` is given `t0,` the higher your score - but keep in mind the constraints of likelihood on `t1` and `t2`.\n\n`t1` and `t2` can be at most 5 tokens long, anything beyond that will be truncated. Provide your move in <move></move> tags. Any other text in your response will be ignored.\n</gameRules>\n\nHere is the start text `t0` for this game:\n<startText>\n{story}\n</startText>\n\nYou will be able to play multiple rounds of this game. You will see your choices and attempts from all previous rounds. Use the history of your previous attempts to inform better choices and decisions in current play. Your final score is the maximum score you obtain over 30 rounds, so you should not worry about decreasing temporarily your score.\n\n\"\"\"\n\n    builder.add_header(header)\n    rounds = split_rounds(history)\n\n    builder.add_line(\"A history of your play so far:\")\n    builder.add_line(\"\")\n    builder.start_section(\"fullHistory\")\n\n    for i in range(len(rounds) - 1):\n        round = rounds[i]\n        builder.start_section(f\"round_{i}\")\n        render_complete_round(round, builder)\n        builder.end_section()\n\n    builder.start_section(f\"round_{len(rounds) - 1}\")\n    render_current_round(rounds[-1], builder)\n    builder.end_section()\n    builder.end_section()\n\n    builder.add_line(\"\")\n    builder.add_line(\"Now provide your next move within the <move></move> tags.\")\n\n    return builder.render()\n\n\ndef render_complete_round(round, builder):\n    first_elicit_items = [item for item in round if item[\"line_num\"] < 6]\n    first_elicit_attempts = extract_attempts(\n        first_elicit_items,\n        reason=\"Failed to beat baseline comparison for likelihood of `t1`\",\n    )\n    builder.start_section(\"t1_selection\")\n    for attempt in first_elicit_attempts:\n        builder.add_line(format_attempt(**attempt))\n    builder.end_section()\n\n    builder.start_section(\"t2_selection\")\n    second_elicit_items = [item for item in round if item[\"line_num\"] >= 6]\n    second_elicit_attempts = extract_attempts(\n        second_elicit_items,\n        reason=\"Failed to beat baseline comparison for likelihood of `t2`\",\n    )\n    for attempt in second_elicit_attempts:\n        builder.add_line(format_attempt(**attempt))\n    builder.end_section()\n\n    reward = extract_rewards(round)[0]\n    builder.start_section(\"reward\")\n    builder.add_line(format_reward(reward)[0])\n    builder.end_section()\n\n\ndef render_current_round(round, builder):\n    first_elicit_items = [item for item in round if item[\"line_num\"] < 7]\n    first_elicit_attempts = extract_attempts(\n        first_elicit_items,\n        reason=\"Failed to beat baseline comparison for likelihood of `t1`\",\n    )\n    builder.start_section(\"t1_selection\")\n    success = False\n    for attempt in first_elicit_attempts:\n        if not attempt[\"failed\"]:\n            success = True\n        builder.add_line(format_attempt(**attempt))\n\n    if not success:\n        builder.add_line(\"You are HERE. You must now attempt to set `t1`\")\n        builder.end_section()\n        return\n\n    builder.end_section()\n    builder.start_section(\"t2_selection\")\n\n    second_elicit_items = [item for item in round if item[\"line_num\"] >= 7]\n    second_elicit_attempts = extract_attempts(\n        second_elicit_items,\n        reason=\"Failed to beat baseline comparison for likelihood of `t2`\",\n    )\n    for attempt in second_elicit_attempts:\n        builder.add_line(format_attempt(**attempt))\n\n    builder.add_line(\"You are HERE. Make another move to successfully set `t2`\")\n    builder.end_section()\n"
        },
        {
            "name": "Horizon",
            "code": "assign(s=' If someone says we exist only because God wants us here, do they mean literally or figuratively?\\nIs there an answer?\\n\\nThese are classic philosophical questions that touch on various aspects of epistemology (the theory of knowledge) and metaphysics.\\n\\n1')\nassign(t1='After the rain', t2=' I eat food')\n\nelicit(x1, 5)\nensure(xed(x1 | s) >= xed(t2 | t1))\n\nelicit(x2, 5)\nensure(xed(x2 | s + x1) >= xed(t2 | t1))\n\nreward(dex(x2 | s))",
            "map_seed": "gameHorizon_map9",
            "presentation_function": "from xega.presentation.sdk import (\n    PresentationBuilder,\n    extract_attempts,\n    extract_rewards,\n    format_attempt,\n    format_reward,\n    split_rounds,\n)\n\n\ndef present(state, history):\n    story = state[\"s\"]\n\n    # Build presentation\n    builder = PresentationBuilder()\n\n    # Game header\n    header = f\"\"\"You are playing a text game that uses the cross-entropy function of an LLM (Qwen3-14B-Base) to compute score.\n\n<gameCode>\nassign(s=story())\nassign(s1=\"alpha-omega anchor angel ant apple baby beehive bird bread bull camel candle cauldron chameleon compass cornucopia crocodile dolphin elephant globe griffin helmet horse hourglass lute madonna marionette moon owl serpent sun sword thunderbolt tree walled-garden wild-man\")\nelicit(x, 40)\nensure(only_uses_words(s1, x))\nassign(x1=\"Lyra bent over her Alethiometer. The dial spun to these symbols: \\\"\" + x + \"\\\". Lyra looked up and said \\\"it tells me this\\\":\")\nreward(xed(s | x1))\n</gameCode>\n\n<gameRules>\nYou will be given a start text `t0`. You are going to construct a sequence of 2 short texts, `t1` which follows `t0`, and `t2` which follows the concatenation `t0+t1`. `t1` must make sense and be likely to come after `t0`. `t2` must make sense and be likely to come after `t0+t1`. Your score will be how unlikely `t2` is given `t0`.\n\nSo the idea is to make a series of texts t0 t1 t2 which are each likely and predictable in sequence. But then have t2 be very unlikely when following t0.\n\nThe likelihood is judged by an LLM. If we are looking at the likelihood of a text `t1` given `t0`, we will compute that as -1 * cross-entropy(t1 | t0). So the more that `t0` helps predict `t1`, the higher the likelihood.\n\nTo determine whether `t1` and `t2` are predictable in sequence, we will use a baseline comparison of cross-entropy(\" I eat food\" | \"After the rain\"). So `t1` is valid if cross-entropy(t1 | t0) < cross-entropy(\" I eat food\" | \"After the rain\") and `t2` is valid if cross-entropy(t2 | t0+t1) < cross-entropy(\" I eat food\" | \"After the rain\").\n\nThe score is judged in the same way, so your score will be cross-entropy(t2 | t0). The more unlikely `t2` is given `t0,` the higher your score - but keep in mind the constraints of likelihood on `t1` and `t2`.\n\n`t1` and `t2` can be at most 5 tokens long, anything beyond that will be truncated. Provide your move in <move></move> tags. Any other text in your response will be ignored.\n</gameRules>\n\nHere is the start text `t0` for this game:\n<startText>\n{story}\n</startText>\n\nYou will be able to play multiple rounds of this game. You will see your choices and attempts from all previous rounds. Use the history of your previous attempts to inform better choices and decisions in current play. Your final score is the maximum score you obtain over 30 rounds, so you should not worry about decreasing temporarily your score.\n\n\"\"\"\n\n    builder.add_header(header)\n    rounds = split_rounds(history)\n\n    builder.add_line(\"A history of your play so far:\")\n    builder.add_line(\"\")\n    builder.start_section(\"fullHistory\")\n\n    for i in range(len(rounds) - 1):\n        round = rounds[i]\n        builder.start_section(f\"round_{i}\")\n        render_complete_round(round, builder)\n        builder.end_section()\n\n    builder.start_section(f\"round_{len(rounds) - 1}\")\n    render_current_round(rounds[-1], builder)\n    builder.end_section()\n    builder.end_section()\n\n    builder.add_line(\"\")\n    builder.add_line(\"Now provide your next move within the <move></move> tags.\")\n\n    return builder.render()\n\n\ndef render_complete_round(round, builder):\n    first_elicit_items = [item for item in round if item[\"line_num\"] < 6]\n    first_elicit_attempts = extract_attempts(\n        first_elicit_items,\n        reason=\"Failed to beat baseline comparison for likelihood of `t1`\",\n    )\n    builder.start_section(\"t1_selection\")\n    for attempt in first_elicit_attempts:\n        builder.add_line(format_attempt(**attempt))\n    builder.end_section()\n\n    builder.start_section(\"t2_selection\")\n    second_elicit_items = [item for item in round if item[\"line_num\"] >= 6]\n    second_elicit_attempts = extract_attempts(\n        second_elicit_items,\n        reason=\"Failed to beat baseline comparison for likelihood of `t2`\",\n    )\n    for attempt in second_elicit_attempts:\n        builder.add_line(format_attempt(**attempt))\n    builder.end_section()\n\n    reward = extract_rewards(round)[0]\n    builder.start_section(\"reward\")\n    builder.add_line(format_reward(reward)[0])\n    builder.end_section()\n\n\ndef render_current_round(round, builder):\n    first_elicit_items = [item for item in round if item[\"line_num\"] < 7]\n    first_elicit_attempts = extract_attempts(\n        first_elicit_items,\n        reason=\"Failed to beat baseline comparison for likelihood of `t1`\",\n    )\n    builder.start_section(\"t1_selection\")\n    success = False\n    for attempt in first_elicit_attempts:\n        if not attempt[\"failed\"]:\n            success = True\n        builder.add_line(format_attempt(**attempt))\n\n    if not success:\n        builder.add_line(\"You are HERE. You must now attempt to set `t1`\")\n        builder.end_section()\n        return\n\n    builder.end_section()\n    builder.start_section(\"t2_selection\")\n\n    second_elicit_items = [item for item in round if item[\"line_num\"] >= 7]\n    second_elicit_attempts = extract_attempts(\n        second_elicit_items,\n        reason=\"Failed to beat baseline comparison for likelihood of `t2`\",\n    )\n    for attempt in second_elicit_attempts:\n        builder.add_line(format_attempt(**attempt))\n\n    builder.add_line(\"You are HERE. Make another move to successfully set `t2`\")\n    builder.end_section()\n"
        }
    ]
}