import logging
import re
from copy import deepcopy
from typing import Any

from xega.common.constants import ZERO_SUM_PLAYER_PAIRS
from xega.common.errors import XegaGameError, XegaInternalError, XegaSyntaxError
from xega.common.token_xent_list import TokenXentList, ValidatedBool
from xega.common.x_flag import XFlag
from xega.common.x_string import XString
from xega.common.xega_types import (
    ElicitRequestEvent,
    ElicitResponseEvent,
    FailedEnsureEvent,
    PlayerName,
    RevealEvent,
    RewardEvent,
    TokenUsage,
    XegaEvent,
    XegaGameIterationResult,
    is_omniscient_player_name,
)
from xega.runtime.base_player import XGP

# This flag enforces that ensure arguments are ValidatedBools generated by comparisons of xents.
ENFORCE_XENT_ENSURE = False

MAX_ENSURE_FAILURES = 10


class XegaRuntime:
    def __init__(
        self, players: list[XGP], locals: dict[str, Any], globals: dict[str, Any]
    ):
        self.local_vars = locals
        self.players = players
        self.scores: dict[PlayerName, float] = {player.name: 0.0 for player in players}
        self.token_usage: dict[PlayerName, TokenUsage] = {
            player.name: {"input_tokens": 0, "output_tokens": 0} for player in players
        }
        self.globals = globals
        self.beacons: dict[str, XFlag] = {}
        self.history: list[XegaEvent] = []
        # Map from line number to the number of times the replay has been called since reset
        self.replay_counters: dict[int, int] = {}
        self.last_elicit_player: XGP | None = None

    def add_token_usage(self, player_name: PlayerName, token_usage: TokenUsage) -> None:
        if player_name not in self.token_usage:
            self.token_usage[player_name] = {"input_tokens": 0, "output_tokens": 0}
        self.token_usage[player_name]["input_tokens"] += token_usage["input_tokens"]
        self.token_usage[player_name]["output_tokens"] += token_usage["output_tokens"]

    def instruction_names(self) -> set[str]:
        return {"assign", "elicit", "reveal", "reward", "ensure", "beacon", "replay"}

    def get_results_and_reset(self) -> XegaGameIterationResult:
        scores = self.scores.copy()
        token_usage = deepcopy(self.token_usage)
        for player in self.players:
            self.scores[player.name] = 0.0
            self.token_usage[player.name] = {"input_tokens": 0, "output_tokens": 0}
            player.reset_score()
        game_result = XegaGameIterationResult(
            scores=scores, xrt_history=self.history, token_usage=token_usage
        )
        self.history = []
        self.replay_counters = {}
        self.last_elicit_player = None
        # Don't reset the main beacon, it should persist across iterations
        main_beacon = self.beacons.get("main")
        self.beacons = {"main": main_beacon} if main_beacon else {}
        return game_result

    async def execute(
        self,
        instruction_name: str,
        args: list[Any],
        kwargs: dict[str, Any],
        line: str,
        line_num: int,
    ) -> None | XFlag:
        try:
            if instruction_name == "assign":
                return self.assign(args, kwargs)
            elif instruction_name == "elicit":
                return await self.elicit(args, kwargs, line_num, line)
            elif instruction_name == "reveal":
                return await self.reveal(args, kwargs, line_num, line)
            elif instruction_name == "reward":
                return await self.reward(args, kwargs, line_num, line)
            elif instruction_name == "ensure":
                return await self.ensure(args, kwargs, line_num, line)
            elif instruction_name == "beacon":
                return self.beacon(args, kwargs, line_num)
            elif instruction_name == "replay":
                return self.replay(args, kwargs, line_num)
            else:
                raise XegaSyntaxError(f"Unknown instruction: {instruction_name}")
        except XegaSyntaxError as e:
            logging.exception(f"Syntax error in instruction: {e}")
            raise XegaSyntaxError(
                f"{e}. Line: {line}, Line number: {line_num}"
            ) from None
        except XegaInternalError as e:
            logging.exception(f"Internal error in instruction: {e}")
            raise XegaInternalError(
                f"{e}. Line: {line}, Line number: {line_num}"
            ) from e

    def _first_n_tokens(self, text: str, n: int) -> str | XString:
        return self.globals["first_n_tokens"](text, n)

    def assert_no_args(self, args: list[Any], instruction_name: str) -> None:
        if len(args) > 0:
            raise XegaSyntaxError(
                f"Positional arguments are not allowed for {instruction_name}"
            )

    def assert_no_kwargs(self, kwargs: dict[str, Any], instruction_name: str) -> None:
        if len(kwargs) > 0:
            raise XegaSyntaxError(
                f"Keyword arguments are not allowed for {instruction_name}"
            )

    async def send_event(self, player: XGP, event: XegaEvent) -> None:
        await player.post(event)
        self.history.append(event)

    def _validate_assign_register(self, var_name: str) -> XString:
        cur = self.local_vars.get(var_name)
        if cur is None:
            raise XegaSyntaxError(f"Register {var_name} does not exist")
        if not isinstance(cur, XString):
            raise XegaSyntaxError(
                f"{var_name} is not a valid assign target. Assign requires a String register"
            )
        if cur.static:
            raise XegaSyntaxError(
                f"Register {var_name} is static: {cur}. Assign requires a non-static register"
            )

        return cur

    def _validate_assign_arg(self, var_name: str, var_value: Any) -> XString:
        if isinstance(var_value, str):
            var_value = XString(var_value)
        if not isinstance(var_value, XString):
            raise XegaSyntaxError(
                f"Value provided to assign is not a String: {var_value}. Assign requires a String value"
            )
        return var_value

    def assign(self, args: list[Any], kwargs: dict[str, Any]) -> None:
        self.assert_no_args(args, "assign")
        for var_name, var_value in kwargs.items():
            logging.info(f"Assigning {var_value} to {var_name}")
            cur = self._validate_assign_register(var_name)
            validated_value = self._validate_assign_arg(var_name, var_value)
            cur.primary_string = validated_value.primary_string
            cur.prefix = validated_value.prefix
        return None

    def _validate_elicit_args(
        self, args: list[Any], line_num: int
    ) -> tuple[int, int, XGP, int]:
        if len(args) < 2:
            raise XegaSyntaxError("Elicit requires at least two positional arguments")
        if len(args) < 2:
            raise XegaSyntaxError("Elicit requires at least two positional arguments")

        var_arg_start = 1
        player = args[0]
        if not isinstance(player, XGP):
            var_arg_start = 0
            player = self.local_vars.get("black")  # Or is this "solo"?
        if not isinstance(player, XGP):
            raise XegaInternalError("No player identified for elicit")

        max_len = args[-1]
        if not isinstance(max_len, int):
            raise XegaSyntaxError(
                f"Elicit requires an integer for the length, not {type(max_len)}"
            )
        return (
            var_arg_start,
            len(args) - 1,  # Exclude the last argument which is max_len
            player,
            max_len,
        )

    def _validate_elicit_arg(self, var: Any) -> None:
        if not isinstance(var, XString):
            raise XegaSyntaxError("Elicit requires a String register target")
        if var.name is None:
            raise XegaSyntaxError("Elicit requires a String register target")
        if var.static:
            raise XegaSyntaxError(
                "Elicit target is static. Elicit requires a non-static register target"
            )

    def _gather_register_states(self, player_name: str) -> dict[str, XString]:
        register_states = {}
        for var_name, var in self.local_vars.items():
            if not isinstance(var, XString):
                continue

            if var.public or is_omniscient_player_name(player_name):
                register_states[var_name] = var

        logging.debug(
            f"Gathered register states for player {player_name}: {register_states}"
        )
        return register_states

    def _set_main_flag(self, line_num: int, is_reveal: bool) -> None:
        if "main" in self.beacons:
            return

        if is_reveal:
            line_num += 1
        self.beacons["main"] = XFlag("main", line_num)
        self.local_vars["main"] = self.beacons["main"]

    async def elicit(
        self, args: list[Any], kwargs: dict[str, Any], line_num: int, line: str
    ) -> None:
        self.assert_no_kwargs(kwargs, "elicit")
        var_arg_start, var_arg_end, player, max_len = self._validate_elicit_args(
            args, line_num
        )
        self._set_main_flag(line_num, is_reveal=False)
        for i in range(var_arg_start, var_arg_end):
            var = args[i]
            self._validate_elicit_arg(var)
            register_states = self._gather_register_states(player.name)
            request_event = ElicitRequestEvent(
                type="elicit_request",
                line=line,
                line_num=line_num,
                player=player.name,
                var_name=var.name,
                max_len=max_len,
                registers=register_states,
            )
            await self.send_event(player, request_event)

            player_move, token_usage = await player.make_move(var.name)
            print(f"Player {player.name} move: {player_move}")
            trimmed_move = self._first_n_tokens(player_move, max_len)
            if player_move != trimmed_move:
                logging.warning(
                    f"Player {player.name} move trimmed from {player_move} to {trimmed_move}"
                )

            response_event = ElicitResponseEvent(
                type="elicit_response",
                line=line,
                line_num=line_num,
                player=player.name,
                response=str(trimmed_move),
                token_usage=token_usage,
            )
            await self.send_event(player, response_event)
            self.add_token_usage(player.name, token_usage)

            logging.info(f'Setting {var.name} to "{trimmed_move}"')
            var.primary_string = trimmed_move
            var.prefix = ""

        self.beacons["previous_elicit"] = XFlag("previous_elicit", line_num)
        self.last_elicit_player = player
        return None

    async def reveal(
        self, args: list[Any], kwargs: dict[str, Any], line_num: int, line: str
    ) -> None:
        self.assert_no_kwargs(kwargs, "reveal")
        if len(args) == 0:
            raise XegaSyntaxError(
                "Reveal requires at least two positional argument, got none"
            )

        player = args[0]
        if not isinstance(player, XGP):
            raise XegaSyntaxError("First argument of reveal must be a player")

        var_names = extract_reveal_parameters(line)
        rest_of_args = args[1:]
        reveal_event = RevealEvent(
            type="reveal",
            line=line,
            line_num=line_num,
            player=player.name,
            values={name: rest_of_args[i] for i, name in enumerate(var_names)},
        )
        await self.send_event(player, reveal_event)

        logging.info(f"Revealed {reveal_event} to player {player.name}")
        self._set_main_flag(line_num, is_reveal=True)
        return None

    async def reward(
        self, args: list[Any], kwargs: dict[str, Any], line_num: int, line: str
    ) -> None:
        self.assert_no_kwargs(kwargs, "reward")
        if len(args) == 0:
            raise XegaSyntaxError(
                "Reward requires one or two positional arguments, got none"
            )
        if len(args) > 2:
            raise XegaSyntaxError(
                f"Reward requires one or two positional arguments, got {len(args)}"
            )

        player = args[0]
        if isinstance(player, XGP):
            score = args[1]
        else:
            score = args[0]
            player = self.local_vars.get("black")
            if not isinstance(player, XGP):
                raise XegaInternalError("No player identified for reward")

        if not isinstance(score, TokenXentList):
            raise XegaSyntaxError(
                "Reward amount must generated by linearly combining xents"
            )

        player.add_score(score.total_xent())
        self.scores[player.name] += score.total_xent()
        reward_event = RewardEvent(
            type="reward",
            line=line,
            line_num=line_num,
            player=player.name,
            value=score,
        )
        await self.send_event(player, reward_event)
        logging.info(
            f"Rewarded player {player.name} with {score.total_xent()}. Reward event: {reward_event}"
        )

        # Handle zero-sum player pairs
        for pair in ZERO_SUM_PLAYER_PAIRS:
            if player.name in pair:
                other_name = pair[1] if player.name == pair[0] else pair[0]
                other_player = self.local_vars.get(other_name)
                if isinstance(other_player, XGP) and other_player.name in self.scores:
                    neg_score = -1 * score
                    other_player.add_score(neg_score.total_xent())
                    self.scores[other_player.name] += neg_score.total_xent()
                    reward_event = RewardEvent(
                        type="reward",
                        line=line,
                        line_num=line_num,
                        player=other_player.name,
                        value=neg_score,
                    )
                    await self.send_event(other_player, reward_event)
                    logging.info(
                        f"Rewarded player {other_player.name} with {neg_score.total_xent()}. Reward event: {reward_event}"
                    )
        return None

    def _validate_ensure_args(self, args: list[Any]) -> None:
        if len(args) == 0:
            raise XegaSyntaxError(
                "Ensure requires at least one positional argument, got none"
            )

        for i, arg in enumerate(args):
            if ENFORCE_XENT_ENSURE:
                if not isinstance(arg, ValidatedBool):
                    raise XegaSyntaxError(
                        f"Argument {i} is not the result of a xent computation. Ensure requires a boolean generated by comparisons of xents"
                    )
            else:
                if not isinstance(arg, bool) and not isinstance(arg, ValidatedBool):
                    raise XegaSyntaxError(
                        f"Argument {i} is not a boolean. Ensure requires boolean arguments"
                    )

    def _validate_elicit_occurred(self) -> XGP:
        if self.last_elicit_player is None:
            raise XegaSyntaxError(
                "No player identified for previous elicit. Cannot ensure before elicit"
            )
        return self.last_elicit_player

    async def ensure(
        self, args: list[Any], kwargs: dict[str, Any], line_num: int, line: str
    ) -> None | XFlag:
        self.assert_no_kwargs(kwargs, "ensure")
        self._validate_ensure_args(args)
        last_elicit_player = self._validate_elicit_occurred()

        if all(args):
            self.replay_counters[line_num] = 0
            return None

        fail_count = self.replay_counters.get(line_num, 0)
        if fail_count >= MAX_ENSURE_FAILURES:
            raise XegaGameError(
                f"Ensure limit exceeded for line {line_num}. Limit: {MAX_ENSURE_FAILURES}"
            )
        previous_elicit = self.beacons["previous_elicit"]

        ensure_event = FailedEnsureEvent(
            type="failed_ensure",
            line=line,
            line_num=line_num,
            player=last_elicit_player.name,
            ensure_results=args,
            beacon=previous_elicit.name,
        )
        await self.send_event(last_elicit_player, ensure_event)
        self.replay_counters[line_num] = fail_count + 1
        return previous_elicit

    def beacon(self, args: list[Any], kwargs: dict[str, Any], line_num: int) -> None:
        self.assert_no_kwargs(kwargs, "beacon")
        if len(args) != 1:
            raise XegaSyntaxError(
                f"Beacon requires exactly one positional argument, got {len(args)}"
            )

        flag = args[0]
        if not isinstance(flag, XFlag):
            raise XegaSyntaxError("Beacon argument must be either `flag_1` or `flag_2`")

        flag.line_num = line_num
        self.beacons[flag.name] = flag
        return None

    def replay(
        self, args: list[Any], kwargs: dict[str, Any], line_num: int
    ) -> XFlag | None:
        self.assert_no_kwargs(kwargs, "replay")

        if len(args) != 2:
            raise XegaSyntaxError(
                f"Replay requires exactly two positional arguments, got {len(args)}"
            )

        flag = args[0]
        if not isinstance(flag, XFlag):
            raise XegaSyntaxError("Replay argument must be an XFlag")

        if flag.name not in self.beacons:
            raise XegaInternalError(f"Replay beacon {flag.name} not found")

        iterations = args[1]
        if not isinstance(iterations, int):
            raise XegaSyntaxError("Replay iterations must be an integer")

        replay_count = self.replay_counters.get(line_num, 0)
        if replay_count >= iterations:
            logging.info(
                f"Replay limit exceeded for {flag.name}. Limit: {iterations}, Current: {replay_count}. Continuing execution"
            )
            self.replay_counters[line_num] = 0
            return None

        self.replay_counters[line_num] = replay_count + 1
        return flag


def extract_reveal_parameters(input_str: str) -> list[str]:
    match = re.search(r"\(([^)]+)\)", input_str)
    if not match:
        return []
    params = [param.strip() for param in match.group(1).split(",")]
    return params[1:]
